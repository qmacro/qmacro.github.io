2020-03-23-annotated-links-episode-58-of-hands-on-sap-dev-with-qmacro
Annotated links: Episode 58 of Hands-on SAP dev with qmacro
technology-blog-sap
2020-03-23
https://community.sap.com/t5/technology-blogs-by-sap/annotated-links-episode-58-of-hands-on-sap-dev-with-qmacro/ba-p/13437995
<EM>This is a searchable description of the content of a live stream recording, specifically <STRONG>‚ÄúEp.58 - Digging deeper into OAuth 2.0 for CF APIs‚Äù</STRONG> in the ‚Äú<A href="https://bit.ly/handsonsapdev" target="_blank" rel="nofollow noopener noreferrer">Hands-on SAP dev with qmacro</A>‚Äù series. There are links directly to specific highlights in the video recording. For links to annotations of other episodes, please see the ‚Äú<A href="https://bit.ly/handsonsapdev#replays" target="_blank" rel="nofollow noopener noreferrer">Catch the replays</A>‚Äù section of the series blog post.</EM><BR />
<BR />
This episode was streamed live on Fri 20 Mar and is approximately 60 minutes in length. The stream recording is <A href="https://www.youtube.com/watch?v=AjuwSJeAUy8" target="_blank" rel="nofollow noopener noreferrer">available on YouTube</A>.<BR />
<BR />
<IMG class="migrated-image" src="https://community.sap.com/legacyfs/online/storage/blog_attachments/2020/03/Screenshot-2020-03-23-at-16.00.40.png" /><BR />
<BR />
Brief synopsis: In the previous episode we put the pieces together on how the "Client Credentials" grant type works with the API Hub and the CF Workflow APIs. Now it‚Äôs time for us to dig even deeper and look into alternative flows. Buckle up!<BR />
<BR />
<A href="https://www.youtube.com/watch?v=AjuwSJeAUy8&amp;t=00h01m00s" target="_blank" rel="nofollow noopener noreferrer">00:01:00</A> Live stream starts.<BR />
<BR />
<A href="https://www.youtube.com/watch?v=AjuwSJeAUy8&amp;t=00h03m00s" target="_blank" rel="nofollow noopener noreferrer">00:03:00</A> Switching to the main scene showing some Pivotal documentation on OAuth 2.0, specifically describing four <A href="https://docs.pivotal.io/p-identity/1-10/grant-types.html" target="_blank" rel="nofollow noopener noreferrer">OAuth 2.0 Grant Types</A>: ‚ÄúAuthorization Code‚Äù, ‚ÄúClient Credentials‚Äù, ‚ÄúResource Owner Password‚Äù and ‚ÄúImplicit‚Äù. Considering what we‚Äôve done with OAuth so far, we remember that last week we used the ‚ÄúClient Credentials‚Äù grant type (or ‚Äúflow‚Äù).<BR />
<BR />
<A href="https://www.youtube.com/watch?v=AjuwSJeAUy8&amp;t=00h07m40s" target="_blank" rel="nofollow noopener noreferrer">00:07:40</A> Earlier on, back in <A href="https://bit.ly/handsonsapdev#ep51" target="_blank" rel="nofollow noopener noreferrer">Ep.51</A> we used the ‚ÄúResource Owner Password‚Äù grant type which, as we‚Äôll see shortly, was quite controversial!<BR />
<BR />
<A href="https://www.youtube.com/watch?v=AjuwSJeAUy8&amp;t=00h08m15s" target="_blank" rel="nofollow noopener noreferrer">00:08:15</A> Now that we‚Äôve established the different grant types (or so we think), we have a brief look at the official OAuth 2.0 website (crazy idea, but hey) and notice something interesting. There are also four grant types listed here, under ‚Äúmost common‚Äù ‚Ä¶ but they‚Äôre not the same four!<BR />
<BR />
Two are the same, specifically ‚ÄúAuthorization Code‚Äù and ‚ÄúClient Credentials‚Äù. These, as we‚Äôll figure out, are indeed very common and in use in many contexts. But then the other two are different. The first is ‚ÄúDevice Code‚Äù, which to me seems more of an edge case flow, for ‚Äúbrowserless or input-constrained devices‚Äù. The second is more interesting. It‚Äôs ‚ÄúRefresh Token‚Äù, which turns out to be what I‚Äôm suddenly going to call a ‚Äúside flow‚Äù, i.e.&nbsp;related to the ‚ÄúAuthorization Code‚Äù flow, where an access token can be refreshed.<BR />
<BR />
<A href="https://www.youtube.com/watch?v=AjuwSJeAUy8&amp;t=00h09m40s" target="_blank" rel="nofollow noopener noreferrer">00:09:40</A> Scrolling further down, to our surprise, we see that the other two grant types that we listed already (from the Pivotal page), ‚ÄúImplicit‚Äù and ‚Äú[Resource Owner] Password‚Äù, are listed under the title ‚ÄúLegacy‚Äù! Looking into this a bit more, I came upon a definitive document from the Internet Engineering Task Force (IETF, one of the standards bodies that ensures that the interwebs work well) ‚Äú<A href="https://tools.ietf.org/html/draft-ietf-oauth-security-topics-13" target="_blank" rel="nofollow noopener noreferrer">OAuth 2.0 Security Best Current Practice</A>, specifically <A href="https://tools.ietf.org/html/draft-ietf-oauth-security-topics-13#section-3.4" target="_blank" rel="nofollow noopener noreferrer">Section 3.4 Resource Owner Password Credentials Grant</A>, where it says <A href="https://tools.ietf.org/html/rfc2119" target="_blank" rel="nofollow noopener noreferrer">in no uncertain terms</A> that this flow MUST NOT be used. For good reasons, explained in the document. Moreover, the‚ÄùImplicit" flow SHOULD NOT be used either.<BR />
<BR />
<A href="https://www.youtube.com/watch?v=AjuwSJeAUy8&amp;t=00h11m45s" target="_blank" rel="nofollow noopener noreferrer">00:11:45</A> We‚Äôre going to take a deep look at the ‚ÄúAuthorization Code‚Äù grant type now, which, along with the ‚ÄúClient Credentials‚Äù grant type, is the most common; and the former is relevant when there‚Äôs a human involved.<BR />
<BR />
<A href="https://www.youtube.com/watch?v=AjuwSJeAUy8&amp;t=00h12m40s" target="_blank" rel="nofollow noopener noreferrer">00:12:40</A> Describing where we left off in the <A href="https://bit.ly/handsonsapdev#ep57" target="_blank" rel="nofollow noopener noreferrer">previous episode</A>, with an instance of the Workflow service, and there‚Äôs a couple of workflow definitions already deployed - <CODE>orderprocess</CODE>, which related to some other activity I‚Äôm involved in, and <CODE>simpleworkflow</CODE> which we‚Äôll use for these experiments. It‚Äôs just a definition that starts and then immediately ends.<BR />
<BR />
<A href="https://www.youtube.com/watch?v=AjuwSJeAUy8&amp;t=00h14m15s" target="_blank" rel="nofollow noopener noreferrer">00:14:15</A> Just noting that when you deploy a workflow definition as an MTA module, a service key is generated for you. This is in case the other service key(s) disappear, as, in reality, they should be treated as potentially ephemeral, or at least deletable.<BR />
<BR />
<A href="https://www.youtube.com/watch?v=AjuwSJeAUy8&amp;t=00h15m00s" target="_blank" rel="nofollow noopener noreferrer">00:15:00</A> Moving to the terminal now (yes, <A href="https://twitter.com/search?q=%23TheFutureIsTerminal" target="_blank" rel="nofollow noopener noreferrer">#TheFutureIsTerminal</A> to explore. I‚Äôve already logged into and authenticaed with the CF endpoint with this temporary test user I‚Äôm using today, and looking at the service instance list we can see the workflow service instance there. So far so good.<BR />
<PRE><CODE>-&gt; cf s<BR />
Getting services in org p2001351149trial / space dev ...<BR />
<BR />
name                               service           plan          bound apps                                 last operation     broker                                                       upgrade available<BR />
portal_resources_workflowtiles     portal            standard      workflowtilesApprouter, workflowtilesFLP   create succeeded   sm-portal-fbae912e-4046-4304-90ad-b6d8ed1fa3be<BR />
uaa_workflowtiles                  xsuaa             application   workflowtilesApprouter, workflowtilesFLP   create succeeded   sm-xsuaa-9ef36350-f975-4194-a399-54db361e79b5<BR />
workflow                           workflow          lite          workflowtilesApprouter, workflowtilesFLP   update succeeded   sm-workflow-broker-d2b48385-f83e-4601-9830-0db967aaa2f5<BR />
workflowtiles_html5_repo_runtime   html5-apps-repo   app-runtime   workflowtilesApprouter                     create succeeded   sm-html5-apps-repo-sb-ebcb2b69-24a5-408e-be00-02066b302b78</CODE></PRE><BR />
<A href="https://www.youtube.com/watch?v=AjuwSJeAUy8&amp;t=00h16m10s" target="_blank" rel="nofollow noopener noreferrer">00:16:10</A> We can also take a look at the service keys that we saw summarised in the web interface, like this:<BR />
<PRE><CODE>-&gt; cf service-keys workflow<BR />
Getting keys for service instance workflow ...<BR />
<BR />
name<BR />
OrderProcess-workflow-credentials<BR />
SimpleWorkflow-workflow-credentials</CODE></PRE><BR />
<A href="https://www.youtube.com/watch?v=AjuwSJeAUy8&amp;t=00h16m40s" target="_blank" rel="nofollow noopener noreferrer">00:16:40</A> Grabbing the service key details for the <CODE>SimpleWorkflow-workflow-credentials</CODE> service key so that we can dig into those details programatically later on:<BR />
<PRE><CODE>-&gt; cf service-key workflow SimpleWorkflow-workflow-credentials &gt; keys.json</CODE></PRE><BR />
We have to edit this now to remove the noise that the <CODE>cf</CODE> command spat out when executing this request (<CODE>cf</CODE> is great as it‚Äôs a command line tool, but I do think it lacks a certain finesse when it comes to usability, and unfortunately the <CODE>cf curl</CODE> approach, using a completely different API and therefore mental model, is not a good workaround).<BR />
<BR />
While editing, we take a look at some of the detail in the file:<BR />
<PRE><CODE>-&gt; cf service-key workflow SimpleWorkflow-workflow-credentials &gt; keys.json</CODE></PRE><BR />
We have to edit this now to remove the noise that the <CODE>cf</CODE> command spat out when executing this request (<CODE>cf</CODE> is great as it‚Äôs a command line tool, but I do t<BR />
hink it lacks a certain finesse when it comes to usability, and unfortunately the <CODE>cf curl</CODE> approach, using a completely different API and therefore mental model, is not a<BR />
good workaround).<BR />
<BR />
While editing, we take a look at some of the detail in the file:<BR />
<PRE><CODE>{                                                                                                                                                                          <BR />
 "content_endpoint": "https://api.workflow-sap.cfapps.eu10.hana.ondemand.com/workflow-deploy/rest/internal/v1",                                                   <BR />
 "endpoints": {<BR />
  "workflow_odata_url": "https://api.workflow-sap.cfapps.eu10.hana.ondemand.com/workflow-service/odata",                                                          <BR />
  "workflow_rest_url": "https://api.workflow-sap.cfapps.eu10.hana.ondemand.com/workflow-service/rest"                                                             <BR />
 },                                                                                                                                                                                   <BR />
 "html5-apps-repo": {                                                                                                                                                       <BR />
  "app_host_id": "2834263a-6e04-4f43-876a-67b81f32306e,1a5b93af-f1af-4acf-aee0-8c6cc8d3f315,8964e911-e35d-4cfd-972e-08e681a2df0f,9ea7410f-80ea-4b19-bbf0-4fca238ef098&amp;qu<BR />
ot;                                                                                                                                                                                   <BR />
 },                                                                                                                                                                                   <BR />
 "saasregistryappname": "workflow",                                                                                                                               <BR />
 "sap.cloud.service": "com.sap.bpm.workflow",                                                                                                                     <BR />
 "uaa": {                                                                                                                                                                   <BR />
  "apiurl": "https://api.authentication.eu10.hana.ondemand.com",                                                                                                  <BR />
  "clientid": "sb-clone-deadbeef-03b2-46bb-bd3d-f00b7d2db0d2!b37882|workflow!b10150",                                                                             <BR />
  "clientsecret": "1090976f-982a-3723-9a5d-723c913aba14$In4EKA1s5AIcfqo_juwHpKwGgh3o_bpYfeyIF0JE1Zg=",                                                            <BR />
  "identityzone": "p2001351149trial",                                                                                                                             <BR />
  "identityzoneid": "0a25d69a-6331-312a-bea9-1e90dc1f941f",                                                                                                       <BR />
  "sburl": "https://internal-xsuaa.authentication.eu10.hana.ondemand.com",                                                                                        <BR />
  "tenantid": "0a25d69a-6331-47ff-bea9-1e90dc1f941f",                                                                                                             <BR />
  "tenantmode": "dedicated",                                                                                                                                      <BR />
  "uaadomain": "authentication.eu10.hana.ondemand.com",<BR />
  "url": "https://p2001351149trial.authentication.eu10.hana.ondemand.com",<BR />
  "verificationkey": "-----BEGIN PUBLIC KEY-----MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAwThn6OO9kj0bchkOGkqYBnV1dQ3zU/xtj7Kj7nDd8nyRMcEWCtVzrzjzh- [ ] sRhlrzlRIEY82<BR />
wRAZNGKMnw7cvCwNixcfcDJnjzgr2pJ+5/yDZUc0IXXyIWPZD+XdL+0EogC3d4+fqyvg/BF/F0t2hKHWr/UTXE6zrGhBKaL0d8rKfYd6olGWigFd+3+24CKI14zWVxUBtC+P9Fhngc9DRzkXqhxOK/EKn0HzSgotf5duq6Tmk9DCNM4sLW4+ERc<BR />
6xzrgbeEexakabvax/Az9WZ4qhwgw+fwIhKIC7WLwCEJaRs...=-----END PUBLIC KEY-----",<BR />
  "xsappname": "clone-b34de1f8-03b2-12de-bd3d-f00b7d2db0d2!b37882|workflow!b10150"<BR />
 }<BR />
}</CODE></PRE><BR />
<UL><BR />
 	<LI><CODE>endpoints.workflow_rest_url</CODE> is the base URL for the resource server (the Workflow API endpoint, in this case)</LI><BR />
 	<LI><CODE>uaa.clientid</CODE> is the client ID to be used in the flow</LI><BR />
 	<LI><CODE>uaa.clientsecret</CODE> is the client secret to be used in the flow</LI><BR />
 	<LI><CODE>uaa.url</CODE> is the based URL for the authorisation server (for requesting tokens and so on)</LI><BR />
</UL><BR />
<A href="https://www.youtube.com/watch?v=AjuwSJeAUy8&amp;t=00h18m50s" target="_blank" rel="nofollow noopener noreferrer">00:18:50</A> Briefly looking at an updated version of the <CODE>skv</CODE> function we created in the <A href="https://bit.ly/handsonsapdev#ep57" target="_blank" rel="nofollow noopener noreferrer">previous episode</A>, this time allowing me to use it on different JSON files. Here‚Äôs what the definition looks like now:<BR />
<PRE><CODE>skv () { jq -r ."$2" "$1".json; }</CODE></PRE><BR />
So in this context, I can get the <CODE>uaa.url</CODE> value from the keys file like this:<BR />
<PRE><CODE>-&gt; skv keys uaa.url<BR />
<A href="https://p2001351149trial.authentication.eu10.hana.ondemand.com" target="test_blank" rel="nofollow noopener noreferrer">https://p2001351149trial.authentication.eu10.hana.ondemand.com</A></CODE></PRE><BR />
<A href="https://www.youtube.com/watch?v=AjuwSJeAUy8&amp;t=00h20m00s" target="_blank" rel="nofollow noopener noreferrer">00:20:00</A> Before we continue, we‚Äôll deliberately wipe out any authorities (scopes) we already have, from the perspective of what may already be allowed at the service instance level (for the ‚ÄúClient Credentials‚Äù flow), by updating the service instance like this:<BR />
<PRE><CODE>-&gt; cf update-service workflow -c '{"authorities":[]}'<BR />
Updating service instance workflow ...<BR />
OK</CODE></PRE><BR />
This should mean that we won‚Äôt have access to make any useful API calls using the ‚ÄúClient Credentials‚Äù flow.<BR />
<BR />
<A href="https://www.youtube.com/watch?v=AjuwSJeAUy8&amp;t=00h20m45s" target="_blank" rel="nofollow noopener noreferrer">00:20:45</A> Looking briefly at what we have from last time, we still have the contents of the <CODE>~/.netrc</CODE> file with the client ID and secret to be used in a Basic Authentication header in calls to the authorisation server endpoint:<BR />
<PRE><CODE>machine p2001351149trial.authentication.eu10.hana.ondemand.com<BR />
login sb-clone-deadbeef-03b2-46bb-bd3d-f00b7d2db0d2!b37882|workflow!b10150<BR />
password 1090976f-982a-3723-9a5d-723c913aba14$In4EKA1s5AIcfqo_juwHpKwGgh3o_bpYfeyIF0JE1Zg=</CODE></PRE><BR />
<A href="https://www.youtube.com/watch?v=AjuwSJeAUy8&amp;t=00h21m28s" target="_blank" rel="nofollow noopener noreferrer">00:21:28</A> Starting to redo what we did last week, so we can compare that approach to what we‚Äôre going to do. This is what we did (using a backslash for <A href="http://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#Escape-Character" target="_blank" rel="nofollow noopener noreferrer">line continuation</A><span class="lia-unicode-emoji" title=":disappointed_face:">üòû</span><BR />
<PRE><CODE>-&gt; curl -n \<BR />
&gt; -v \<BR />
&gt; -X POST \<BR />
&gt; "$(skv keys uaa.url)/oauth/token?grant_type=client_credentials" &gt; token.json</CODE></PRE><BR />
<A href="https://www.youtube.com/watch?v=AjuwSJeAUy8&amp;t=00h23m10s" target="_blank" rel="nofollow noopener noreferrer">00:23:10</A> In order to keep things clean and tidy as we move from exploring the ‚ÄúClient Credentials‚Äù flow to the ‚ÄúAuthorisation Code‚Äù flow, we now put this <CODE>token.json</CODE> file containing the results of this call into a separate folder signifying the flow that was used. Also, to have the service key details (in the <CODE>keys.json</CODE> file we wrote to earlier) in the same directory, but not repeated, we make a symbolic link, ending up with something like this:<BR />
<PRE><CODE>‚îú‚îÄ‚îÄ client_credentials<BR />
‚îÇ&nbsp;&nbsp; ‚îú‚îÄ‚îÄ keys.json -&gt; ../keys.json<BR />
‚îÇ&nbsp;&nbsp; ‚îî‚îÄ‚îÄ token.json<BR />
‚îî‚îÄ‚îÄ keys.json</CODE></PRE><BR />
<A href="https://www.youtube.com/watch?v=AjuwSJeAUy8&amp;t=00h23m30s" target="_blank" rel="nofollow noopener noreferrer">00:23:30</A> Pretty-printing the contents of the <CODE>token.json</CODE> file, we see that we have these properties returned to us:<BR />
<UL><BR />
 	<LI><CODE>access_token</CODE>: the token itself</LI><BR />
 	<LI><CODE>token_type</CODE>: the type of token (it‚Äôs a <A href="https://oauth.net/2/bearer-tokens/" target="_blank" rel="nofollow noopener noreferrer">bearer token</A>)</LI><BR />
 	<LI><CODE>expires_in</CODE>: how long the token lives for (we had a fun time guessing what the 43199 value represented, back in <A href="https://bit.ly/handsonsapdev#ep52" target="_blank" rel="nofollow noopener noreferrer">Episode 52</A> - see the <A href="https://blogs.sap.com/2020/02/07/annotated-links-episode-52-of-hands-on-sap-dev-with-qmacro/" target="_blank" rel="noopener noreferrer">annotations blog post</A> for more on that)</LI><BR />
 	<LI><CODE>scope</CODE>: an indication of the access we have with this particular token, in the form of scopes authorised by the UAA</LI><BR />
 	<LI><CODE>jti</CODE>: not mentioned here but this is a unique identifier for this token</LI><BR />
</UL><BR />
<A href="https://www.youtube.com/watch?v=AjuwSJeAUy8&amp;t=00h23m50s" target="_blank" rel="nofollow noopener noreferrer">00:23:50</A> We look at the value of the <CODE>scope</CODE> property using some basic tools, like this:<BR />
<PRE><CODE>-&gt; skv token scope | tr ' ' '\n' | sort<BR />
uaa.resource<BR />
workflow!b10150.FORM_DEFINITION_DEPLOY<BR />
workflow!b10150.TASK_DEFINITION_GET<BR />
workflow!b10150.TASK_GET<BR />
workflow!b10150.WORKFLOW_DEFINITION_DEPLOY</CODE></PRE><BR />
The scopes here relate to deploying artifacts, not anything else.<BR />
<BR />
<A href="https://www.youtube.com/watch?v=AjuwSJeAUy8&amp;t=00h24m40s" target="_blank" rel="nofollow noopener noreferrer">00:24:40</A> With this freshly minted token, we try it out by attempting to list the workflow definitions:<BR />
<PRE><CODE>-&gt; curl -H "Authorization: Bearer $(skv token access_token)" \<BR />
&gt; "$(skv keys endpoints.workflow_rest_url)/v1/workflow-definitions" \<BR />
&gt; | jq .<BR />
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current<BR />
                                 Dload  Upload   Total   Spent    Left  Speed<BR />
100    65  100    65    0     0    137      0 --:--:-- --:--:-- --:--:--   137<BR />
{<BR />
  "error": {<BR />
    "message": "User does not have sufficient privileges."<BR />
  }<BR />
}</CODE></PRE><BR />
A successful fail! <span class="lia-unicode-emoji" title=":slightly_smiling_face:">üôÇ</span> (BTW, we can suppress the progress output from curl with the <CODE>-s</CODE> switch).<BR />
<BR />
<A href="https://www.youtube.com/watch?v=AjuwSJeAUy8&amp;t=00h26m30s" target="_blank" rel="nofollow noopener noreferrer">00:26:30</A> So now we add the required scope back to the service instance, like this:<BR />
<PRE><CODE>-&gt; cf update-service workflow \<BR />
&gt; -c '{"authorities":["WORKFLOW_DEFINITION_GET"]}'<BR />
Updating service instance workflow ...<BR />
OK</CODE></PRE><BR />
Trying again after this, with the same <CODE>access_token</CODE>, gives us a result that we could have predicted, i.e.&nbsp;we still get the ‚ÄúUser does not have sufficient privileges‚Äù message. This is of course because when minted, that token didn‚Äôt include the scope we‚Äôve just set.<BR />
<BR />
<A href="https://www.youtube.com/watch?v=AjuwSJeAUy8&amp;t=00h27m00s" target="_blank" rel="nofollow noopener noreferrer">00:27:00</A> So, after asking for a new token, we get the result we‚Äôre looking for, like this:<BR />
<PRE><CODE>-&gt; curl -s \<BR />
&gt; -H "Authorization: Bearer $(skv token access_token)" \<BR />
&gt; "$(skv keys endpoints.workflow_rest_url)/v1/workflow-definitions"  \<BR />
&gt; | jq .<BR />
[<BR />
  {<BR />
    "id": "simpleworkflow",<BR />
    "version": "1",<BR />
    "name": "simpleworkflow",<BR />
    "createdBy": "sb-clone-deadbeef-03b2-46bb-bd3d-f00b7d2db0d2!b37882|workflow!b10150",<BR />
    "createdAt": "2020-03-20T05:57:50.933Z",<BR />
    "jobs": []<BR />
  },<BR />
  {<BR />
    "id": "orderprocess",<BR />
    "version": "8",<BR />
    "name": "orderprocess",<BR />
    "createdBy": "sb-clone-deadbeef-03b2-46bb-bd3d-f00b7d2db0d2!b37882|workflow!b10150",<BR />
    "createdAt": "2020-03-18T14:29:16.411Z",<BR />
    "jobs": []<BR />
  }<BR />
]</CODE></PRE><BR />
Great.<BR />
<BR />
<A href="https://www.youtube.com/watch?v=AjuwSJeAUy8&amp;t=00h28m00s" target="_blank" rel="nofollow noopener noreferrer">00:28:00</A> At this stage, it‚Äôs only fair to mention that when I did this last week, I didn‚Äôt even notice that I was using the HTTP POST method, when GET would have done the job just as well. The SAP authorisation server‚Äôs service is pretty flexible and supports different ways of making these requests. After all, there‚Äôs a reason that the Perl community motto <A href="https://en.wikipedia.org/wiki/There%27s_more_than_one_way_to_do_it" target="_blank" rel="nofollow noopener noreferrer">TMTOWTDI</A> exists!<BR />
<BR />
So to round out the recap, we try out a couple of alternatives (nothing majorly different, but different enough to look at).<BR />
<BR />
First, the same request format, but via GET:<BR />
<PRE><CODE>-&gt; curl -n \<BR />
&gt; -v \<BR />
&gt; "$(skv keys uaa.url)/oauth/token?grant_type=client_credentials" &gt; token.json</CODE></PRE><BR />
More interestingly, we can use a POST request in a rather different way, like this:<BR />
<PRE><CODE>-&gt; curl -v \<BR />
&gt; -d "grant_type=client_credentials&amp;client_id=$(skv keys uaa.clientid)&amp;client_secret=$(skv keys uaa.clientsecret)" \<BR />
&gt; "$(skv keys uaa.url)/oauth/token" &gt; token.json</CODE></PRE><BR />
This version of the request doesn‚Äôt pass anything in a Basic Authentication header; instead, it passes the client ID and secret, along with the grant type, in the body of the POST request. Lovely!<BR />
<BR />
I point out here, having just edited the command in an editor before submitting it, that you can do this too; in bash, just set the option like this:<BR />
<PRE><CODE>-&gt; set -o vi</CODE></PRE><BR />
If you‚Äôre interested in learning more about vi mode in bash, have a quick watch of this 6 minute video from Luke Smith: <A href="https://www.youtube.com/watch?v=GqoJQft5R2E" target="_blank" rel="nofollow noopener noreferrer">TFW You Learn There‚Äôs a Vim Mode in Bash‚Ä¶</A>.<BR />
<BR />
<A href="https://www.youtube.com/watch?v=AjuwSJeAUy8&amp;t=00h32m30s" target="_blank" rel="nofollow noopener noreferrer">00:32:30</A> Moving on now to the ‚ÄúAuthorisation Code‚Äù flow, which is where a HUMAN is involved. Exciting! Ta show the contrast in sharper relief, we first add the scope to be able to start new workflow instances:<BR />
<PRE><CODE>-&gt; cf update-service workflow -c '{"authorities": ["WORKFLOW_DEFINITION_GET", "WORKFLOW_INSTANCE_START"]}'<BR />
Updating service instance workflow ...<BR />
OK</CODE></PRE><BR />
(Remember that the list passed like this is absolute, not relative, so that if we‚Äôd just passed ‚ÄúWORKFLOW_INSTANCE_START‚Äù we‚Äôd have effectively removed ‚ÄúWORKFLOW_DEFINITION_GET‚Äù).<BR />
<BR />
Then, after retrieving a fresh access token like this:<BR />
<PRE><CODE>-&gt; curl -v \<BR />
&gt; -d "grant_type=client_credentials&amp;client_id=$(skv keys uaa.clientid)&amp;client_secret=$(skv keys uaa.clientsecret)" \<BR />
&gt; "$(skv keys uaa.url)/oauth/token" &gt; token.json</CODE></PRE><BR />
we make a successful call to start a new workflow instance, using the <CODE>/v1/workflow-definitions</CODE> API endpoint, like this:<BR />
<PRE><CODE>-&gt; curl -s \<BR />
&gt; -H "Content-Type: application/json" \<BR />
&gt; -H "Authorization: Bearer $(skv token access_token)" \<BR />
&gt; -d '{"definitionId":"simpleworkflow", "context":{"number":42}}' \<BR />
&gt; "$(skv keys endpoints.workflow_rest_url)/v1/workflow-instances" | jq .<BR />
{<BR />
  "id": "1fce48e8-6d08-11ea-855a-eeee0a94224d",<BR />
  "definitionId": "simpleworkflow",<BR />
  "definitionVersion": "1",<BR />
  "subject": "simpleworkflow",<BR />
  "status": "RUNNING",<BR />
  "businessKey": "",<BR />
  "startedAt": "2020-03-23T13:13:44.900Z",<BR />
  "startedBy": "sb-clone-deadbeef-03b2-46bb-bd3d-f00b7d2db0d2!b37882|workflow!b10150",<BR />
  "completedAt": null<BR />
}</CODE></PRE><BR />
(At this point <A href="https://twitter.com/alexellisuk" target="_blank" rel="nofollow noopener noreferrer">Alex Ellis</A> pipes up with a lovely phrase that summarises this hard core session, and which is definitely going on a tshirt (thanks Alex!) - ‚ÄúOAuth at 8am‚Äù!)<BR />
<BR />
<A href="https://www.youtube.com/watch?v=AjuwSJeAUy8&amp;t=00h37m15s" target="_blank" rel="nofollow noopener noreferrer">00:37:15</A> And when we go to the Workflow Monitor to look at this newly created instance (which of course is already in the COMPLETED state) we see that it was ‚ÄúStarted By‚Äù ‚Ä¶ the client ID. Not me, not any human, but the curl command identified by the credentials granted to it via the token request for that client ID. Not ideal, but a situation we can solve with the use of the ‚ÄúAuthorisation Code‚Äù grant type, as we‚Äôll see now.<BR />
<BR />
<A href="https://www.youtube.com/watch?v=AjuwSJeAUy8&amp;t=00h40m10s" target="_blank" rel="nofollow noopener noreferrer">00:40:10</A> Armed with the knowledge that two of the four grant types listed on the Pivotal site are now legacy, we revisit the SAP Help Portal pages, specifically the <A href="https://help.sap.com/viewer/e157c391253b4ecd93647bf232d18a83/Cloud/en-US/df943e71122448caaf3c49f5ffd80627.html" target="_blank" rel="noopener noreferrer">Using Workflow APIs</A> section, and now understand why there are only two subsections relating to the access via OAuth:<BR />
<UL><BR />
 	<LI><A href="https://help.sap.com/viewer/e157c391253b4ecd93647bf232d18a83/Cloud/en-US/9edeb36db8aa4628be092328e8810e5e.html" target="_blank" rel="noopener noreferrer">Access Workflow APIs Using OAuth 2.0 Authentication (Authorization Code Grant)</A></LI><BR />
 	<LI><A href="https://help.sap.com/viewer/e157c391253b4ecd93647bf232d18a83/Cloud/en-US/c2bd37c63dda47449e24b8830ba312f1.html" target="_blank" rel="noopener noreferrer">Access Workflow APIs Using OAuth 2.0 Authentication (Client Credentials Grant)</A></LI><BR />
</UL><BR />
Now we know why!<BR />
<BR />
<A href="https://www.youtube.com/watch?v=AjuwSJeAUy8&amp;t=00h40m30s" target="_blank" rel="nofollow noopener noreferrer">00:40:30</A> Looking at the ‚ÄúAuthorisation Code‚Äù flow details, we see that the flow is slightly longer, but that‚Äôs because a HUMAN is involved, as we saw in the nice diagram on the Pivotal site for that flow section.<BR />
<BR />
This is how the flow goes, as we work through it, this time in a new directory <CODE>authorization_code/</CODE> that we create in a similar way to the first one, so we now have:<BR />
<PRE><CODE>.<BR />
‚îú‚îÄ‚îÄ authorization_code<BR />
‚îÇ&nbsp;&nbsp; ‚îî‚îÄ‚îÄ keys.json -&gt; ../keys.json<BR />
‚îú‚îÄ‚îÄ client_credentials<BR />
‚îÇ&nbsp;&nbsp; ‚îú‚îÄ‚îÄ keys.json -&gt; ../keys.json<BR />
‚îÇ&nbsp;&nbsp; ‚îî‚îÄ‚îÄ token.json<BR />
‚îî‚îÄ‚îÄ keys.json</CODE></PRE><BR />
Step 1 is to generate the URL with which we can request a code, noting that the endpoint URL‚Äôs path is <CODE>/oauth/authorize</CODE> as opposed to what we‚Äôve seen thus far, i.e. <CODE>/oauth/token</CODE>. This is because we‚Äôre not asking for a token directly at this stage.<BR />
<BR />
<A href="https://www.youtube.com/watch?v=AjuwSJeAUy8&amp;t=00h42m50s" target="_blank" rel="nofollow noopener noreferrer">00:42:50</A> We actually need to go to the request URL in our browser, so at this stage we just need to produce the URL, i.e.&nbsp;echo it out to the terminal, so we can grab it to open.<BR />
<BR />
BTW, I‚Äôve aliases a pair of little helpers for URL encoding and decoding, which you can see in my <CODE>~/.bash_aliases</CODE>, as we‚Äôll need to URL encode the values in the URL‚Äôs query string:<BR />
<PRE><CODE>-&gt; cat ~/.bash_aliases<BR />
alias urldecode='python3 -c "import sys, urllib.parse as ul; print(ul.unquote_plus(sys.argv[1]))"'<BR />
alias urlencode='python3 -c "import sys, urllib.parse as ul; print (ul.quote_plus(sys.argv[1]))"'</CODE></PRE><BR />
OK, so to the creation of the URL:<BR />
<PRE><CODE>-&gt; echo "$(skv keys uaa.url)/oauth/authorize?client_id=$(urlencode `skv keys uaa.clientid`)&amp;response_type=code"<BR />
<A href="https://p2001351149trial.authentication.eu10.hana.ondemand.com/oauth/authorize?client_id=sb-clone-deadbeef-03b2-46bb-bd3d-f00b7d2db0d2%21b37882%7Cworkflow%21b10150&amp;response_type=code" target="test_blank" rel="nofollow noopener noreferrer">https://p2001351149trial.authentication.eu10.hana.ondemand.com/oauth/authorize?client_id=sb-clone-deadbeef-03b2-46bb-bd3d-f00b7d2db0d2%21b37882%7Cworkflow%21b10150&amp;response_type=code</A></CODE></PRE><BR />
<A href="https://www.youtube.com/watch?v=AjuwSJeAUy8&amp;t=00h45m20s" target="_blank" rel="nofollow noopener noreferrer">00:45:20</A> Step 2 is to go to the generated URL, which we do now. And we‚Äôre asked, beautifully, to authenticate! Which we do, using my personal credentials in my role as ‚Äúresource owner‚Äù here.<BR />
<BR />
<IMG class="migrated-image" src="https://community.sap.com/legacyfs/online/storage/blog_attachments/2020/03/Screenshot-2020-03-23-at-16.15.26.png" /><BR />
<BR />
As a result of that, we get redirected to a URL that contains the code that we‚Äôre looking for:<BR />
<BR />
<A class="uri" href="http://localhost:8080?code=zCyAM2lqaQ" target="_blank" rel="nofollow noopener noreferrer">http://localhost:8080?code=zCyAM2lqaQ</A><BR />
<BR />
<A href="https://www.youtube.com/watch?v=AjuwSJeAUy8&amp;t=00h46m10s" target="_blank" rel="nofollow noopener noreferrer">00:46:10</A> Step 3 is to ask for an exchange of that code <CODE>zCyAM2lqaQ</CODE> for an access token. So we do that:<BR />
<PRE><CODE>-&gt; curl -n \<BR />
&gt; -v \<BR />
&gt; "$(skv keys uaa.url)/oauth/token?grant_type=authorization_code&amp;code=zCyAM2lqaQ"</CODE></PRE><BR />
In fact, I forgot to save the (JSON) response into a file, which is a nice mistake to have made, as it illustrated that such codes can only be used once. Trying again to exchange the same code for another access token resulted in an HTTP 400 response. Quite right too!<BR />
<BR />
So we request another code, and this time, when we ask for it to be exchanged for an access token, we save the response into a <CODE>token.json</CODE> file (remember, we‚Äôre in the <CODE>authorization_code/</CODE> directory here too).<BR />
<BR />
<A href="https://www.youtube.com/watch?v=AjuwSJeAUy8&amp;t=00h48m25s" target="_blank" rel="nofollow noopener noreferrer">00:48:25</A> Moreover, not only do we have an access token now, but also (and this is something that will hopefully pique <SPAN class="mention-scrubbed">phil.cooley</SPAN>‚Äôs interest) a refresh token!<BR />
<BR />
And there‚Äôs more. There are far more scopes related to this access token than we‚Äôve seen thus far. The scopes related to the access token that was granted in our ‚ÄúClient Credentials‚Äù flow look like this:<BR />
<PRE><CODE>-&gt; cd ../client_credentials/<BR />
-&gt; skv token scope | tr ' ' '\n' | sort<BR />
uaa.resource<BR />
workflow!b10150.FORM_DEFINITION_DEPLOY<BR />
workflow!b10150.TASK_DEFINITION_GET<BR />
workflow!b10150.TASK_GET<BR />
workflow!b10150.WORKFLOW_DEFINITION_DEPLOY<BR />
workflow!b10150.WORKFLOW_DEFINITION_GET<BR />
workflow!b10150.WORKFLOW_INSTANCE_START</CODE></PRE><BR />
But the scopes related to the access token we just received, granted in our ‚ÄúAuthorisation Code‚Äù flow, look like this:<BR />
<PRE><CODE>-&gt; skv token scope | tr ' ' '\n' | sort<BR />
openid<BR />
uaa.user<BR />
workflow!b10150.AUTHORIZE_WITH_INSTANCE_ROLES<BR />
workflow!b10150.FORM_DEFINITION_DEPLOY<BR />
workflow!b10150.FORM_DEFINITION_GET_MODEL<BR />
workflow!b10150.FORM_DEFINITION_GET_MODEL_ANY<BR />
workflow!b10150.IMPERSONATION_TOKEN_GET<BR />
workflow!b10150.READ_FEATURE_FLAGS<BR />
workflow!b10150.RETRIEVE_XSRF_TOKEN<BR />
workflow!b10150.TASK_COMPLETE_ANY<BR />
workflow!b10150.TASK_DEFINITION_QUERY_ANY<BR />
workflow!b10150.TASK_GET_ATTRIBUTES_ANY<BR />
workflow!b10150.TASK_GET_CONTEXT_ANY<BR />
workflow!b10150.TASK_GET_FORM<BR />
workflow!b10150.TASK_GET_FORM_MODEL<BR />
workflow!b10150.TASK_MANAGE_OWN<BR />
workflow!b10150.TASK_PATCH_ANY<BR />
workflow!b10150.TASK_QUERY_ANY<BR />
workflow!b10150.WORKFLOW_DEFINITION_DEPLOY<BR />
workflow!b10150.WORKFLOW_DEFINITION_GET_MODEL<BR />
workflow!b10150.WORKFLOW_DEFINITION_QUERY_ANY<BR />
workflow!b10150.WORKFLOW_DEFINITION_VALIDATE<BR />
workflow!b10150.WORKFLOW_INSTANCE_CANCEL<BR />
workflow!b10150.WORKFLOW_INSTANCE_ERROR_MESSAGES_QUERY<BR />
workflow!b10150.WORKFLOW_INSTANCE_GET_ATTRIBUTES<BR />
workflow!b10150.WORKFLOW_INSTANCE_GET_CONTEXT<BR />
workflow!b10150.WORKFLOW_INSTANCE_QUERY_ANY<BR />
workflow!b10150.WORKFLOW_INSTANCE_QUERY_EXECUTION_LOGS<BR />
workflow!b10150.WORKFLOW_INSTANCE_QUERY_ROLES<BR />
workflow!b10150.WORKFLOW_INSTANCE_RETRY_RESUME<BR />
workflow!b10150.WORKFLOW_INSTANCE_START<BR />
workflow!b10150.WORKFLOW_INSTANCE_SUSPEND<BR />
workflow!b10150.WORKFLOW_INSTANCE_UPDATE_ROLES</CODE></PRE><BR />
Gosh!<BR />
<BR />
<A href="https://www.youtube.com/watch?v=AjuwSJeAUy8&amp;t=00h50m10s" target="_blank" rel="nofollow noopener noreferrer">00:50:10</A> Why is this? Well of course, because the access token has been granted on MY behalf, and I have lots of roles assigned to me via the <CODE>workflow</CODE> role collection, which we look at briefly now.<BR />
<BR />
<IMG class="migrated-image" src="https://community.sap.com/legacyfs/online/storage/blog_attachments/2020/03/Screenshot-2020-03-23-at-16.16.24.png" /><BR />
<BR />
These roles are:<BR />
<UL><BR />
 	<LI>WorkflowAdmin</LI><BR />
 	<LI>WorkflowContextViewer</LI><BR />
 	<LI>WorkflowDeveloper</LI><BR />
 	<LI>WorkflowInitiator</LI><BR />
 	<LI>WorkflowParticipant</LI><BR />
 	<LI>WorkflowViewer</LI><BR />
</UL><BR />
<A href="https://www.youtube.com/watch?v=AjuwSJeAUy8&amp;t=00h50m40s" target="_blank" rel="nofollow noopener noreferrer">00:50:40</A> Now we have this access token, we can try to start a new workflow instance, just like we did before. While the token request and receipt has a different flow (and more importantly a different context), the use of the token in an actual API call is the same.<BR />
<PRE><CODE>-&gt; curl -s \<BR />
&gt; -H "Content-Type: application/json" \<BR />
&gt; -H "Authorization: Bearer $(skv token access_token)" \<BR />
&gt; -d '{"definitionId":"simpleworkflow", "context":{"number":43}}' \<BR />
&gt; "$(skv keys endpoints.workflow_rest_url)/v1/workflow-instances" | jq .<BR />
{<BR />
  "id": "1fce48e8-6d08-11ea-855a-209327de311",<BR />
  "definitionId": "simpleworkflow",<BR />
  "definitionVersion": "1",<BR />
  "subject": "simpleworkflow",<BR />
  "status": "RUNNING",<BR />
  "businessKey": "",<BR />
  "startedAt": "2020-03-23T13:13:44.900Z",<BR />
  "startedBy": "qmacro+workflowcodejam@gmail.com",<BR />
  "completedAt": null<BR />
}</CODE></PRE><BR />
<A href="https://www.youtube.com/watch?v=AjuwSJeAUy8&amp;t=00h53m10s" target="_blank" rel="nofollow noopener noreferrer">00:53:10</A> And which part of these successful results do we think is the most exciting? Well, it‚Äôs the value of the <CODE>startedBy</CODE> property, of course! Instead of referring to the non-human client ID, it‚Äôs referring to me, the human who actually started the workflow instance.<BR />
<BR />
A quick look via the Workflow Monitor shows this contrast between the different ‚ÄúStarted By‚Äù values. Great!<BR />
<BR />
<A href="https://www.youtube.com/watch?v=AjuwSJeAUy8&amp;t=00h54m50s" target="_blank" rel="nofollow noopener noreferrer">00:54:50</A> Flushed with this success, we talk briefly about how we might have different clients, different apps, with different access rights (as they might serve different purposes) in the context of the ‚ÄúClient Credentials‚Äù grant type. And the answer is to have multiple service instances of the workflow service, assign different scopes to these multiple instances, and use the client credentials (ID and secret) from the different service keys connected to these instances accordingly. Now it makes a lot of sense, right?<BR />
<BR />
<A href="https://www.youtube.com/watch?v=AjuwSJeAUy8&amp;t=00h56m10s" target="_blank" rel="nofollow noopener noreferrer">00:56:10</A> In the spirit of ‚Äúpoke it and see what happens‚Äù, we take a brief look at whether what we‚Äôve discovered makes sense and holds when we do something ‚Ä¶ say, like remove a role from the role collection that‚Äôs assigned to me.<BR />
<BR />
<A href="https://www.youtube.com/watch?v=AjuwSJeAUy8&amp;t=00h56m30s" target="_blank" rel="nofollow noopener noreferrer">00:56:30</A> Before we do anything, we check what‚Äôs in the scope relating to our current (Authorisation Code grant type related) access token. We see the list, which is the same as the one above, which includes the scope:<BR />
<PRE><CODE>workflow!b10150.WORKFLOW_INSTANCE_START</CODE></PRE><BR />
Good.<BR />
<BR />
Now, we remove the WorkflowInitiator role from the role collection that‚Äôs assigned to me. Then we generate a new URL to request a new code, using the same <CODE>echo</CODE> command as before:<BR />
<PRE><CODE>-&gt; echo "$(skv keys uaa.url)/oauth/authorize?client_id=$(urlencode `skv keys uaa.clientid`)&amp;response_type=code"<BR />
<A href="https://p2001351149trial.authentication.eu10.hana.ondemand.com/oauth/authorize?client_id=sb-clone-deadbeef-03b2-46bb-bd3d-f00b7d2db0d2%21b37882%7Cworkflow%21b10150&amp;response_type=code" target="test_blank" rel="nofollow noopener noreferrer">https://p2001351149trial.authentication.eu10.hana.ondemand.com/oauth/authorize?client_id=sb-clone-deadbeef-03b2-46bb-bd3d-f00b7d2db0d2%21b37882%7Cworkflow%21b10150&amp;response_type=code</A></CODE></PRE><BR />
We must do a bit of jiggling about in order to remove the cookies to effectively invalidate my already-authenticated status so that we‚Äôll be asked to authenticate again, and once we‚Äôve done this, we do indeed get the authentication challenge screen again, asking me for my email address and password.<BR />
<BR />
We then exchange the code we receive for a new access token, and take a look at the scopes:<BR />
<PRE><CODE>-&gt; skv token scope | tr ' ' '\n' | sort<BR />
openid<BR />
uaa.user<BR />
workflow!b10150.AUTHORIZE_WITH_INSTANCE_ROLES<BR />
workflow!b10150.FORM_DEFINITION_DEPLOY<BR />
workflow!b10150.FORM_DEFINITION_GET_MODEL<BR />
workflow!b10150.FORM_DEFINITION_GET_MODEL_ANY<BR />
workflow!b10150.IMPERSONATION_TOKEN_GET<BR />
workflow!b10150.READ_FEATURE_FLAGS<BR />
workflow!b10150.RETRIEVE_XSRF_TOKEN<BR />
workflow!b10150.TASK_COMPLETE_ANY<BR />
workflow!b10150.TASK_DEFINITION_QUERY_ANY<BR />
workflow!b10150.TASK_GET_ATTRIBUTES_ANY<BR />
workflow!b10150.TASK_GET_CONTEXT_ANY<BR />
workflow!b10150.TASK_GET_FORM<BR />
workflow!b10150.TASK_GET_FORM_MODEL<BR />
workflow!b10150.TASK_MANAGE_OWN<BR />
workflow!b10150.TASK_PATCH_ANY<BR />
workflow!b10150.TASK_QUERY_ANY<BR />
workflow!b10150.WORKFLOW_DEFINITION_DEPLOY<BR />
workflow!b10150.WORKFLOW_DEFINITION_GET_MODEL<BR />
workflow!b10150.WORKFLOW_DEFINITION_QUERY_ANY<BR />
workflow!b10150.WORKFLOW_DEFINITION_VALIDATE<BR />
workflow!b10150.WORKFLOW_INSTANCE_CANCEL<BR />
workflow!b10150.WORKFLOW_INSTANCE_ERROR_MESSAGES_QUERY<BR />
workflow!b10150.WORKFLOW_INSTANCE_GET_ATTRIBUTES<BR />
workflow!b10150.WORKFLOW_INSTANCE_GET_CONTEXT<BR />
workflow!b10150.WORKFLOW_INSTANCE_QUERY_ANY<BR />
workflow!b10150.WORKFLOW_INSTANCE_QUERY_EXECUTION_LOGS<BR />
workflow!b10150.WORKFLOW_INSTANCE_QUERY_ROLES<BR />
workflow!b10150.WORKFLOW_INSTANCE_RETRY_RESUME<BR />
workflow!b10150.WORKFLOW_INSTANCE_SUSPEND<BR />
workflow!b10150.WORKFLOW_INSTANCE_UPDATE_ROLES</CODE></PRE><BR />
Can you see what‚Äôs (successfully) missing? Yes, the <CODE>workflow!b10150.WORKFLOW_INSTANCE_START</CODE> scope. This is a direct result of the removal of the WorkflowInitiator role from the workflow role collection assigned to me.<BR />
<BR />
And of course, as you can guess, an attempt to start a new workflow instance fails, with:<BR />
<PRE><CODE>{<BR />
  "error": {<BR />
    "message": "User does not have sufficient privileges."<BR />
  }<BR />
}</CODE></PRE><BR />
Great, this is what we expect.<BR />
<BR />
<A href="https://www.youtube.com/watch?v=AjuwSJeAUy8&amp;t=01h01m50s" target="_blank" rel="nofollow noopener noreferrer">01:01:50</A> As <SPAN class="mention-scrubbed">phil.cooley</SPAN> had been asking about refresh tokens, we extend the episode by a few minutes to see how we can follow the refresh token flow.<BR />
<BR />
First, we have a look at what we have in the <CODE>token.json</CODE> file, remembering which properties are in there:<BR />
<PRE><CODE>-&gt; jq keys token.json<BR />
[<BR />
  "access_token",<BR />
  "expires_in",<BR />
  "id_token",<BR />
  "jti",<BR />
  "refresh_token",<BR />
  "scope",<BR />
  "token_type"<BR />
]</CODE></PRE><BR />
(we didn‚Äôt use this ‚Äòkeys‚Äô option of <CODE>jq</CODE> in the live stream but it‚Äôs useful for us here).<BR />
<BR />
The flow is described on the same documentation page (<A href="https://help.sap.com/viewer/e157c391253b4ecd93647bf232d18a83/Cloud/en-US/9edeb36db8aa4628be092328e8810e5e.html" target="_blank" rel="noopener noreferrer">Access Workflow APIs Using OAuth 2.0 Authentication (Authorization Code Grant)</A>) and is very simple:<BR />
<PRE><CODE>-&gt; curl -n -v "$(skv keys uaa.url)/oauth/token?grant_type=refresh_token&amp;refresh_token=$(skv token refresh_token)" &gt; refreshed-token.json</CODE></PRE><BR />
(At this stage, we also notice that the use of the value ‚Äúrefresh_token‚Äù for the <CODE>grant_type</CODE> query string parameter is most likely why ‚ÄúRefresh Token‚Äù is <A href="https://oauth.net/2/grant-types/" target="_blank" rel="nofollow noopener noreferrer">listed on the OAuth 2.0 website</A> as a first class grant type citizen.)<BR />
<BR />
<A href="https://www.youtube.com/watch?v=AjuwSJeAUy8&amp;t=01h04m35s" target="_blank" rel="nofollow noopener noreferrer">01:04:35</A> Is this new, refreshed access token actually usable? We try it out by trying to get a list of workflow definitions, thus:<BR />
<PRE><CODE>-&gt; curl -s -H "Authorization: Bearer $(skv token access_token)" "$(skv keys endpoints.workflow_rest_url)/v1/workflow-definitions" | jq .<BR />
[<BR />
  {<BR />
    "id": "simpleworkflow",<BR />
    "version": "1",<BR />
    "name": "simpleworkflow",<BR />
    "createdBy": "sb-clone-b34de1f8-03b2-46bb-bd3d-f00b7d2db0d2!b37882|workflow!b10150",<BR />
    "createdAt": "2020-03-20T05:57:50.933Z",<BR />
    "jobs": []<BR />
  },<BR />
  {<BR />
    "id": "orderprocess",<BR />
    "version": "8",<BR />
    "name": "orderprocess",<BR />
    "createdBy": "sb-clone-b34de1f8-03b2-46bb-bd3d-f00b7d2db0d2!b37882|workflow!b10150",<BR />
    "createdAt": "2020-03-18T14:29:16.411Z",<BR />
    "jobs": []<BR />
  }<BR />
]</CODE></PRE><BR />
It is indeed usable - hurray!
