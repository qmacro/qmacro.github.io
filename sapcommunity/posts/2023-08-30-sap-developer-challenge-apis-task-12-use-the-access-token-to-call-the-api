2023-08-30-sap-developer-challenge-apis-task-12-use-the-access-token-to-call-the-api
SAP Developer Challenge - APIs - Task 12 - Use the access token to call the API endpoint
application-developmentforum-board
2023-08-30
https://community.sap.com/t5/application-development-discussions/sap-developer-challenge-apis-task-12-use-the-access-token-to-call-the-api/td-p/283202
<P>(Check out the <A href="https://blogs.sap.com/2023/08/01/sap-developer-challenge-apis/" target="_blank" rel="noopener noreferrer">SAP Developer Challenge - APIs</A> blog post for everything you need to know about the challenge to which this task relates!)</P><P>Well done for making it to the final task of this SAP Developer Challenge on APIs! You're going to finish on a high, by finally calling the API endpoint in the Core Services for SAP BTP API package. But not without a little diversion in the road on the way there <span class="lia-unicode-emoji" title=":slightly_smiling_face:">ðŸ™‚</span> Let's get to it!</P><H2 id="toc-hId-1652060615">Background</H2><P>So, at this point, you have completed steps 1, 2 and 3 in this group of tasks. And after a slight detour into JWTs in the previous task, you're now back on track, on the home straight, ready to complete step 4.</P><OL><LI>create an instance of the SAP Cloud Management Service, with a plan that contains the appropriate scope(s) that you need <span class="lia-unicode-emoji" title=":white_heavy_check_mark:">âœ…</span></LI><LI>create a service key based on that instance <span class="lia-unicode-emoji" title=":white_heavy_check_mark:">âœ…</span></LI><LI>use the details in the service key to request an access token <span class="lia-unicode-emoji" title=":white_heavy_check_mark:">âœ…</span></LI><LI>use the access token thus obtained to authenticate a call to the API endpoint</LI></OL><P>To complete this task you're going to need to recall bits and pieces from prior tasks:</P><UL><LI>the GUID of the directory that you created in <A href="https://groups.community.sap.com/t5/application-development/sap-developer-challenge-apis-task-7-create-a-new-directory-in-an/td-p/280341" target="_blank" rel="noopener noreferrer">Task 7</A></LI><LI>the service key data that you obtained in <A href="https://groups.community.sap.com/t5/application-development/sap-developer-challenge-apis-task-9-create-a-service-key-for-api/td-p/281337" target="_blank" rel="noopener noreferrer">Task 9</A></LI><LI>the JSON object containing the access token and related metadata that you requested and received in <A href="https://groups.community.sap.com/t5/application-development/sap-developer-challenge-apis-task-10-request-an-oauth-access/m-p/281933" target="_blank" rel="noopener noreferrer">Task 10</A></LI></UL><P>How are you going to use each of these pieces of information?</P><P>Well, you'll need the directory GUID to replace the {directoryGUID} placeholder in the actual API endpoint that you're going to be calling (the endpoint detail was also mentioned in <A href="https://groups.community.sap.com/t5/application-development/sap-developer-challenge-apis-task-9-create-a-service-key-for-api/td-p/281337" target="_blank" rel="noopener noreferrer">Task 9</A>). In other words:</P><PRE>GET /accounts/v1/directories/{directoryGUID}</PRE><P>You'll need information from the service key data to know what the base URL of the Accounts Service API to use, because this /accounts/v1/directories/{directoryGUID} API endpoint belongs to that Accounts Service API, remember? Recall that the service key data looks like this (heavily redacted in the .credentials.uaa section for brevity):</P><DIV class=""><PRE><SPAN><SPAN class="">{</SPAN></SPAN>
<SPAN>  <SPAN class="">"credentials"</SPAN><SPAN class="">:</SPAN> <SPAN class="">{</SPAN></SPAN>
<SPAN>    <SPAN class="">"endpoints"</SPAN><SPAN class="">:</SPAN> <SPAN class="">{</SPAN></SPAN>
<SPAN>      <SPAN class="">"accounts_service_url"</SPAN><SPAN class="">:</SPAN> <SPAN class="">"https://accounts-service.cfapps.eu10.hana.ondemand.com"</SPAN><SPAN class="">,</SPAN></SPAN>
<SPAN>      <SPAN class="">"cloud_automation_url"</SPAN><SPAN class="">:</SPAN> <SPAN class="">"https://cp-formations.cfapps.eu10.hana.ondemand.com"</SPAN><SPAN class="">,</SPAN></SPAN>
<SPAN>      <SPAN class="">"entitlements_service_url"</SPAN><SPAN class="">:</SPAN> <SPAN class="">"https://entitlements-service.cfapps.eu10.hana.ondemand.com"</SPAN><SPAN class="">,</SPAN></SPAN>
<SPAN>      <SPAN class="">"events_service_url"</SPAN><SPAN class="">:</SPAN> <SPAN class="">"https://events-service.cfapps.eu10.hana.ondemand.com"</SPAN><SPAN class="">,</SPAN></SPAN>
<SPAN>      <SPAN class="">"external_provider_registry_url"</SPAN><SPAN class="">:</SPAN> <SPAN class="">"https://external-provider-registry.cfapps.eu10.hana.ondemand.com"</SPAN><SPAN class="">,</SPAN></SPAN>
<SPAN>      <SPAN class="">"metadata_service_url"</SPAN><SPAN class="">:</SPAN> <SPAN class="">"https://metadata-service.cfapps.eu10.hana.ondemand.com"</SPAN><SPAN class="">,</SPAN></SPAN>
<SPAN>      <SPAN class="">"order_processing_url"</SPAN><SPAN class="">:</SPAN> <SPAN class="">"https://order-processing.cfapps.eu10.hana.ondemand.com"</SPAN><SPAN class="">,</SPAN></SPAN>
<SPAN>      <SPAN class="">"provisioning_service_url"</SPAN><SPAN class="">:</SPAN> <SPAN class="">"https://provisioning-service.cfapps.eu10.hana.ondemand.com"</SPAN><SPAN class="">,</SPAN></SPAN>
<SPAN>      <SPAN class="">"saas_registry_service_url"</SPAN><SPAN class="">:</SPAN> <SPAN class="">"https://saas-manager.cfapps.eu10.hana.ondemand.com"</SPAN></SPAN>
<SPAN>    <SPAN class="">},</SPAN></SPAN>
<SPAN>    <SPAN class="">"grant_type"</SPAN><SPAN class="">:</SPAN> <SPAN class="">"user_token"</SPAN><SPAN class="">,</SPAN></SPAN>
<SPAN>    <SPAN class="">"sap.cloud.service"</SPAN><SPAN class="">:</SPAN> <SPAN class="">"com.sap.core.commercial.service.central"</SPAN><SPAN class="">,</SPAN></SPAN>
<SPAN>    <SPAN class="">"uaa"</SPAN><SPAN class="">:</SPAN> <SPAN class="">{</SPAN></SPAN>
<SPAN>      <SPAN class="">"apiurl"</SPAN><SPAN class="">:</SPAN> <SPAN class="">"https://api.authentication.eu10.hana.ondemand.com"</SPAN><SPAN class="">,</SPAN></SPAN>
<SPAN>      <SPAN class="">"clientid"</SPAN><SPAN class="">:</SPAN> <SPAN class="">"..."</SPAN><SPAN class="">,</SPAN></SPAN>
<SPAN>      <SPAN class="">"clientsecret"</SPAN><SPAN class="">:</SPAN> <SPAN class="">"..."</SPAN><SPAN class="">,</SPAN></SPAN>
<SPAN>      <SPAN class="">"..."</SPAN><SPAN class="">:</SPAN> <SPAN class="">"..."</SPAN></SPAN>
<SPAN>    <SPAN class="">}</SPAN></SPAN>
<SPAN>  <SPAN class="">}<BR /></SPAN></SPAN><SPAN><SPAN class="">}</SPAN></SPAN></PRE></DIV><P>So you will need the value of the .credentials.endpoints.accounts_service_url property from your service key data.</P><P>Finally, you'll need of course the access token you obtained in <A href="https://groups.community.sap.com/t5/application-development/sap-developer-challenge-apis-task-10-request-an-oauth-access/m-p/281933" target="_blank" rel="noopener noreferrer">Task 10</A>, i.e. the value of the access_token property in the JSON object that looks like this:</P><DIV class=""><PRE><SPAN><SPAN class="">{</SPAN></SPAN>
<SPAN>  <SPAN class="">"access_token"</SPAN><SPAN class="">:</SPAN> <SPAN class="">"eyJhbGciOiJSUzI1NiIs..."</SPAN><SPAN class="">,</SPAN></SPAN>
<SPAN>  <SPAN class="">"token_type"</SPAN><SPAN class="">:</SPAN> <SPAN class="">"bearer..."</SPAN><SPAN class="">,</SPAN></SPAN>
<SPAN>  <SPAN class="">"id_token"</SPAN><SPAN class="">:</SPAN> <SPAN class="">"eyJhbGciOiJSUzI1NiIs..."</SPAN><SPAN class="">,</SPAN></SPAN>
<SPAN>  <SPAN class="">"refresh_token"</SPAN><SPAN class="">:</SPAN> <SPAN class="">"e72b61a9a9304dde963e..."</SPAN><SPAN class="">,</SPAN></SPAN>
<SPAN>  <SPAN class="">"expires_in"</SPAN><SPAN class="">:</SPAN> <SPAN class="">43199</SPAN><SPAN class="">,</SPAN></SPAN>
<SPAN>  <SPAN class="">"scope"</SPAN><SPAN class="">:</SPAN> <SPAN class="">"cis-central!b14.glob..."</SPAN><SPAN class="">,</SPAN></SPAN>
<SPAN>  <SPAN class="">"jti"</SPAN><SPAN class="">:</SPAN> <SPAN class="">"579fea14a1cf47d7ab9e..."</SPAN></SPAN>
<SPAN><SPAN class="">}</SPAN></SPAN></PRE></DIV><P>"<EM>But wait!</EM>" I hear some of you cry. "<EM>Task 10 was last week. That's, err, more than 43199 seconds ago, right? What's going to happen?</EM>"</P><P>Well let's find out!</P><H3 id="toc-hId--1096609851">Attempting a call with an expired access token</H3><P>Let's assume for this experiment that:</P><UL><LI>the GUID of your directory is 57675710-7b16-43ec-b64a-ab14660c1b24</LI><LI>you have your service key data from Task 9 in a file called sk.json</LI><LI>your access token data from Task 10 in a file called tokendata.json</LI></UL><P>Let's also assume that the access token data in tokendata.json was indeed obtained on Friday last week, when Task 10 was published.</P><P>Using curl (but we'd see the same effect using any HTTP client, of course), let's see what the actual call to the API endpoint would look like:</P><PRE>curl \
  --verbose \
  --header "Authorization: Bearer $(jq -r .access_token tokendata.json)" \
  --url "$(jq -r .credentials.endpoints.accounts_service_url sk.json)/accounts/v1/directories/57675710-7b16-43ec-b64a-ab14660c1b24"</PRE><P>Invoking this returns something interesting, but not entirely unexpected. Here's part of the verbose output from that curl invocation:</P><PRE>&gt; GET /accounts/v1/directories/57675710-7b16-43ec-b64a-ab14660c1b24 HTTP/2
&gt; Host: accounts-service.cfapps.eu10.hana.ondemand.com
&gt; user-agent: curl/7.74.0
&gt; accept: */*
&gt; authorization: Bearer eyJhbGciOiJSUzI1Ni...
&gt;
&lt; HTTP/2 401
&lt; cache-control: no-cache, no-store, max-age=0, must-revalidate
&lt; date: Sat, 26 Aug 2023 09:30:06 GMT
&lt; expires: 0
&lt; pragma: no-cache
&lt; www-authenticate: Bearer error="invalid_token", error_description="An error occurred while attempting to decode the Jwt: Jwt expired at 2023-08-22T20:30:22Z", error_uri="https://tools.ietf.org/html/rfc6750#section-3.1"
&lt; x-content-type-options: nosniff
&lt; x-frame-options: DENY
&lt; x-vcap-request-id: 7a7c0c79-f3f7-4b19-651f-6c9b8dd2b013
&lt; x-xss-protection: 1; mode=block
&lt; content-length: 0
&lt; strict-transport-security: max-age=31536000; includeSubDomains; preload;</PRE><P>Ooh! Let's examine the content of that WWW-Authenticate HTTP response header:</P><PRE>error="invalid_token"
error_description="An error occurred while attempting to decode the Jwt: Jwt expired at 2023-08-22T20:30:22Z"
error_uri="https://tools.ietf.org/html/rfc6750#section-3.1"</PRE><P>The error description pretty much gives it to us straight. Our JWT, i.e. the access token, has expired! Now, this example is from my context, where I'd obtained an access token earlier last week. This is why the expiry in this example is on 22 Aug. In fact, let's double check.</P><H3 id="toc-hId-646200484">Checking when the access token expires</H3><P>Some of you may have been wondering about the expires_in property in the access token JSON object. This is a simple number of seconds (in this case 43199, to be precise) and represents the lifetime of the token. But how does this relate to actual dates and times? It is of course the lifetime starting from whenever the token was generated, so you may end up calculating the actual expiry date and time by adding those number of seconds on to the exact date and time you obtained the access token. But that can be cumbersome.</P><P>You can probably guess that the JWT contains expiry information too. In other words, expiry information is also contained within the access token itself, along with the list of scopes, and other things, that you discovered in the previous task. In fact, not only is the exact expiry date and time in there, but also the date and time when the token was issued. The eagle-eyed amongst you may have spotted the iat and exp properties in the payload part of the JWT in the previous task:</P><DIV class=""><PRE><SPAN><SPAN class="">{</SPAN></SPAN>
<SPAN>  <SPAN class="">"header"</SPAN><SPAN class="">:</SPAN> <SPAN class="">{</SPAN></SPAN>
<SPAN>    <SPAN class="">"alg"</SPAN><SPAN class="">:</SPAN> <SPAN class="">"..."</SPAN><SPAN class="">,</SPAN></SPAN>
<SPAN>    <SPAN class="">"jku"</SPAN><SPAN class="">:</SPAN> <SPAN class="">"https://c2d7b642trial-ga.authentication.eu10.hana.ondemand.com/token_keys"</SPAN><SPAN class="">,</SPAN></SPAN>
<SPAN>    <SPAN class="">"kid"</SPAN><SPAN class="">:</SPAN> <SPAN class="">"default-jwt-key-1281344942"</SPAN><SPAN class="">,</SPAN></SPAN>
<SPAN>    <SPAN class="">"typ"</SPAN><SPAN class="">:</SPAN> <SPAN class="">"..."</SPAN><SPAN class="">,</SPAN></SPAN>
<SPAN>    <SPAN class="">"jid"</SPAN><SPAN class="">:</SPAN> <SPAN class="">"iaVmTleRBCIVnVE7veQ9opMtlHnk+3DvKWWsjpsm542="</SPAN></SPAN>
<SPAN>  <SPAN class="">},</SPAN></SPAN>
<SPAN>  <SPAN class="">"payload"</SPAN><SPAN class="">:</SPAN> <SPAN class="">{</SPAN></SPAN>
<SPAN>    <SPAN class="">"..."</SPAN><SPAN class="">:</SPAN> <SPAN class="">"..."</SPAN><SPAN class="">,</SPAN></SPAN>
<SPAN>    <SPAN class="">"grant_type"</SPAN><SPAN class="">:</SPAN> <SPAN class="">"password"</SPAN><SPAN class="">,</SPAN></SPAN>
<SPAN>    <SPAN class="">"user_id"</SPAN><SPAN class="">:</SPAN> <SPAN class="">"965a393a-dc96-422f-87ac-9f3d8bb25142"</SPAN><SPAN class="">,</SPAN></SPAN>
<SPAN>    <SPAN class="">"origin"</SPAN><SPAN class="">:</SPAN> <SPAN class="">"sap.default"</SPAN><SPAN class="">,</SPAN></SPAN>
<SPAN>    <SPAN class="">"iat"</SPAN><SPAN class="">:</SPAN> <SPAN class="">1692693022</SPAN><SPAN class="">,</SPAN></SPAN>
<SPAN>    <SPAN class="">"exp"</SPAN><SPAN class="">:</SPAN> <SPAN class="">1692736222</SPAN><SPAN class="">,</SPAN></SPAN>
<SPAN>    <SPAN class="">"..."</SPAN><SPAN class="">:</SPAN> <SPAN class="">"..."</SPAN></SPAN>
<SPAN>  <SPAN class="">},</SPAN></SPAN>
<SPAN>  <SPAN class="">"signature"</SPAN><SPAN class="">:</SPAN> <SPAN class="">"ZVe_aqyLAyXwToCvG..."</SPAN><SPAN class="">,</SPAN></SPAN>
<SPAN>  <SPAN class="">"input"</SPAN><SPAN class="">:</SPAN> <SPAN class="">"eyJhbGciOiJSUzI1NiIsI..."</SPAN></SPAN>
<SPAN><SPAN class="">}</SPAN></SPAN></PRE></DIV><P>These properties are standard registered claim names, defined in the <A href="https://datatracker.ietf.org/doc/html/rfc7519" target="_blank" rel="noopener nofollow noreferrer">JSON Web Token (JWT) RFC7519</A>. Specifically, they are:</P><UL><LI>the <A href="https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.6" target="_blank" rel="noopener nofollow noreferrer">"iat" (Issued At) Claim</A> which conveys when the token was issued</LI><LI>the <A href="https://datatracker.ietf.org/doc/html/rfc7519#section-4.1.4" target="_blank" rel="noopener nofollow noreferrer">"exp" (Expiration Time) Claim</A> which conveys when the token expires</LI></UL><P>The values of these claims (1692693022 and 1692736222) are UNIX epoch values, i.e. the number of seconds since the UNIX epoch (01 Jan 1970), a standard way to measure time.</P><P>Let's examine these a little closer, using the power of the command line and a bit of jq, because <A href="https://qmacro.org/tags/jq/" target="_blank" rel="noopener nofollow noreferrer">why not</A>. Getting the value of the actual access token from the JSON object in tokendata.json file, getting it parsed into its component JWT parts (using the jwt command line tool that we learned about in the previous task), and then taking the exp and iat values from the payload part of the JWT, subtracting one from the other:</P><PRE>jq \
  --raw-output \
  '.access_token' \
  tokendata.json \
  | jwt --output=json \
  | jq '.payload | .exp - .iat'</PRE><P>This emits, rather beautifully:</P><PRE>43200</PRE><BLOCKQUOTE><P>The --raw-output (which can be shortened to -r) tells jq to emit the raw string, rather than try to always emit valid JSON. So if the value is the string 'hello', then the raw version is hello whereas a valid value as far as JSON is concerned is "hello". Yes, a double-quoted string, all on its own, is syntactically valid JSON. See <A class="" href="https://www.json.org/json-en.html" target="_blank" rel="noopener nofollow noreferrer">https://www.json.org/json-en.html</A> for more details.</P></BLOCKQUOTE><P>What about the values themselves? Well, if you're running a standard UNIX style environment with the normal tools (such as in a Dev Space in the SAP Business Application Studio) you can use the standard date command to convert from an epoch value.</P><P>Starting almost the same as before, let's first emit the two epoch values:</P><PRE>jq \
  -r \
  '.access_token' \
  tokendata.json \
  | jwt --output=json \
  | jq '.payload | .iat, .exp'</PRE><P>This produces:</P><PRE>1692693022
1692736222</PRE><P>We can then feed those into the date command, using the --date (or -d) parameter to display the date and time denoted by the value that follows it, which will be the epoch time preceded with an @ sign to symbolize "this value is the number of seconds since the epoch":</P><PRE>jq \
  -r \
  '.access_token' \
  tokendata.json \
  | jwt --output=json \
  | jq -r '.payload | "@\(.iat)", "@\(.exp)"' \
  | while read -r epochvalue; do
      date -d "$epochvalue";
  done</PRE><P>This produces:</P><PRE>Tue Aug 22 08:30:22 UTC 2023
Tue Aug 22 20:30:22 UTC 2023</PRE><P>It was last Tuesday morning that I requested and received this access token. And we can see that it expired exactly 12 hours (43200 seconds) later, at Tue Aug 22 20:30:22 UTC 2023. And lo and behold, this is precisely the date and time given in the error description returned in the response where we got an HTTP 401 (UNAUTHORIZED) status code:</P><PRE>error_description="An error occurred while attempting to decode the Jwt: Jwt expired at 2023-08-22T20:30:22Z"</PRE><P>So what are we going to do?</P><P>Of course, the sledgehammer approach would be to request another access token. But that's bad practice, because the Resource Owner Password Grant grant type requires the resource owner's credentials, and for the consumer script to hold onto them for such purposes is (or should be) frowned upon, and for the script to re-request them from the resource owner each time is an anti-pattern.</P><P>Instead, we can request a new token via the <A href="https://oauth.net/2/grant-types/refresh-token/" target="_blank" rel="noopener nofollow noreferrer">Refresh Token grant type</A>, which "<EM>allows clients to continue to have a valid access token without further interaction with the user</EM>". Isn't OAuth lovely?</P><H3 id="toc-hId--1905956477">Using the refresh token grant type</H3><P>So we have everything we need already to request a fresh token. This is what must be supplied in such a call:</P><UL><LI>the client's identity (the client ID and secret)</LI><LI>the grant type, which must be refresh_token</LI><LI>the actual refresh token itself</LI></UL><P>The refresh token itself was supplied along with the original access token, in the JSON object returned from the call in <A href="https://groups.community.sap.com/t5/application-development/sap-developer-challenge-apis-task-10-request-an-oauth-access/m-p/281933" target="_blank" rel="noopener noreferrer">Task 10</A>, which we saw briefly earlier in this section:</P><DIV class=""><PRE><SPAN><SPAN class="">{</SPAN></SPAN>
<SPAN> <SPAN class="">"access_token"</SPAN><SPAN class="">:</SPAN> <SPAN class="">"eyJhbGciOiJSUzI1NiIs..."</SPAN><SPAN class="">,</SPAN></SPAN>
<SPAN> <SPAN class="">"token_type"</SPAN><SPAN class="">:</SPAN> <SPAN class="">"bearer..."</SPAN><SPAN class="">,</SPAN></SPAN>
<SPAN> <SPAN class="">"id_token"</SPAN><SPAN class="">:</SPAN> <SPAN class="">"eyJhbGciOiJSUzI1NiIs..."</SPAN><SPAN class="">,</SPAN></SPAN>
<SPAN> <SPAN class="">"refresh_token"</SPAN><SPAN class="">:</SPAN> <SPAN class="">"e72b61a9a9304dde963e..."</SPAN><SPAN class="">,</SPAN></SPAN>
<SPAN> <SPAN class="">"expires_in"</SPAN><SPAN class="">:</SPAN> <SPAN class="">43199</SPAN><SPAN class="">,</SPAN></SPAN>
<SPAN> <SPAN class="">"scope"</SPAN><SPAN class="">:</SPAN> <SPAN class="">"cis-central!b14.glob..."</SPAN><SPAN class="">,</SPAN></SPAN>
<SPAN> <SPAN class="">"jti"</SPAN><SPAN class="">:</SPAN> <SPAN class="">"579fea14a1cf47d7ab9e..."</SPAN></SPAN>
<SPAN><SPAN class="">}</SPAN></SPAN></PRE></DIV><P>And of course, we still have the client ID and client secret in the service key data (stored in the tokendata.json file).</P><P>Where do we send such a call? To the same Authorization Server endpoint as before, i.e. to the /oauth/token endpoint we've used already.</P><P>So a token refresh call looks very similar to the previous request when the grant type was "password". Here's the structure:</P><PRE>curl \
  --user '&lt;clientid&gt;:&lt;clientsecret&gt;' \
  --data 'grant_type=refresh_token' \
  --url 'authorizationserver/oauth/token'</PRE><P>Note that the resource owner credentials are conspicuous by their absence here. They are not needed, and should not be required!</P><P>Here's an actual call. Values are needed from two places - the service key data and the access token JSON object.</P><P>From the service key data, the &lt;clientid&gt;:&lt;clientsecret&gt; construction is achieved with a bit of jq inside a <A href="https://www.gnu.org/software/bash/manual/html_node/Command-Substitution.html" target="_blank" rel="noopener nofollow noreferrer">command substitution</A> expansion, joining the .clientid and .clientsecret values (found within the .credentials.uaa value, which is an object) with a colon. And the retrieval of the actual authorization server details is also done in a similar way, taking the value of the .credentials.uaa.url property in the service key data.</P><P>And from the access token JSON object, the refresh_token value is taken.</P><PRE>curl \
  --user "$(jq -r '.credentials.uaa|[.clientid,.clientsecret]|join(":")' sk.json)" \
  --data 'grant_type=refresh_token' \
  --data-urlencode "refresh_token=$(jq -r .refresh_token tokendata.json)" \
  --url "$(jq -r .credentials.uaa.url sk.json)/oauth/token" \
  | tee tokendata.json</PRE><BLOCKQUOTE><P>The venerable UNIX command tee is used here to save the output (the new access token and corresponding metadata in a JSON object) in a file (tokendata.json) as well as letting it pass through to STDOUT so we see it too. It's called tee because it's like using a <A href="https://www.screwfix.com/c/heating-plumbing/pipe-fittings/cat831504?pipefittingproducttype=tees" target="_blank" rel="noopener nofollow noreferrer">tee pipe fitting</A> in a plumbing context.</P></BLOCKQUOTE><P>And what do you know? We get a freshly minted access token to use, with 12 more hours on the clock:</P><DIV class=""><PRE><SPAN><SPAN class="">{</SPAN></SPAN>
<SPAN>  <SPAN class="">"access_token"</SPAN><SPAN class="">:</SPAN> <SPAN class="">"eyJhbGciOiJSUzI1Niq2..."</SPAN><SPAN class="">,</SPAN></SPAN>
<SPAN>  <SPAN class="">"token_type"</SPAN><SPAN class="">:</SPAN> <SPAN class="">"bearer..."</SPAN><SPAN class="">,</SPAN></SPAN>
<SPAN>  <SPAN class="">"id_token"</SPAN><SPAN class="">:</SPAN> <SPAN class="">"eyJhbGciOiJSUzI1NiJS..."</SPAN><SPAN class="">,</SPAN></SPAN>
<SPAN>  <SPAN class="">"refresh_token"</SPAN><SPAN class="">:</SPAN> <SPAN class="">"e72b61a9a9304dae263e..."</SPAN><SPAN class="">,</SPAN></SPAN>
<SPAN>  <SPAN class="">"expires_in"</SPAN><SPAN class="">:</SPAN> <SPAN class="">43199</SPAN><SPAN class="">,</SPAN></SPAN>
<SPAN>  <SPAN class="">"scope"</SPAN><SPAN class="">:</SPAN> <SPAN class="">"cis-central!b14.glob..."</SPAN><SPAN class="">,</SPAN></SPAN>
<SPAN>  <SPAN class="">"jti"</SPAN><SPAN class="">:</SPAN> <SPAN class="">"579fea14a1cf47d7ab9e..."</SPAN></SPAN>
<SPAN><SPAN class="">}</SPAN></SPAN></PRE></DIV><P>Nice!</P><BLOCKQUOTE><P>It's useful to know as well that you can refresh your token before the expiry. This gives you a chance to build in a robust token management system into your client, and avoid the risk of falling between the gaps between validity periods.</P></BLOCKQUOTE><H3 id="toc-hId--163146142">Using a valid access token</H3><P>Now that we have a fresh, valid access token, we can complete the journey and make the call to the API endpoint. There's nothing special here, so let's get right to trying it out. In fact, the call is going to be exactly the same as before; the only thing that is different now is that the access token is still valid:</P><PRE>curl \
  --silent \
  --header "Authorization: Bearer $(jq -r .access_token tokendata.json)" \
  --url "$(jq -r .credentials.endpoints.accounts_service_url sk.json)/accounts/v1/directories/57675710-7b16-43ec-b64a-ab14660c1b24"</PRE><BLOCKQUOTE><P>The --silent parameter here is used to suppress the "progress bar" that curl shows while retrieving a resource.</P></BLOCKQUOTE><P>And the call is successful, emitting ...</P><P>Well.</P><P>That would be giving the task away, wouldn't it!</P><H2 id="toc-hId-1776177698">Your task</H2><P>Your task is to ensure you have a valid access token. Ideally, you should work through the process above, using your old (and expired) access token to make a first call to the API endpoint, using the GUID of your directory that you created.</P><P>You should see the HTTP 401 status code and look at the value of the WWW-Authenticate header in the HTTP response. You should embrace all that this entails and enjoy matching up the expiration date and time stated in that header, and try to match it up with the value of the exp claim in the payload of the JWT that is your old access token.</P><P>Then you should run through the process of requesting a new token, using the Refresh Token grant type explained above.</P><P>And with this fresh access token, you should make the call again to the API endpoint, to get the details of the directory that you created way back in <A href="https://groups.community.sap.com/t5/application-development/sap-developer-challenge-apis-task-7-create-a-new-directory-in-an/td-p/280341" target="_blank" rel="noopener noreferrer">Task 7</A>.</P><P>Once you have this directory detail, which will be in the form of a JSON object, you should take the value of two of the properties in that detail, join them together with a colon, and send them to the hash service. Then, as always, and as described in <A href="https://groups.community.sap.com/t5/application-development/sap-developer-challenge-apis-task-0-learn-to-share-your-task/td-p/276058" target="_blank" rel="noopener noreferrer">Task 0</A>, you should reply to this discussion thread with the hash that's returned.</P><P>You need to take the values from these two properties:</P><UL><LI>displayName</LI><LI>directoryType</LI></UL><P>And don't forget to concatenate them with a colon.</P><P>That's it ... you've done it!</P><OL><LI>create an instance of the SAP Cloud Management Service, with a plan that contains the appropriate scope(s) that you need <span class="lia-unicode-emoji" title=":white_heavy_check_mark:">âœ…</span></LI><LI>create a service key based on that instance <span class="lia-unicode-emoji" title=":white_heavy_check_mark:">âœ…</span></LI><LI>use the details in the service key to request an access token <span class="lia-unicode-emoji" title=":white_heavy_check_mark:">âœ…</span></LI><LI>use the access token thus obtained to authenticate a call to the API endpoint <span class="lia-unicode-emoji" title=":white_heavy_check_mark:">âœ…</span></LI></OL><P>Great work.</P><H2 id="toc-hId--775979263">Hints and tips</H2><P>Most of what you'll need has already been covered this time in the narrative within the Background section. And you've all worked so hard with these tasks over the month that you're now well prepared for working with APIs in the SAP universe, dealing with OAuth, endpoints, service key information and more.</P><P>Well done!</P><H2 id="toc-hId-966831072">For discussion</H2><P>In the directory details that were returned from your successful call to the API endpoint, did you also spot the label information that you added during the directory's creation in Task 7? Where was it? What else did you find interesting about the data returned?</P>
