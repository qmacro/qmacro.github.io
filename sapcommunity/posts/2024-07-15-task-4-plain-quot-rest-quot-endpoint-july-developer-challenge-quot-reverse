2024-07-15-task-4-plain-quot-rest-quot-endpoint-july-developer-challenge-quot-reverse
Task 4 - Plain "REST" endpoint (July Developer Challenge - "Reverse APIs")
application-developmentforum-board
2024-07-15
https://community.sap.com/t5/application-development-discussions/task-4-plain-quot-rest-quot-endpoint-july-developer-challenge-quot-reverse/td-p/13760488
<DIV class=""><DIV class=""><DIV class=""><DIV class=""><DIV class=""><P>This is a task in the<SPAN>&nbsp;</SPAN><A href="https://community.sap.com/t5/application-development-blog-posts/2024-07-quot-reverse-apis-quot-sap-developer-challenge/ba-p/13749653" target="_blank">July Developer Challenge - "Reverse APIs"</A>.</P><P>In this task, you'll create a new, second service, and within that you'll add a single API endpoint. The difference to the previous service and endpoints is that here a plain "REST" protocol is required.</P><H2 id="toc-hId-1020171749">Background</H2><P>What does that mean, exactly? Well, you may know that CAP's design is wonderfully modular, and agnostic as well as opinionated. I'm sure you will also know that if you define a service in your CDS model and serve it with the CAP server, you'll basically have an OData service. Standing up and serving OData services was the original<SPAN>&nbsp;</SPAN><A href="https://www.bbc.co.uk/news/business-47802280" target="_blank" rel="nofollow noopener noreferrer">killer app</A><SPAN>&nbsp;</SPAN>for the SAP Cloud Application Programming Model. It's hard now to remember how much effort it was, before CAP came along, to create and serve an OData service - and there was even more effort, much more, in fact, to facilitate all Create, Read, Update, Delete &amp; Query (CRUD+Q) operations for the data model you had defined. We take it for granted that with CAP we can spin up an OData service with fully functional support for all standard CRUD+Q operations in a couple of minutes.</P><BLOCKQUOTE><P>When talking about OData, I refer specifically to OData V4. This is for two reasons: CAP's default for OData is also V4, and, well, OData V4 is already<SPAN>&nbsp;</SPAN><A href="https://github.com/qmacro/odata-specs/blob/master/overview.md" target="_blank" rel="nofollow noopener noreferrer">over a decade old</A>.</P></BLOCKQUOTE><H3 id="toc-hId-952740963">Protocols and CAP's modular design</H3><P>While CAP will default to serving OData services, its modular design allows for services to be served using different protocols. Yes, OData is more than<SPAN>&nbsp;</SPAN><A href="https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html" target="_blank" rel="nofollow noopener noreferrer">a protocol</A>, but the protocol component is critical.</P><P>And that leads us on to the other protocol that CAP can serve, out of the box: "REST". I personally put "REST" here in quotes, because REST is not a protocol, it is an architectural style, with a set of<SPAN>&nbsp;</SPAN><A href="https://en.wikipedia.org/wiki/REST#Architectural_constraints" target="_blank" rel="nofollow noopener noreferrer">constraints</A><SPAN>&nbsp;</SPAN>that should inform the design of HTTP-based APIs, if they are to be accurately referred to as "RESTful". Incidentally, if an API conforms to all of the architectural constraints described, it is referred to as "Fully RESTful", and yes, that's the "hidden" (second, or first) meaning behind the name of my narrowboat where I live and work.</P><P><span class="lia-inline-image-display-wrapper lia-image-align-inline" image-alt="fullyrestful.png" style="width: 999px;"><img src="https://community.sap.com/t5/image/serverpage/image-id/136558i61D777AAF79A84FE/image-size/large?v=v2&amp;px=999" role="button" title="fullyrestful.png" alt="fullyrestful.png" /></span></P><P>When you see "REST" referred to as a protocol, think of it as a "plain HTTP" style API.</P><P>Anyway, for the sake of this Developer Challenge, and for common understanding and consistency with Capire, the CAP documentation, we can think of "REST" as a protocol. You can see in the<SPAN>&nbsp;</SPAN><A href="https://cap.cloud.sap/docs/node.js/cds-serve#cds-protocols" target="_blank" rel="nofollow noopener noreferrer">cds.serve() - cds.protocols</A><SPAN>&nbsp;</SPAN>section of Capire which protocol adapters are available both out of the box and as an open source package.</P><P>It's important then to think of a CAP service in different contexts, or at different layers:</P><UL><LI>the definition (in CDL, within the CDS model as a whole)</LI><LI>the implementation (in Node.js or Java)</LI><LI>the protocol used to serve it</LI></UL><P>And as the primary protocols used to serve it are all based on the application protocol that is HTTP, there's a link between the protocol used, and how that is indicated, or exposed, as part of the URL path. Here are the default paths for the standard protocols:</P><UL><LI>OData V4:<SPAN>&nbsp;</SPAN>/odata/v4</LI><LI>"REST":<SPAN>&nbsp;</SPAN>/rest</LI><LI>GraphQL:<SPAN>&nbsp;</SPAN>/graphql</LI></UL><P>And OData V4 is the default protocol. So by default, if you define a service<SPAN>&nbsp;</SPAN>x, it will be served as an OData V4 service, at the service path<SPAN>&nbsp;</SPAN>/odata/v4/x.</P><P>With the<SPAN>&nbsp;</SPAN><A href="https://cap.cloud.sap/docs/node.js/cds-serve#path" target="_blank" rel="nofollow noopener noreferrer">@path</A><SPAN>&nbsp;</SPAN>annotation you can specify a custom path for the service, and this is what you were required to do for the service that contained the API endpoints described in Tasks 1, 2 and 3, in that the required path for the OData service was<SPAN>&nbsp;</SPAN>/basic, rather than<SPAN>&nbsp;</SPAN>/odata/v4/basic.</P><P>With the<SPAN>&nbsp;</SPAN><A href="https://cap.cloud.sap/docs/node.js/cds-serve#protocol" target="_blank" rel="nofollow noopener noreferrer">@protocol</A><SPAN>&nbsp;</SPAN>annotation you can specify the protocol.</P><H3 id="toc-hId-756227458">Differences between the OData V4 and "REST" protocols</H3><P>If you take a basic CAP service<SPAN>&nbsp;</SPAN>x<SPAN>&nbsp;</SPAN>that defaults to being served as an OData protocol, at<SPAN>&nbsp;</SPAN>/odata/v4/x, and then switch protocols by annotating it with<SPAN>&nbsp;</SPAN>@protocol: 'rest'<SPAN>&nbsp;</SPAN>(or simply<SPAN>&nbsp;</SPAN>@rest) you'll see that while there are differences between the key resources (such as the entity sets) they are only very slight. Perhaps most notably there's an absence of any notion of metadata or metadata context. Even the standard OData system query options (such as<SPAN>&nbsp;</SPAN>$filter<SPAN>&nbsp;</SPAN>and<SPAN>&nbsp;</SPAN>$select) are supported.</P><P>That lack of differences, in my opinion, is because it makes a lot of sense, based on a combination of reasons:</P><UL><LI>OData has a well thought out, battle-tested and mature<SPAN>&nbsp;</SPAN><A href="https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html" target="_blank" rel="nofollow noopener noreferrer">protocol</A>,<SPAN>&nbsp;</SPAN><A href="https://docs.oasis-open.org/odata/odata/v4.01/os/part2-url-conventions/odata-v4.01-os-part2-url-conventions.html" target="_blank" rel="nofollow noopener noreferrer">set of URL convention</A><SPAN>&nbsp;</SPAN>and<SPAN>&nbsp;</SPAN><A href="https://docs.oasis-open.org/odata/odata-csdl-json/v4.01/odata-csdl-json-v4.01.html" target="_blank" rel="nofollow noopener noreferrer">schema definition language</A></LI><LI>Not being an actual protocol, REST needs some concrete decisions with respect not only to addressing and accessing &amp; manipulating resources, but also to providing those resources in specific representations. And OData's approach is both well designed and well understood, from a URL convention perspective (addressing and accessing resources), from a protocol perspective (accessing &amp; manipulating resources) and resource provision perspective (providing those resources in specific representations). So why re-invent?</LI><LI>a well-designed plain HTTP protocol today should work with, rather than fight against, the HTTP constructs and philosophy of being an application protocol (yes I'm looking at you, GraphQL)</LI></UL><P>This and the next couple of tasks give you a chance to explore these ideas, and the "REST" protocol in particular.</P><H2 id="toc-hId-430631234">The requirements</H2><P>Here are the specific requirements for this task.</P><P>You must create a new service called<SPAN>&nbsp;</SPAN>plain. One separate to the<SPAN>&nbsp;</SPAN>basic<SPAN>&nbsp;</SPAN>service that you already have. The service must be served via the "REST" protocol, at the default endpoint for such a service.</P><P>Within this new service, you should define a very simple API endpoint that returns a static value, <A href="https://simple.wikipedia.org/wiki/42_(answer)" target="_self" rel="nofollow noopener noreferrer">the answer to life, the universe, and everything</A>. Very much like the endpoint in<SPAN>&nbsp;</SPAN><A href="https://community.sap.com/t5/application-development-discussions/task-1-your-first-service-and-first-endpoint-july-developer-challenge-quot/m-p/13752205" target="_blank">Task 1 - Your first service and endpoint</A>.</P><P>It should expect no arguments (and therefore be defined with no parameters), and be standalone, i.e. "unbound". It should be callable via the HTTP GET method and have no side-effects, i.e. a "function".</P><BLOCKQUOTE><P>The terms bound and unbound, and the idea of and semantic differences between functions and actions, are taken from the OData world, but make sense here in the land of more plain HTTP based APIs, especially as with CAP, the service definition (CDS model), and the serving of the service (protocol), are separate.</P></BLOCKQUOTE><P>To underline, however, that we've now moved away from the OData protocol, the API endpoint should be addressable via the following simpler path:</P><DIV class=""><PRE>/rest/plain/theAnswer</PRE><DIV class=""><SPAN>Note the lack of parentheses at the end of the last segment.</SPAN></DIV></DIV><P>Like always, once you've got your service defined, and a simple implementation ready, you're done.</P><P>It is definitely worth testing it yourself first, e.g. with<SPAN>&nbsp;</SPAN>curl, Postman, or even the<SPAN>&nbsp;</SPAN><A href="https://marketplace.visualstudio.com/items?itemName=humao.rest-client" target="_blank" rel="nofollow noopener noreferrer">REST Client</A><SPAN>&nbsp;</SPAN>extension to VS Code that some of you are using (going on what I can see from some of your responses to the<SPAN>&nbsp;</SPAN><A href="https://community.sap.com/t5/application-development-discussions/july-developer-challenge-quot-reverse-apis-quot-task-1-your-first-service/m-p/13752205" target="_blank">previous task</A>). Use whatever tool you prefer for making HTTP calls.</P><P>With your server running (on, let's say, the default local CAP server port of 4004), make a request like this:</P><DIV class=""><PRE>curl -s --url <SPAN class=""><SPAN class="">"</SPAN>localhost:4004/rest/plain/theAnswer<SPAN class="">"</SPAN></SPAN></PRE><DIV class=""><SPAN>and the reponse should look like this:</SPAN></DIV></DIV><DIV class=""><PRE>42</PRE><DIV class=""><SPAN>For some bonus kudos, share your observation in the comments below on the default representation here. What is the value of the Content-Type header in the HTTP responses served for your endpoint?. What would it be if you served an array of Integers?</SPAN></DIV></DIV><H2 id="toc-hId-234117729">Defining and implementing this second service</H2><P>CAP offers flexibility, not least in service definitions (in the overall CDS model) and implementations. In needing to define and implement a new, second service, you have lots of choices:</P><UL><LI>define the service in the same, existing<SPAN>&nbsp;</SPAN>.cds<SPAN>&nbsp;</SPAN>file that you already have</LI><LI>create a new<SPAN>&nbsp;</SPAN>.cds<SPAN>&nbsp;</SPAN>file</LI></UL><P>and of course you could always:</P><UL><LI>create a completely new CAP project</LI></UL><P>Which way you go is up to you. It would be great to hear from you, again, in the comments below, which approach you took.</P><H2 id="toc-hId-37604224">Submitting your API endpoint to the TESTER</H2><P>Now you're ready to submit your CANDIDATE service, with the specific API endpoint, to the TESTER!</P><H3 id="toc-hId--29826562">The payload</H3><P>The task identifier you need to supply in the payload of your submission is:<SPAN>&nbsp;</SPAN><STRONG>plain-theAnswer</STRONG>.</P><P>You'll have already done this sort of thing<SPAN>&nbsp;</SPAN><A href="https://community.sap.com/t5/application-development-discussions/july-developer-challenge-quot-reverse-apis-quot-task-1-your-first-service/m-p/13752205" target="_blank">previously</A><SPAN>&nbsp;</SPAN>so just head back there for the more detailed instructions if you need them, or to the the section titled "<A href="https://community.sap.com/t5/application-development-blog-posts/2024-07-quot-reverse-apis-quot-sap-developer-challenge/ba-p/13749653#toc-hId--553513390" target="_blank">The Tester service, and making a test request</A>" in the<SPAN>&nbsp;</SPAN><A href="https://community.sap.com/t5/application-development-blog-posts/2024-07-quot-reverse-apis-quot-sap-developer-challenge/ba-p/13749653" target="_blank">main challenge blog post</A>.</P><P>Now, to have your freshly minted API endpoint in this task tested, you'll need to submit a JSON payload like this:</P><DIV class=""><PRE>{
  <SPAN class="">"communityid"</SPAN>: <SPAN class=""><SPAN class="">"</SPAN>&lt;your-community-id&gt;<SPAN class="">"</SPAN></SPAN>,
  <SPAN class="">"serviceurl"</SPAN>: <SPAN class=""><SPAN class="">"</SPAN>&lt;the-URL-of-your-service&gt;<SPAN class="">"</SPAN></SPAN>,
  <SPAN class="">"task"</SPAN>: <SPAN class=""><SPAN class="">"</SPAN>plain-theAnswer<SPAN class="">"</SPAN></SPAN>
}</PRE><DIV class=""><SPAN>And, just as with the previous (and all further tasks):</SPAN></DIV></DIV><UL><LI><P>the value for the<SPAN>&nbsp;</SPAN>communityid<SPAN>&nbsp;</SPAN>property should be your ID on this SAP Community platform (e.g. mine is "qmacro")</P></LI><LI><P>the value for the<SPAN>&nbsp;</SPAN>serviceurl<SPAN>&nbsp;</SPAN>property should be the absolute URL (i.e. including the scheme), of your CANDIDATE<SPAN>&nbsp;</SPAN><STRONG>service</STRONG><SPAN>&nbsp;</SPAN>which<SPAN>&nbsp;</SPAN><EM>contains</EM><SPAN>&nbsp;</SPAN>the API endpoint (see<SPAN>&nbsp;</SPAN><A href="https://community.sap.com/t5/application-development-blog-posts/2024-07-quot-reverse-apis-quot-sap-developer-challenge/ba-p/13749653#toc-hId--356999885" target="_blank"><span class="lia-unicode-emoji" title=":information:">ℹ️</span><SPAN>&nbsp;</SPAN>A note on URLs and services</A>), not the full URL of the specific API endpoint itself</P></LI></UL><P>That's it!</P><H2 id="toc-hId--355422786">Logging of test results</H2><P>Remember that you can check on your progress, and the progress of your fellow participants - all requests are logged and are available in an entity set served by the TESTER service. The entity set URL is<SPAN>&nbsp;</SPAN><A href="https://developer-challenge-2024-07.cfapps.eu10.hana.ondemand.com/tester/Testlog" target="_blank" rel="nofollow noopener noreferrer">https://developer-challenge-2024-07.cfapps.eu10.hana.ondemand.com/tester/Testlog</A><SPAN>&nbsp;</SPAN>and being an OData V4 entity set, all the normal OData system query options are available to you for digging into that information.</P><P>Until the next task, have fun, and if you have any questions or comments, leave them below!</P></DIV></DIV></DIV></DIV></DIV>
