2023-08-23-sap-developer-challenge-apis-task-9-create-a-service-key-for-api-endpoints
SAP Developer Challenge - APIs - Task 9 - Create a service key for API endpoints and auth info
application-developmentforum-board
2023-08-23
https://community.sap.com/t5/application-development-discussions/sap-developer-challenge-apis-task-9-create-a-service-key-for-api-endpoints/td-p/281337
<P>(Check out the <A href="https://blogs.sap.com/2023/08/01/sap-developer-challenge-apis/" target="_blank" rel="noopener noreferrer">SAP Developer Challenge - APIs</A> blog post for everything you need to know about the challenge to which this task relates!)</P><P>This task follows on from the previous task and moves you one step closer in your steady journey of enlightenment, moving towards calling an API endpoint on SAP BTP.</P><H2 id="toc-hId-1652002092">Background</H2><P>In the previous task, you created an instance of the SAP Cloud Management Service. Why? Because this service provides facilities to manage resources on SAP BTP, and those facilities include the APIs you've been learning about in previous tasks in this group. But merely having an instance of the service isn't going to get you far.</P><P>To consume a service's facilities, more is needed. In an application context, an app is bound to a service instance, and, once bound, can consume those facilities. The same goes for API calls. What's needed are a couple of things - endpoint information and credential information.</P><P>So. You've done step 1 of the steps introduced in the previous task. Now you're tackling step 2.</P><OL><LI>create an instance of the SAP Cloud Management Service, with a plan that contains the appropriate scope(s) that you need <span class="lia-unicode-emoji" title=":white_heavy_check_mark:">âœ…</span></LI><LI>create a service key based on that instance</LI><LI>use the details in the service key to request an access token</LI><LI>use the access token thus obtained to authenticate a call to the API endpoint</LI></OL><H3 id="toc-hId--1096668374">Endpoint information</H3><P>First, you need some information on the API endpoints. This is because information you found on the SAP Business Accelerator Hub for the endpoint you're going to call:</P><PRE>GET /accounts/v1/directories/{directoryGUID}</PRE><P>only presents a relative path (/accounts/v1/directories/{directoryGUID}). For it to be a callable endpoint it needs of course to be prefixed with the rest of the URL - the scheme and fully qualified domain name, at least.</P><BLOCKQUOTE><P>To be precise, the http (or https) part of a URL is known as the "scheme". See the <A href="https://en.wikipedia.org/wiki/List_of_URI_schemes" target="_blank" rel="noopener nofollow noreferrer">List of URI schemes</A> Wikipedia page for more information. And while we're in precision mode, are you wondering about the difference between URL and URI? They're not the same. URLs are a subset of URIs. A URI (Uniform Resource Identifier) is just a string that identifies a resource. A URL (Uniform Resource Locator) identifies a resource, but also allows you to locate that resource. Yes, the clue really is in the name(s) <span class="lia-unicode-emoji" title=":slightly_smiling_face:">ðŸ™‚</span></P></BLOCKQUOTE><H3 id="toc-hId-646141961">Credential information</H3><P>As well as endpoint information, you also need access, in the form of authentication. What form that takes, and how it's used, is sometime service-specific. But generally there will be a requirement to provide credentials in the API call itself.</P><P>You've done this already in a previous task, in that you provided an API key in an "APIKey" header, when you made the call to the country date format API endpoint in <A href="https://groups.community.sap.com/t5/application-development/sap-developer-challenge-apis-task-5-call-the-country-date-format/td-p/279160" target="_blank" rel="noopener noreferrer">Task 5 - Call the country date format API endpoint</A></P><P>More commonly, the standard <A href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Authorization" target="_blank" rel="noopener nofollow noreferrer">Authorization HTTP header</A> is used to convey the credentials. The value for this header is usually made up of two parts, and formed like this:</P><PRE>Authorization: &lt;auth scheme&gt; &lt;auth details&gt;</PRE><P>In the bad (good?) old days, you may well have used Basic Authentication, i.e. provided a username and password, joined with a colon, and encoded in Base64. Here's an example of that:</P><PRE>Authorization: Basic d2VsbC1kb25lOnlvdXItY3VyaW9zaXR5LWlzLWdyZWF0IQ==</PRE><P>Note that encoding != encrypting, which means that this approach was somewhat insecure, in that anyone who could see the HTTP request headers could obtain those credentials. Moreover, obtaining credentials as fundamental as username and password means a world of pain if they are ever compromised.</P><P>This is why OAuth, which focuses on obtaining and using tokens as credentials, is a far better approach for managing the request and use of credentials. Generally, tokens are obtained up front (sometimes requiring username and password style information) and then also eventually expire (they can be refreshed using a similar but simpler approach to the original way they were obtained). Expired tokens are no use to anyone, and if a token is compromised, it can be expired a lot easier, and with far fewer side effects (on other consumers using the same credential approach) than expiring or invalidating a compromised username and password.</P><P>Anyway, getting back to this Authorization header, there are other more secure auth schemes that are standard and used with this header, and you'll be working towards using such a scheme in the next task.</P><H3 id="toc-hId--1906015000">Service keys</H3><P>This endpoint and credential information, essential to consume a service's facilities, is provisioned in so-called "service keys", that relate to an instance of a service.</P><P>Creating a service key effectively brings about the creation of credentials that are then valid for use by the consumer. Once a service key has been created, it can be retrieved, and will contain the credentials, plus information on the endpoints.</P><P>When an app is bound to a service instance, similar information is created (this is why one can equate the term "service key" with "binding" and why different cloud platform runtimes use these terms almost interchangeably).</P><H2 id="toc-hId-33308840">Your task</H2><P>Your task, then, is to create a service key for the instance of the SAP Cloud Management Service you created in the previous task. You should use the cf CLI to do this. You'll have to give the service key a name; it doesn't really matter too much what you call it; the name "sk" will do fine for the purpose of this task, but in the end, you can choose.</P><P>Once you have created a service key, you should retrieve it, and take a look at the information, which will be in JSON. You'll need to compose a value (to send to the hash service) based on some of the property names in this JSON data.</P><P>That value should be a sorted list of the endpoint property names (not their values), separated by commas. To be clear, these endpoint property names are the keys of the key/value pairs inside the credentials.endpoints node, and they all end in _url.</P><P>Once you have composed that value, you should hash it and share as a new reply to this discussion thread, as always, and as described in <A href="https://groups.community.sap.com/t5/application-development/sap-developer-challenge-apis-task-0-learn-to-share-your-task/m-p/276058" target="_blank" rel="noopener noreferrer">Task 0</A>.</P><P>Oh, and while it's not part of this task's requirements, you might as well save the JSON in in a file, too, because you're going to need it again in the next task!</P><H2 id="toc-hId-1776119175">Hints and tips</H2><P>You're strongly encouraged to use the cf CLI for this task. This is for the usual obvious reasons, which are:</P><UL><LI>the command line is an extremely powerful and flexible environment</LI><LI>using and combining tools in a command line (shell) context is the ultimate in power and flexibility</LI><LI>you can script usage of such tools, embracing the facilities of the command line to build automation</LI><LI>it helps you get closer to the metal, to explore the details of the services and runtimes you're consuming</LI></UL><P>If, however, you do wish to use the GUI, in the form of the SAP BTP Cockpit, then go ahead. The cockpit, or any GUI for that matter, is great for one-off and occasional tasks, but it's no match for the power of the command line. You may wish to read the blog post <A href="https://blogs.sap.com/2022/12/12/managing-resources-on-sap-btp-what-tool-do-i-choose/" target="_blank" rel="noopener noreferrer">Managing resources on SAP BTP â€“ what tool do I choose?</A> which touches on this topic.</P><P>If you're using the cf CLI, you'll want to avail yourself of the commands within the "Services integration" section.</P><PRE>Services integration:
  marketplace,m        create-user-provided-service,cups
  services,s           update-user-provided-service,uups
  create-service,cs    create-service-key,csk
  update-service       delete-service-key,dsk
  delete-service,ds    service-keys,sk  service              service-key
  bind-service,bs      bind-route-service,brs
  unbind-service,us    unbind-route-service,urs</PRE><P>Note that once you've created your service key, and are looking at its output with:</P><PRE>cf service-key &lt;service-instance&gt; &lt;service-key&gt;</PRE><P>you'll notice that the output is JSON. Great! You can parse it and programatically generate the value you need to send to the hash service for your task reply.</P><P>However, note that the command is not entirely well-behaved, emitting "helpful" information just before the JSON itself. This is ultimately against the spirit of the UNIX command line philosophy. Here's an example of the output of such a command (some of the properties in the JSON have been removed for brevity):</P><PRE>Getting key cis-central-sk for service instance cis-central as dj.adams@sap.com...

{
  "credentials": {
    "endpoints": "..."
    "grant_type": "user_token",
    "sap.cloud.service": "com.sap.core.commercial.service.central",
    "uaa": {
      "uaadomain": "authentication.eu10.hana.ondemand.com",
      "xsappname": "ut-f86082c9-7fbf-4e1e-8310-f5d018dab542-clone!b254751|cis-central!b42",
      "xsmasterappname": "cis-central!b42",
      "zoneid": "7da58aab-6c60-4492-a95b-b1ed3139e242"
    }
  }
}</PRE><P>The first two lines ("Getting key ...", and the empty line) are not JSON. This means you will have to clean up the output of the command before processing it as JSON (and saving it to a file).</P><P>Note that the value of the endpoints property in the above output example is given as "..." - this is just for brevity in illustration; the value is in fact an object, containing properties, the names of which should be of interest to you for this task!</P><P>Note also that this example output also reminds us of one of the breaking changes between version 7 and version 8 of the cf CLI that were mentioned in the previous task. It's the advent of version 8 that brought along the outermost wrapping of the data within a new credentials property. Before version 8, that node does not exist in the JSON.</P>
