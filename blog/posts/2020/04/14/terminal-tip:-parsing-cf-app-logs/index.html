<!doctype html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="canonical" href="https://qmacro.org/blog/posts/2020/04/14/terminal-tip:-parsing-cf-app-logs/"><link rel="alternate" type="application/atom+xml" title="DJ's Weblog - Feed" href="https://qmacro.org/feed.xml"><link href="/assets/main.54fe08380532f159e78f.css" rel="stylesheet"><link rel="preconnect" href="https://fonts.gstatic.com"><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans&display=swap" rel="stylesheet"><title>Terminal Tip: parsing CF app logs | DJ Adams</title><link rel="icon" type="“image/x-icon”" href="/images/favicon.ico"><meta property="og:title" content="Terminal Tip: parsing CF app logs"><meta property="og:site_name" content="DJ Adams"><meta property="og:type" content="website"><meta property="og:url" content="https://qmacro.org/blog/posts/2020/04/14/terminal-tip:-parsing-cf-app-logs/"><meta name="description" content="Terminal Tip: parsing CF app logs 14 Apr 2020 | 4 min read Further to my last Terminal Tip on truncating CF output I have another terminal..."><meta property="og:description" content="Terminal Tip: parsing CF app logs 14 Apr 2020 | 4 min read Further to my last Terminal Tip on truncating CF output I have another terminal..."><meta name="description" content="Terminal Tip: parsing CF app logs 14 Apr 2020 | 4 min read Further to my last Terminal Tip on truncating CF output I have another terminal..."><meta property="og:image" content="https://qmacro.org/images/site-image.png"><script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script><script>mermaid.initialize({startOnLoad:true});</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-4WQKBG0L4Y"></script><script>window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-4WQKBG0L4Y');</script></head><body><div class="layout-wrapper"><header class="header"><div class="header__content"><h1 class="site-title"><a href="/">DJ Adams</a></h1><nav class="nav"><ul class="nav__list"><li class="nav-item"><a href="/about">About Me</a></li><li class="nav-item"><a href="/blog">Blog</a></li><li class="nav-item"><a href="/feed.xml">Feed</a></li></ul></nav></div></header><main class="main"><article class="post"><header class="post__header"><h1>Terminal Tip: parsing CF app logs</h1><div class="post__details"><time datetime="2020-04-14">14 Apr 2020 </time><span>| </span><span>4 min read</span></div></header><main class="post__content"><p>Further to my last <a href="/blog/posts/2020/04/07/terminal-tip:-truncating-cf-output/">Terminal Tip on truncating CF output</a> I have another terminal tip for you that might help in the context of reading log output from Cloud Foundry (CF) apps.</p><p><a href="https://docs.cloudfoundry.org/devguide/deploy-apps/streaming-logs.html">Application logging on CF</a> can be quite involved, and there's all sorts of useful information for diagnostics and monitoring purposes. If you're just starting out using the CF environment on SAP Cloud Platform, you might however be overwhelmed, rather than overjoyed, at the amount of information and how it's presented.</p><p>You can monitor the logs of an app on CF with the following command:</p><pre class="language-shell"><code class="language-shell">cf logs <span class="token operator">&lt;</span>appname<span class="token operator">></span></code></pre><p>Here's a screenshot of the sort of thing you might see from this command, at the startup of an app:</p><p><img src="/images/2020/04/Screenshot-2020-04-14-at-07.05.31.png" alt=""></p><p>I cut my commercial programming teeth working at Esso Petroleum in London on IBM big iron - mainframes running MVS/ESA, upon which we ran SAP R/2 systems with IMS DB/DC. While that was a rather proprietary OS environment, it did leave many lasting positive impressions, one of which was: logging is important and should be consistent, <a href="/blog/posts/2009/11/05/tech-skills-chat-with-jonerp-a-follow-on-story/#documentation">easily referenced</a>, and readable.</p><p>Just focusing on the last quality - readability - this log output may be readable by machines, but if you ask me, it should be readable by humans first, and machines second.</p><p>If you stare for a few seconds at the log output in the screenshot above, you may discern that it's in the form of JSON (!), and produced for the &quot;APP/PROC/WEB&quot; context. I've found myself interested in knowing what's going on in this context, so I turned to my terminal, and some venerable commands, to make this readable for humans too.</p><p>Like in the previous <a href="/blog/posts/2020/04/07/terminal-tip:-truncating-cf-output/">Terminal Tip</a>, I found myself creating a shell function &quot;lintlogs&quot; that I could pipe the output of the cf logs command into, to parse and format it nicely.</p><p>Because, effectively, all I'm interested in here is a timestamp for each log record, and the text details of what happened. Taking the last log record from the above screenshot as an example, all I want is something like this:</p><pre class="language-log"><code class="language-log"><span class="token date number">2020-04-14T</span><span class="token time number">07:15:22.102Z</span> Application router is listening on port<span class="token operator">:</span> <span class="token number">8080</span></code></pre><p>So, here's what was involved. First, let's take a look at the definition of the &quot;lintlogs&quot; function (printed here over separate lines for readability):</p><pre class="language-shell"><code class="language-shell"><span class="token function-name function">lintlogs</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <br>  <span class="token function">grep</span> --line-buffered <span class="token string">'OUT {'</span> <br>  <span class="token operator">|</span> stdbuf <span class="token parameter variable">-oL</span> <span class="token function">cut</span> <span class="token parameter variable">-d</span> <span class="token string">' '</span> <span class="token parameter variable">-f</span> <span class="token number">7</span>- <br>  <span class="token operator">|</span> jq <span class="token parameter variable">-r</span> <span class="token string">'.written_at + " " + .msg'</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre><p>First, remember that you define a shell function like this:</p><pre class="language-shell"><code class="language-shell"><span class="token function-name function">functionname</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">..</span>. <span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>Once it's defined, you can treat it like any other command in the shell, in particular in pipeline processing, i.e. you can pass data to it via STDIO as normal. That means you can pipe the output of one command and have it be the input to this function. That's exactly what's going on here (in the screenshot):</p><pre class="language-shell"><code class="language-shell">cf logs desttest <span class="token operator">|</span> lintlogs</code></pre><p>Now that's clear, let's take the function definition, one command at a time.</p><pre class="language-shell"><code class="language-shell"><span class="token function">grep</span> --line-buffered <span class="token string">'OUT {'</span></code></pre><p>Here, we're using the standard <a href="https://en.wikipedia.org/wiki/Grep">grep</a> command to search for string patterns in the input, in this case, we're looking for this highlighted section of the log lines:</p><p><img src="/images/2020/04/Screenshot-2020-04-14-at-08.15.54.png" alt=""></p><p>This is a crude but good-enough way to identify this type of log output.</p><p>The --line-buffered option for grep turns on line buffering on output, and is essential here so that the streaming output from cf logs makes its way all the way through the pipeline to the end (data would normally be buffered more for performance reasons, but we don't want that here, we want each line to be sent as it arrives).</p><p>Now we pipe (|) the lines found by the grep command into the following:</p><pre class="language-shell"><code class="language-shell">stdbuf <span class="token parameter variable">-oL</span> <span class="token function">cut</span> <span class="token parameter variable">-d</span> <span class="token string">' '</span> <span class="token parameter variable">-f</span> <span class="token number">7</span>-</code></pre><p>This is actually two commands. The first is <a href="https://linux.die.net/man/1/stdbuf">stdbuf</a>, which gives us the ability to control STDIO stream buffering for other commands, in this case for the command that follows it, i.e. <a href="https://en.wikipedia.org/wiki/Cut_(Unix)">cut</a>. The option -oL sets the standard output stream (STDOUT) buffering to line level buffering, the same as what --line-buffered did for grep.</p><p>We've seen the use of <a href="https://en.wikipedia.org/wiki/Cut_(Unix)">cut</a> in the previous Terminal Tip; here, we're saying, with the -d ' ' option, that the delimiter (separator) upon which cut should base its slicing, is a space character. And then, given that we're separating on spaces, with the -f 7- option, we're saying that we want the seventh and subsequent fields, all the way to the end. The effect of this is that we'll just get the JSON output. If you're wondering about why the value 7 is required, look at the raw log output and how untidy it is:</p><pre class="language-log"><code class="language-log"><span class="token date number">2020-04-14T</span><span class="token time number">08:15:21.60+0100</span> <span class="token punctuation">[</span>APP<span class="token operator">/</span>PROC<span class="token operator">/</span>WEB<span class="token operator">/</span><span class="token number">0</span><span class="token punctuation">]</span> OUT <span class="token operator">{</span><span class="token string">"written_at"</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span></code></pre><p>There are actually three spaces at the start of the log line, meaning that this part:</p><pre class="language-log"><code class="language-log"><span class="token operator">{</span><span class="token string">"written_at"</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span></code></pre><p>will be the seventh field, when separated by spaces.</p><p>Now we have the JSON only, we can pass it into our friend <a href="https://stedolan.github.io/jq/">jq</a>, the command line JSON processor:</p><pre class="language-shell"><code class="language-shell">jq <span class="token parameter variable">-r</span> <span class="token string">'.written_at + " " + .msg'</span></code></pre><p>Here we request just the value of the 'written_at' and 'msg' properties, separated by a space. The -r option gets jq to give us raw (i.e. unformatted) output.</p><p>Putting this altogether into the 'lintlogs' function, I can now monitor apps in CF more comfortably. Here's what the same log lines look like now when we pipe the output of cf logs desttest into the lintlogs function:</p><p><img src="/images/2020/04/Screenshot-2020-04-14-at-08.01.21.png" alt=""></p><p>Much better, no?</p><p>You can see the definition and use of this function, and its inaugural naming, in the <a href="https://bit.ly/handsonsapdev#ep63">#HandsOnSAPDev live stream episode 63</a> &quot;Tracing the OAuth 2.0 Authorisation Code grant type with approuter and CF&quot;.</p><p>Share &amp; enjoy, and remember, <a href="https://twitter.com/search?q=%23TheFutureIsTerminal&amp;src=typed_query">#TheFutureIsTerminal</a>!</p><hr><p><a href="https://community.sap.com/t5/technology-blogs-by-sap/terminal-tip-parsing-cf-app-logs/ba-p/13436028">Originally published on SAP Community</a></p></main><aside class="post__aside"><div class="post__tags"><a href="/tags/sapcommunity/">#sapcommunity</a> <a href="/tags/terminal/">#terminal</a> <a href="/tags/terminaltip/">#terminaltip</a></div><style>.utterances {
  margin-left: inherit !important;
}</style><script src="https://utteranc.es/client.js" repo="qmacro/qmacro.github.io" issue-term="title" crossorigin="anonymous" async></script><nav class="post__pagination"><a href="/blog/posts/2020/04/23/terminal-tip:-switching-cf-targets/"><span>←</span> <span>Terminal Tip: switching CF targets</span> </a><a href="/blog/posts/2020/04/07/terminal-tip:-truncating-cf-output/"><span>Terminal Tip: truncating CF output</span> <span>→</span></a></nav></aside></article></main><footer class="footer"><div class="footer__content"><ul class="hero__social-links"><li><a rel="me" href="https://github.com/qmacro" target="_blank" rel="noopener noreferrer">GitHub</a></li><li><a rel="me" href="https://www.youtube.com/djadams-qmacro" target="_blank" rel="noopener noreferrer">YouTube</a></li><li><a rel="me" href="https://www.linkedin.com/in/djadams/" target="_blank" rel="noopener noreferrer">LinkedIn</a></li><li><a rel="me" href="/tweets/">Tweet Archive</a></li><li><a rel="me" href="https://hachyderm.io/@qmacro" target="_blank" rel="noopener noreferrer">Mastodon</a></li><li><a rel="me" href="https://bsky.app/profile/qmacro.org" target="_blank" rel="noopener noreferrer">Bluesky</a></li><li><a href="/feed.xml" target="_blank" rel="noopener noreferrer">RSS</a></li></ul></div></footer></div><script src="/assets/main.31d6cfe0d16ae931b73c.js"></script></body></html>