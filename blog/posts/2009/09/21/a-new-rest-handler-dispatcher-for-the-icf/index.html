<!doctype html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="canonical" href="https://qmacro.org/blog/posts/2009/09/21/a-new-rest-handler-dispatcher-for-the-icf/"><link rel="alternate" type="application/atom+xml" title="DJ's Weblog - Feed" href="https://qmacro.org/feed.xml"><link href="/assets/main.7884d8f8e9dd86c3b137.css" rel="stylesheet"><link rel="preconnect" href="https://fonts.gstatic.com"><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans&display=swap" rel="stylesheet"><title>A new REST handler / dispatcher for the ICF | DJ Adams</title><link rel="icon" type="“image/x-icon”" href="/images/favicon.ico"><meta property="og:title" content="A new REST handler / dispatcher for the ICF"><meta property="og:site_name" content="DJ Adams"><meta property="og:type" content="website"><meta property="og:url" content="https://qmacro.org/blog/posts/2009/09/21/a-new-rest-handler-dispatcher-for-the-icf/"><meta name="description" content="A new REST handler / dispatcher for the ICF 21 Sep 2009 | 4 min read One of the best underlying mechanisms to be introduced into the Basis /..."><meta property="og:description" content="A new REST handler / dispatcher for the ICF 21 Sep 2009 | 4 min read One of the best underlying mechanisms to be introduced into the Basis /..."><meta name="description" content="A new REST handler / dispatcher for the ICF 21 Sep 2009 | 4 min read One of the best underlying mechanisms to be introduced into the Basis /..."><meta property="og:image" content="https://qmacro.org/images/site-image.png"><script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script><script>mermaid.initialize({startOnLoad:true});</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-4WQKBG0L4Y"></script><script>window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-4WQKBG0L4Y');</script></head><body><div class="layout-wrapper"><header class="header"><div class="header__content"><h1 class="site-title"><a href="/">DJ Adams</a></h1><nav class="nav"><ul class="nav__list"><li class="nav-item"><a href="/about">About Me</a></li><li class="nav-item"><a href="/blog">Blog</a></li><li class="nav-item"><a href="/feed.xml">Feed</a></li></ul></nav></div></header><main class="main"><article class="post"><header class="post__header"><h1>A new REST handler / dispatcher for the ICF</h1><div class="post__details"><time datetime="2009-09-21">21 Sep 2009 </time><span>| </span><span>4 min read</span></div></header><main class="post__content"><p>One of the best underlying mechanisms to be introduced into the Basis / NetWeaver stack in the past few years is the Internet Communication Framework (ICF), which is a collection of configuration, interfaces, classes and a core set of processes that allow us to build HTTP applications directly inside SAP.</p><p>If you're not directly familiar with the ICF, allow me to paraphrase a part of Tim O'Reilly's <a href="https://www.oreilly.com/pub/a/tim/articles/paradigmshift_0504.html">Open Source Paradigm Shift</a>, where he gets audiences to realise that they all use Linux, by asking them whether they've used Google, and so on. If you've used WebDynpro, BSPs, the embedded ITS, SOAP, Web Services, or any number of other similar services, you've used the ICF, the layer that sits underneath and powers these subsystems.</p><p>One of my <a href="/tags/rest/">passions</a> is <a href="http://en.wikipedia.org/wiki/Representational_State_Transfer">REpresentational State Transfer (REST)</a>, the architectural approach to the development of web services in the Resource Orientated Architecture (ROA) style, using HTTP for what it is – an application protocol. While the ICF lends itself very well to programming HTTP applications in general, I have found myself wanting to be able to develop web applications and services that not only follow the REST style, but also in a way that is more aligned with other web programming environments I work with.</p><p>An example of one of these environments is the one used in Google's <a href="http://code.google.com/appengine/">App Engine</a>. App Engine is a cloud-based service that offers the ability to build and host web applications on Google's infrastructure. In the Python flavour of Google's App Engine, the <a href="https://web.archive.org/web/20071012165155/http://pythonpaste.org/webob/">WebOb</a> library, an interface for HTTP requests and responses, is used as part of App Engine's <a href="http://code.google.com/appengine/docs/python/tools/webapp/">web application framework</a>.</p><p>Generally (and in an oversimplified way!), in the WebOb-style programming paradigm, you define a set of patterns matching various URLs in your application's &quot;url space&quot; (usually the root), and for each of the patterns, specify a handler class that is to be invoked to handle a request for the URL matched. When a match is found, the handler method invoked corresponds to the HTTP method in the request, and any subpattern values captured in the match are passed in the invocation.</p><p>So for instance, if the incoming request were:</p><pre class="language-text"><code class="language-text">GET /channel/100234/subscriber/91/</code></pre><p>and there was a pattern/handler class pair defined thus:</p><pre class="language-python"><code class="language-python"><span class="token string">'^/channel/([^/]+)/subscriber/([^/]+)/$'</span><span class="token punctuation">,</span> ChannelSubscriber</code></pre><p>then the URL would be matched, an object of class ChannelSubscriber instantiated, the method GET of that class invoked, and the values ‘100234' and '91' passed in the invocation. The GET method would read the HTTP request, prepare the HTTP response, and hand off when done.</p><p>For a real-world example, see <a href="http://github.com/qmacro/coffeeshop/blob/master/coffeeshop.py">coffeeshop.py</a> (part of my <a href="https://github.com/qmacro/coffeeshop">REST-orientated, HTTP-based publish/subscribe (pubsub) mechanism</a>), in particular from line 524 onward. You can see how this model follows the paradigm described above.</p><pre class="language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span><br>  application <span class="token operator">=</span> webapp<span class="token punctuation">.</span>WSGIApplication<span class="token punctuation">(</span><span class="token punctuation">[</span><br>    <span class="token punctuation">(</span><span class="token string">r'/'</span><span class="token punctuation">,</span>                                MainPageHandler<span class="token punctuation">)</span><span class="token punctuation">,</span><br>    <span class="token punctuation">(</span><span class="token string">r'/channel/submissionform/?'</span><span class="token punctuation">,</span>        ChannelSubmissionformHandler<span class="token punctuation">)</span><span class="token punctuation">,</span><br>    <span class="token punctuation">(</span><span class="token string">r'/channel/(.+?)/subscriber/(.+?)/'</span><span class="token punctuation">,</span> ChannelSubscriberHandler<span class="token punctuation">)</span><span class="token punctuation">,</span><br>    <span class="token punctuation">(</span><span class="token string">r'/message/'</span><span class="token punctuation">,</span>                        MessageHandler<span class="token punctuation">)</span><span class="token punctuation">,</span><br>    <span class="token punctuation">(</span><span class="token string">r'/distributor/(.+?)'</span><span class="token punctuation">,</span>               DistributorWorker<span class="token punctuation">)</span><span class="token punctuation">,</span><br>    <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">]</span><br>  <span class="token punctuation">]</span><span class="token punctuation">,</span> debug<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><br>  wsgiref<span class="token punctuation">.</span>handlers<span class="token punctuation">.</span>CGIHandler<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>run<span class="token punctuation">(</span>application<span class="token punctuation">)</span></code></pre><p>This model is absolutely great in helping you think about your application in REST terms. What it does is help you focus on a couple of the core entities in any proper web application or service — the <strong>nouns</strong> and the <strong>verbs</strong>. In other words, the URLs, and the HTTP methods. The framework allows you to control and handle incoming requests in a URL-and-method orientated fashion, and leaves you to concentrate on actually fulfilling the requests and forming the responses.</p><p>So where does this bring us? Well, while I'm a huge fan of the ICF, it does have a few shortcomings from a REST point of view, so I built a new generic handler / dispatcher class that I can use at any given node in the ICF tree, in the same style as WebOb. Put simply, it allows me to write an ICF node handler as simple as <a href="https://gist.github.com/qmacro/189000">this</a>:</p><pre class="language-text"><code class="language-text">method IF_HTTP_EXTENSION~HANDLE_REQUEST.<br>  handler( p = '^/$'                                          h = 'Y_COF_H_MAINPAGE' ).<br>  handler( p = '^/channel/submissionform$'                    h = 'Y_COF_H_CHANSUBMITFORM' ).<br>  handler( p = '^/channel/([^/]+)/subscriber/submissionform$' h = 'Y_COF_H_CHNSUBSUBMITFORM' ).<br>  handler( p = '^/channel/([^/]+)/subscriber/$'               h = 'Y_COF_H_CHNSUBCNT' ).<br>  handler( p = '^/channel/([^/]+)/subscriber/([^/]+)/$'       h = 'Y_COF_H_CHNSUB' ).<br>  dispatch( server ).<br>endmethod.</code></pre><p>The handler / dispatcher consists of a generic class that implements interface IF_HTTP_EXTENSION (as all ICF handlers must), and provides a set of attributes and methods that allow you, in subclassing this generic class, to write handler code in the above style. Here's the method tab of Y_DISP_COFFEESHOP, to give you a feel for how it fits together:</p><p><img src="/images/2009/09/y_disp_coffeeshop_methodtab_97688.png" alt="Method tab of Y_DISP_COFFEESHOP"></p><p>The classes that are invoked (Y_COF_H_* in this example) all inherit from a generic request handler class which provides a set of attributes and methods that allow you to get down to the business of simply providing GET, POST, PUT and other methods to handle the actual HTTP requests.</p><p>Here's an example of the method list of one of the request handler classes:</p><p><img src="/images/2009/09/y_cof_h_chnsub_97689.png" alt="Method list of Y_COF_H_CHNSUB"></p><p>One interesting advantage, arguably a side-effect of this approach, is that you can use nodes in the ICF tree to ‘root' your various web applications and services more cleanly, and avoid the difficulties of having different handlers defined at different levels in the child hierarchy just to service various parts of your application's particular url space.</p><p>I'd like to end this weblog post with a diagram that hopefully shows what I've been describing:</p><p><img src="/images/2009/09/diagram_97690.png" alt="diagram"></p><p>If you're interested in learning more, or sharing code, please let me know. I'm using this for real in one of my projects, but it's still early days.</p><p>For more information on the coffeeshop mechanism, checkout the videos in this playlist:</p><p><a href="https://www.youtube.com/playlist?list=PLfctWmgNyOIcbRYRdPrbjN_ZM56Kc5YTL"><img src="/images/2009/09/Ehdcd1HWkAA60Zi-1.jpeg" alt="Screenshot from video"></a></p><p><em>Update 01/05/2012 I've re-added images to this post that were lost when SDN went through the migration to the new platform. This project is now called ADL – Alternative Dispatcher Layer and is on the SAP Code Exchange here: https://cw.sdn.sap.com/cw/groups/adl</em></p><p><em>Update 09/09/2020 Added a link to the coffeeshop playlist</em></p><p><a href="https://blogs.sap.com/2009/09/21/a-new-rest-handler-dispatcher-for-the-icf/">Originally published on SAP Community</a></p></main><aside class="post__aside"><div class="post__tags"><a href="/tags/sapcommunity/">#sapcommunity</a></div><style>.utterances {
  margin-left: inherit !important;
}</style><script src="https://utteranc.es/client.js" repo="qmacro/qmacro.github.io" issue-term="title" crossorigin="anonymous" async></script><nav class="post__pagination"><a href="/blog/posts/2009/09/30/rest-orientation-controlling-access-to-resources/"><span>←</span> <span>REST orientation - Controlling access to resources</span> </a><a href="/blog/posts/2009/09/09/mainframes-and-the-cloud-everything-old-is-new-again/"><span>Mainframes and the cloud - everything old is new again</span> <span>→</span></a></nav></aside></article></main><footer class="footer"><div class="footer__content"><ul class="hero__social-links"><li><a rel="me" href="https://github.com/qmacro" target="_blank" rel="noopener noreferrer">GitHub</a></li><li><a rel="me" href="https://www.youtube.com/djadams-qmacro" target="_blank" rel="noopener noreferrer">YouTube</a></li><li><a rel="me" href="https://www.linkedin.com/in/djadams/" target="_blank" rel="noopener noreferrer">LinkedIn</a></li><li><a rel="me" href="https://hachyderm.io/@qmacro" target="_blank" rel="noopener noreferrer">Mastodon</a></li><li><a rel="me" href="https://bsky.app/profile/qmacro.bsky.social" target="_blank" rel="noopener noreferrer">Bluesky</a></li><li><a href="/feed.xml" target="_blank" rel="noopener noreferrer">RSS</a></li></ul></div></footer></div><script src="/assets/main.31d6cfe0d16ae931b73c.js"></script></body></html>