<!doctype html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="canonical" href="https://qmacro.org/blog/posts/2009/09/30/rest-orientation-controlling-access-to-resources/"><link rel="alternate" type="application/atom+xml" title="DJ's Weblog - Feed" href="https://qmacro.org/feed.xml"><link href="/assets/main.7884d8f8e9dd86c3b137.css" rel="stylesheet"><link rel="preconnect" href="https://fonts.gstatic.com"><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans&display=swap" rel="stylesheet"><title>REST orientation - Controlling access to resources | DJ Adams</title><link rel="icon" type="“image/x-icon”" href="/images/favicon.ico"><meta property="og:title" content="REST orientation - Controlling access to resources"><meta property="og:site_name" content="DJ Adams"><meta property="og:type" content="website"><meta property="og:url" content="https://qmacro.org/blog/posts/2009/09/30/rest-orientation-controlling-access-to-resources/"><meta name="description" content="REST orientation - Controlling access to resources 30 Sep 2009 | 7 min read Background Using my new REST handler / dispatcher for the ICF, I..."><meta property="og:description" content="REST orientation - Controlling access to resources 30 Sep 2009 | 7 min read Background Using my new REST handler / dispatcher for the ICF, I..."><meta name="description" content="REST orientation - Controlling access to resources 30 Sep 2009 | 7 min read Background Using my new REST handler / dispatcher for the ICF, I..."><meta property="og:image" content="https://qmacro.org/images/site-image.png"><script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script><script>mermaid.initialize({startOnLoad:true});</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-4WQKBG0L4Y"></script><script>window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-4WQKBG0L4Y');</script></head><body><div class="layout-wrapper"><header class="header"><div class="header__content"><h1 class="site-title"><a href="/">DJ Adams</a></h1><nav class="nav"><ul class="nav__list"><li class="nav-item"><a href="/about">About Me</a></li><li class="nav-item"><a href="/blog">Blog</a></li><li class="nav-item"><a href="/feed.xml">Feed</a></li></ul></nav></div></header><main class="main"><article class="post"><header class="post__header"><h1>REST orientation - Controlling access to resources</h1><div class="post__details"><time datetime="2009-09-30">30 Sep 2009 </time><span>| </span><span>7 min read</span></div></header><main class="post__content"><h2>Background</h2><p>Using my <a href="/blog/posts/2009/09/21/a-new-rest-handler-dispatcher-for-the-icf/">new REST handler / dispatcher for the ICF</a>, I can adopt a Resource Orientated Architecture (ROA) approach to integration. This gives me huge advantages, in that I can avoid complexity, and expose data and functions from SAP as resources - first class citizens on the web. From here, I can, amongst other things:</p><ul><li>use off-the-shelf cacheing mechanisms to improve performance</li><li>easily debug and trace integration with standard logging and proxying tools</li><li>even make statements about the resources using RDF</li></ul><p>Moreover, I can easily divide up the programming tasks and the logic into logical chunks, based upon resource, and HTTP method, and let the infrastructure handle what gets called, and when.</p><p>This is all because what we're dealing with in a REST-orientated approach is a set of resources - the nouns - which we manipulate with HTTP methods - the verbs.</p><p>As an example, here's a few of the channel-related resources that are relevant in my Coffeeshop project; in particular, my implementation of Coffeeshop in SAP. The resource URLs are relative, and rooted in the /qmacro/coffeeshop node of the ICF tree.</p><table><thead><tr><th>Resource</th><th>Description</th><th>Method</th><th>Action</th></tr></thead><tbody><tr><td>/qmacro/coffeeshop/</td><td>Homepage</td><td>GET</td><td>Returns the Coffeeshop 'homepage'</td></tr><tr><td>/qmacro/coffeeshop/channel/</td><td>Channel container</td><td>GET</td><td>Return list of channels</td></tr><tr><td>POST</td><td>Create new channel</td><td></td><td></td></tr><tr><td>/qmacro/coffeeshop/channel/123/</td><td>Channel</td><td>GET</td><td>Return information about the channel</td></tr><tr><td>POST</td><td>Publish a message to the channel</td><td></td><td></td></tr><tr><td>DELETE</td><td>Remove the channel</td><td></td><td></td></tr></tbody></table><p>(For more info on these and more resources, see the <a href="https://github.com/qmacro/coffeeshop/">Coffeeshop</a> repository.)</p><h2>Problem</h2><p>This is all fine, but often a degree of access control is required. What if we want to allow certain groups access to a certain resources, other groups to another set of resources, but only allow that group, say, to be able to read channel information, and not create any new channels? In other words, how do we control access following a resource orientated approach - access dependent upon the noun, and the verb?</p><p>Perhaps we would like group A to have GET access to all channel resources (read-only administration), group B to have GET and POST access to a particular channel (simple publisher access) and group C to have POST access to the channel container and DELETE access to individual channels (read/write administration)?</p><h2>What does SAP standard offer?</h2><p>Before looking at building something from scratch, what does standard SAP offer in the ICF area to support access control?</p><p>When you define a node in the ICF tree, you can specify access control relating to the userid in the Logon Data tab:</p><p>(image lost in early SAP community platform migration)</p><p>This is great first step. It means that we can control, on a high level, who gets access generally, and who doesn't. Let's call this 'Level 1 access'.</p><p>You can also specify, in the Service Data tab, a value for the SAP Authorisation field ('SAP Authoriz.'):</p><p>(image lost in early SAP community platform migration)</p><p>The value specified here is checked against authorisation object S_ICF, in the ICF_VALUE field, along with 'SERVICE' in the ICF_FIELD field.</p><pre class="language-swift"><code class="language-swift"><span class="token punctuation">[</span><span class="token class-name">O</span><span class="token punctuation">]</span> <span class="token constant">S_ICF</span><br> <span class="token operator">|</span><br> <span class="token operator">+--</span> <span class="token constant">ICF_FIELD</span><br> <span class="token operator">+--</span> <span class="token constant">ICF_VALUE</span></code></pre><p>This is clearly a 'service orientated' approach, and is at best a very blunt mechanism with which to control access.</p><p>As well as being blunt, it is also unfortunately violent. If the user that's been authenticated does have an authorisation with appropriate values for this authorisation object, then the authorisation check passes, and nothing more is said. But if the authenticated user doesn't have authorisation, the ICF returns HTTP status code '500', which implies an Internal Server Error. Extreme, and semantically incorrect - there hasn't been an error, the user just doesn't have authorisation. So, violent, and rather brutal. Then again, service orientation was never about elegance :-).</p><h2>What's our approach, then?</h2><p>Clearly, what the SAP standard offers in the ICF is not appropriate for a REST approach to integration design. (To be fair, it was never designed with resource orientation in mind).</p><p>What we would like is a three-level approach to access control:</p><p><strong>Level 1 - user authentication</strong>: Can the user be authenticated, generally? If not, the HTTP response should be status <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.2">401</a> - Unauthorised. This level is taken care of nicely by the ICF itself. Thanks, ICF!</p><p><strong>Level 2 - general resource access</strong>: Does the user have access, generally, to the specific resource? If not, the HTTP response should be status <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.4">403</a> - Forbidden.</p><p><strong>Level 3 - specific resource access</strong>: Is the user allowed to perform the HTTP method specified on that resource? If not, the HTTP response should be status <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.6">405</a> - Method Not Allowed. As well as this status code, the response must contain an Allow header, telling the caller what methods are allowed.</p><p>This will give us an ability to implement a fine-grained access control, allowing us to set up, say, group access, as described earlier.</p><h2>How do we get there?</h2><p>Clearly, we're not going to achieve what we want with the SAP standard. We'll have to construct our own mechanism to give us Levels 2 and 3. But, SAP standard does offer us a couple of great building blocks that we'll use.</p><h3>Building block: Authorisation Concept</h3><p>Why re-invent an authorisation concept, when we have such a good one as standard? Exactly. So we'll use the standard SAP authorisation concept.</p><p>So we'll create an authorisation object, YRESTAUTH, with two fields - one for the method, and one for the (relative) resource. This is what it looks like:</p><pre class="language-swift"><code class="language-swift"><span class="token punctuation">[</span><span class="token class-name">O</span><span class="token punctuation">]</span> <span class="token constant">YRESTAUTH</span><br> <span class="token operator">|</span><br> <span class="token operator">+--</span> <span class="token constant">YMETHOD</span> <span class="token constant">HTTP</span> method<br> <span class="token operator">+--</span> <span class="token constant">YRESOURCE</span> <span class="token function">resource</span> <span class="token punctuation">(</span>relative <span class="token constant">URL</span><span class="token punctuation">)</span></code></pre><p>We can then maintain as many combinations of verbs and nouns as we like, and manage &amp; assign those combinations using standard SAP authorisation concept tools. Heck, we could even farm that work out to the appropriate security team! Then, when it comes to the crunch, and the ICF is handling an incoming HTTP request, our mechanism can perform authorisation checks on this new authorisation object for the authenticated user associated with the request.</p><h3>Building block: Stacked Handlers</h3><p>One of the most fantastic things about the generally excellent ICF is the ability to have a whole stack of handlers, that are called in a controlled fashion by the ICF infrastructure, to respond to an incoming HTTP request. The model follows that of Apache and mod_perl, with flow control allowing any given handler to say whether, for example, it has responded completely and no further handlers should be called to satisfy the request, or that it has partially or not at all been able to respond, and that other handlers should be called.</p><p>So for any particular ICF node that we want to have this granular 3-level access control, what we need is a pluggable handler that we can insert in the first position of the handler stack, to deal with authorisation. Like this:</p><p>(image lost in early SAP community platform migration)</p><p>As you can see, we have the main coffeeshop handler, and before that in the stack, another handler, Y_AUTH, to provide the Levels 2 and 3 access control. So when an HTTP request comes in and the ICF determines that it's this node ([/default_host]/qmacro/coffeeshop) that should take care of the request, it calls Y_AUTH first.</p><p>Y_AUTH is a handler class just like any other HTTP handler class, and implements interface IF_HTTP_EXTENSION. It starts out with a few data definitions, and identifies the resource specified in the request:</p><pre class="language-swift"><code class="language-swift">method <span class="token constant">IF_HTTP_EXTENSION</span><span class="token operator">~</span><span class="token constant">HANDLE_REQUEST</span><span class="token punctuation">.</span><br>  data<span class="token punctuation">:</span><br>      l_method     type string<br>    <span class="token punctuation">,</span> l_is_allowed type abap_bool<br>    <span class="token punctuation">,</span> lt_allowed   type stringtab<br>    <span class="token punctuation">,</span> l_resource   type string<br>    <span class="token punctuation">,</span> l_resource_c type text255<br>    <span class="token punctuation">,</span> l_allowed    type string<br>    <span class="token punctuation">.</span><br><span class="token operator">*</span> <span class="token class-name">What</span>'s the resource<span class="token operator">?</span><br>  l_resource <span class="token operator">=</span> server<span class="token operator">-></span>request<span class="token operator">-></span><span class="token function">get_header_field</span><span class="token punctuation">(</span> '<span class="token operator">~</span>request_uri' <span class="token punctuation">)</span><span class="token punctuation">.</span><br><span class="token operator">*</span> <span class="token class-name">Need</span> char version <span class="token keyword">for</span> authority check<br>  l_resource_c <span class="token operator">=</span> l_resource<span class="token punctuation">.</span></code></pre><p>Then it performs the Level 2 access check - is the user authorised generally for the resource?</p><pre class="language-swift"><code class="language-swift"><span class="token operator">*</span> <span class="token class-name">Level</span> <span class="token number">2</span> check <span class="token operator">-</span> general access to that resource<span class="token operator">?</span><br>  authority<span class="token operator">-</span>check object '<span class="token constant">YRESTAUTH</span>'<br>    id '<span class="token constant">YMETHOD</span>'   dummy<br>    id '<span class="token constant">YRESOURCE</span>' field l_resource_c<span class="token punctuation">.</span><br>  <span class="token keyword">if</span> sy<span class="token operator">-</span>subrc <span class="token operator">&lt;></span> <span class="token number">0</span><span class="token punctuation">.</span><br>    server<span class="token operator">-></span>response<span class="token operator">-></span><span class="token function">set_status</span><span class="token punctuation">(</span> code <span class="token operator">=</span> '<span class="token number">403</span>' reason <span class="token operator">=</span> '<span class="token constant">FORBIDDEN</span> <span class="token operator">-</span> <span class="token constant">NO</span> <span class="token constant">AUTH</span> <span class="token constant">FOR</span> <span class="token constant">RESOURCE</span>' <span class="token punctuation">)</span><span class="token punctuation">.</span><br>    exit<span class="token punctuation">.</span><br>  endif<span class="token punctuation">.</span></code></pre><p>If the authority check failed for that resource generally, we return a status 403 and that response is sent back to the client.</p><p>However, if the authority check succeeds, and we pass Level 2, it's time to check the specific combination of HTTP method and resource - the verb and the noun. We do this with a call to a simple method is_method_allowed() which takes the resource and method from the request, and returns a boolean, saying whether or not the method is allowed, plus a list of the methods that are actually allowed. Remember, in the HTTP response, we must return an Allow: header listing those methods if we're going to send a 405.</p><pre class="language-swift"><code class="language-swift"><span class="token operator">*</span> <span class="token class-name">Level</span> <span class="token number">3</span> check <span class="token operator">-</span> method<span class="token operator">-</span>specific access to that resource<span class="token operator">?</span><br>  l_method <span class="token operator">=</span>  server<span class="token operator">-></span>request<span class="token operator">-></span><span class="token function">get_header_field</span><span class="token punctuation">(</span> '<span class="token operator">~</span>request_method' <span class="token punctuation">)</span><span class="token punctuation">.</span><br>  translate l_method to upper <span class="token keyword">case</span><span class="token punctuation">.</span><br>  call method is_method_allowed<br>    exporting<br>      i_resource   <span class="token operator">=</span> l_resource<br>      i_method     <span class="token operator">=</span> l_method<br>    importing<br>      e_is_allowed <span class="token operator">=</span> l_is_allowed<br>      e_allowed    <span class="token operator">=</span> lt_allowed<span class="token punctuation">.</span><br><br><span class="token operator">*</span> <span class="token class-name">If</span> not allowed<span class="token punctuation">,</span> need to send back a response<br>  <span class="token keyword">if</span> l_is_allowed eq abap_false<span class="token punctuation">.</span><br><br>    concatenate lines of lt_allowed into l_allowed separated by '<span class="token punctuation">,</span>'<span class="token punctuation">.</span><br>    server<span class="token operator">-></span>response<span class="token operator">-></span><span class="token function">set_status</span><span class="token punctuation">(</span> code <span class="token operator">=</span> '<span class="token number">405</span>' reason <span class="token operator">=</span> '<span class="token constant">METHOD</span> <span class="token constant">NOT</span> <span class="token constant">ALLOWED</span> <span class="token constant">FOR</span> <span class="token constant">RESOURCE</span>' <span class="token punctuation">)</span><span class="token punctuation">.</span><br>    server<span class="token operator">-></span>response<span class="token operator">-></span><span class="token function">set_header_field</span><span class="token punctuation">(</span> name <span class="token operator">=</span> '<span class="token class-name">Allow</span>' value <span class="token operator">=</span> l_allowed <span class="token punctuation">)</span><span class="token punctuation">.</span></code></pre><p>So we send a 405 with an Allow: header if the user doesn't have authorisation for that specific combination of HTTP method and resource. (The is_method_allowed() works by taking a given list of HTTP methods, and authority-checking each one in combination with the resource, noting which were allowed, and which weren't.)</p><p>Finally, if we've successfully passed the Levels 2 and 3 checks, we can let go and have the ICF invoke the main handler for this ICF node - Y_DISP_COFFEESHOP. In order to make sure this happens, we tell the ICF, through the flow control variable IF_HTTP_EXTENSION~FLOW_RC, that while our execution has been OK, we still need to have a further handler executed to satisfy the request completely:</p><pre class="language-swift"><code class="language-swift"><span class="token operator">*</span> <span class="token class-name">Otherwise</span><span class="token punctuation">,</span> we're golden<span class="token punctuation">,</span> but make sure another handler executes<br>  <span class="token keyword">else</span><span class="token punctuation">.</span><br>    if_http_extension<span class="token operator">~</span>flow_rc <span class="token operator">=</span> if_http_extension<span class="token operator">~</span>co_flow_ok_others_mand<span class="token punctuation">.</span><br><br>  endif<span class="token punctuation">.</span><br><br>endmethod<span class="token punctuation">.</span></code></pre><p>And that's pretty much it!</p><p>To finish off, here are some examples of the results of this mechanism.</p><p>(image lost in early SAP community platform migration)</p><p>In the first call, the wrong password is specified in authentication, so the status in the HTTP response, directly from the ICF, is 401. This is Level 1.</p><p>In the second call, the user is authenticated ok, but doesn't have access generally to the /qmacro/coffeeshop/ resource, hence the 403 status. This is Level 2.</p><p>In the third call, we're trying to make a POST request to a specific channel resource. While we might have GET access to this resource, we don't specifically have POST access, so the status in the HTTP response is 405. In addition, a header like this: &quot;Allow: GET&quot; would have been returned in the response. This is Level 3.</p><p>I hope this shows that when implementing a REST approach to integration, you can control access to your resources in a very granular way, and respond in a symantically appropriate way, using HTTP as designed - as an application protocol.</p><p><a href="https://blogs.sap.com/2009/09/30/rest-orientation-controlling-access-to-resources/">Originally published on SAP Community</a></p></main><aside class="post__aside"><div class="post__tags"><a href="/tags/sapcommunity/">#sapcommunity</a></div><style>.utterances {
  margin-left: inherit !important;
}</style><script src="https://utteranc.es/client.js" repo="qmacro/qmacro.github.io" issue-term="title" crossorigin="anonymous" async></script><nav class="post__pagination"><a href="/blog/posts/2009/11/05/tech-skills-chat-with-jonerp-a-follow-on-story/"><span>←</span> <span>Tech Skills Chat with JonERP - A Follow-on Story</span> </a><a href="/blog/posts/2009/09/21/a-new-rest-handler-dispatcher-for-the-icf/"><span>A new REST handler / dispatcher for the ICF</span> <span>→</span></a></nav></aside></article></main><footer class="footer"><div class="footer__content"><ul class="hero__social-links"><li><a rel="me" href="https://github.com/qmacro" target="_blank" rel="noopener noreferrer">GitHub</a></li><li><a rel="me" href="https://www.youtube.com/djadams-qmacro" target="_blank" rel="noopener noreferrer">YouTube</a></li><li><a rel="me" href="https://www.linkedin.com/in/djadams/" target="_blank" rel="noopener noreferrer">LinkedIn</a></li><li><a rel="me" href="/tweets">Tweet Archive</a></li><li><a rel="me" href="https://hachyderm.io/@qmacro" target="_blank" rel="noopener noreferrer">Mastodon</a></li><li><a rel="me" href="https://bsky.app/profile/qmacro.bsky.social" target="_blank" rel="noopener noreferrer">Bluesky</a></li><li><a href="/feed.xml" target="_blank" rel="noopener noreferrer">RSS</a></li></ul></div></footer></div><script src="/assets/main.31d6cfe0d16ae931b73c.js"></script></body></html>