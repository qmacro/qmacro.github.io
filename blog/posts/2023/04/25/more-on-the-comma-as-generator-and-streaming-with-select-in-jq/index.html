<!doctype html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="canonical" href="https://qmacro.org/blog/posts/2023/04/25/more-on-the-comma-as-generator-and-streaming-with-select-in-jq/"><link rel="alternate" type="application/atom+xml" title="DJ's Weblog - Feed" href="https://qmacro.org/feed.xml"><link href="/assets/main.7884d8f8e9dd86c3b137.css" rel="stylesheet"><link rel="preconnect" href="https://fonts.gstatic.com"><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans&display=swap" rel="stylesheet"><title>More on the comma as generator, and streaming with select in jq | DJ Adams</title><link rel="icon" type="“image/x-icon”" href="/images/favicon.ico"><meta property="og:title" content="More on the comma as generator, and streaming with select in jq"><meta property="og:site_name" content="DJ Adams"><meta property="og:type" content="website"><meta property="og:url" content="https://qmacro.org/blog/posts/2023/04/25/more-on-the-comma-as-generator-and-streaming-with-select-in-jq/"><meta name="description" content="More on the comma as generator, and streaming with select in jq 25 Apr 2023 | 3 min read In the context of writing a short jq script to turn..."><meta property="og:description" content="More on the comma as generator, and streaming with select in jq 25 Apr 2023 | 3 min read In the context of writing a short jq script to turn..."><meta name="description" content="More on the comma as generator, and streaming with select in jq 25 Apr 2023 | 3 min read In the context of writing a short jq script to turn..."><meta property="og:image" content="https://qmacro.org/images/site-image.png"><script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script><script>mermaid.initialize({startOnLoad:true});</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-4WQKBG0L4Y"></script><script>window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-4WQKBG0L4Y');</script></head><body><div class="layout-wrapper"><header class="header"><div class="header__content"><h1 class="site-title"><a href="/">DJ Adams</a></h1><nav class="nav"><ul class="nav__list"><li class="nav-item"><a href="/about">About Me</a></li><li class="nav-item"><a href="/blog">Blog</a></li><li class="nav-item"><a href="/feed.xml">Feed</a></li></ul></nav></div></header><main class="main"><article class="post"><header class="post__header"><h1>More on the comma as generator, and streaming with select in jq</h1><div class="post__details"><time datetime="2023-04-25">25 Apr 2023 </time><span>| </span><span>3 min read</span></div></header><main class="post__content"><p>In the context of writing a short jq script to turn a JSON representation of an OData entity set into a set of CSV records, I came across something in jq that reminded me of something I'd discovered recently, and made me think a bit more about it.</p><p>In the source data, each entity was represented by an object, but I only wanted to include properties whose value types were either strings, numbers or booleans. I ended up taking the simplest route to check, in an expression supplied to a call to <code>select</code>, using <a href="https://stedolan.github.io/jq/manual/#type">type</a> to check whether the type of a value was one of these.</p><p>What I found was another instance of the <a href="/blog/posts/2023/04/02/learning-from-community-solutions-on-exercism-part-2/#generators-and-streams-of-values">comma as generator</a> that I wrote about a couple of weeks ago in <a href="/blog/posts/2023/04/02/learning-from-community-solutions-on-exercism-part-2/">Learning from community solutions on Exercism - part 2</a>.</p><p>Moving away from the original source input, let's consider the simplest case where I want to pick out only numbers from a stream of values:</p><pre class="language-jq"><code class="language-jq"><span class="token number">42</span><span class="token punctuation">,</span> <span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token boolean">true</span> <span class="token operator pipe">|</span> <span class="token c-style-function function">select</span><span class="token punctuation">(</span>type <span class="token operator">==</span> <span class="token string">"number"</span><span class="token punctuation">)</span></code></pre><p>This produces:</p><pre class="language-json"><code class="language-json"><span class="token number">42</span></code></pre><p>So far so good. But what about picking out both numbers and strings? The simplest looking and perhaps idiomatic approach looks like this:</p><pre class="language-jq"><code class="language-jq"><span class="token number">42</span><span class="token punctuation">,</span> <span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token boolean">true</span> <span class="token operator pipe">|</span> <span class="token c-style-function function">select</span><span class="token punctuation">(</span>type <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token string">"number"</span><span class="token punctuation">,</span> <span class="token string">"string"</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>As one would expect, or at least hope, this produces:</p><pre class="language-json"><code class="language-json"><span class="token number">42</span><br><span class="token string">"hello"</span></code></pre><p>But what exactly is going on with <code>type == (&quot;number&quot;, &quot;string&quot;)</code>? Visually it's not too far from representing what we want. And in fact it's the same pattern as we saw in <code>&quot;car&quot; | . == (&quot;car&quot;, &quot;truck&quot;)</code> in <a href="/blog/posts/2023/04/02/learning-from-community-solutions-on-exercism-part-2/#generators-and-streams-of-values">that previous post</a>. Moreover, how does this actually work with <code>select</code>?</p><p>I'd noticed that <code>select</code> is <a href="https://github.com/stedolan/jq/blob/a9f97e9e61a910a374a5d768244e8ad63f407d3e/src/builtin.jq#L4">defined as a builtin in jq itself</a>:</p><pre class="language-jq"><code class="language-jq"><span class="token keyword">def</span> <span class="token function">select</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">if</span> f <span class="token keyword">then</span> <span class="token dot important">.</span> <span class="token keyword">else</span> empty <span class="token keyword">end</span><span class="token punctuation">;</span></code></pre><p>The jq manual says:</p><blockquote><p>The function <code>select(foo)</code> produces its input unchanged if <code>foo</code> returns true for that input, and produces no output otherwise.</p></blockquote><p>Before we try to use that, let's remove the <code>select</code> from the expression for a moment to see what we get:</p><pre class="language-jq"><code class="language-jq"><span class="token number">42</span><span class="token punctuation">,</span> <span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token boolean">true</span> <span class="token operator pipe">|</span> type <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token string">"number"</span><span class="token punctuation">,</span> <span class="token string">"string"</span><span class="token punctuation">)</span></code></pre><p>What we get is something that looks a little odd, at least at first:</p><pre class="language-json"><code class="language-json"><span class="token boolean">true</span><br><span class="token boolean">false</span><br><span class="token boolean">false</span><br><span class="token boolean">true</span><br><span class="token boolean">false</span><br><span class="token boolean">false</span></code></pre><p>How do we visually parse this? Well, it's two &quot;pairs&quot; of booleans, one pair for each of the input values <code>42</code>, <code>&quot;hello&quot;</code> and <code>true</code>, where each pair represents the result of comparing the type of the input value twice, with <code>&quot;number&quot;</code> and with <code>&quot;string&quot;</code>, in order. Splitting these pairs up with whitespace and adding some explanation, we get:</p><pre class="language-text"><code class="language-text">true     :-- is number \   42<br>false    :-- is string /<br><br>false    :-- is number \ "hello"<br>true     :-- is string /<br><br>false    :-- is number \  true<br>false    :-- is string /</code></pre><p>Then, reminding ourselves that the definition of <code>select</code> is:</p><pre class="language-jq"><code class="language-jq"><span class="token keyword">def</span> <span class="token function">select</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">if</span> f <span class="token keyword">then</span> <span class="token dot important">.</span> <span class="token keyword">else</span> empty <span class="token keyword">end</span><span class="token punctuation">;</span></code></pre><p>then the values that stream through to <code>select</code> are either emitted (<code>.</code>) if the condition evaluates to <code>true</code>, otherwise nothing is emitted (<code>empty</code>) if the condition evaluates to <code>false</code>.</p><p>This results in the following behaviour:</p><pre class="language-text"><code class="language-text">true     :-- is number \   42    / emitted       --:   42<br>false    :-- is string /         \ not emitted<br><br>false    :-- is number \ "hello" / not emitted<br>true     :-- is string /         \ emitted       --: "hello"<br><br>false    :-- is number \  true   / not emitted<br>false    :-- is string /         \ not emitted</code></pre><p>and thus:</p><pre class="language-json"><code class="language-json"><span class="token number">42</span><br><span class="token string">"hello"</span></code></pre><p>The fascinating thing is that if we were to have a duplicate entry (<code>&quot;number&quot;</code>) in the parentheses on the right hand side, like this:</p><pre class="language-jq"><code class="language-jq"><span class="token number">42</span><span class="token punctuation">,</span> <span class="token string">"hello"</span><span class="token punctuation">,</span> <span class="token boolean">true</span> <span class="token operator pipe">|</span> <span class="token c-style-function function">select</span><span class="token punctuation">(</span>type <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token string">"number"</span><span class="token punctuation">,</span> <span class="token string">"string"</span><span class="token punctuation">,</span> <span class="token string">"number"</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>then our result would be different, and probably not what we were expecting:</p><pre class="language-json"><code class="language-json"><span class="token number">42</span><br><span class="token number">42</span><br><span class="token string">"hello"</span></code></pre><p>But knowing what's going on allows us to understand why. There are now three values each being tested not twice but three times:</p><pre class="language-text"><code class="language-text">true     :-- is number \         / emitted       --:   42<br>false    :-- is string |   42    | not emitted<br>true     :-- is number /         \ emitted       --:   42<br><br>false    :-- is number \         / not emitted<br>true     :-- is string | "hello" | emitted       --: "hello"<br>false    :-- is number /         \ not emitted<br><br>false    :-- is number \         / not emitted<br>false    :-- is string |  true   | not emitted<br>false    :-- is number /         \ not emitted</code></pre><p>While the superficial operation of this jq expression is sort of obvious, why it works is less so. At least to me. And in case it wasn't obvious to you either, I hope this has helped!</p></main><aside class="post__aside"><div class="post__tags"><a href="/tags/jq/">#jq</a></div><style>.utterances {
  margin-left: inherit !important;
}</style><script src="https://utteranc.es/client.js" repo="qmacro/qmacro.github.io" issue-term="title" crossorigin="anonymous" async></script><nav class="post__pagination"><a href="/blog/posts/2023/04/27/improving-my-interactive-jq-workflow-with-ijq-bash-and-tmux/"><span>←</span> <span>Improving my interactive jq workflow with ijq, bash and tmux</span> </a><a href="/blog/posts/2023/04/16/double-sap-btp-goodness-in-isernhagen/"><span>Double SAP BTP goodness in Isernhagen</span> <span>→</span></a></nav></aside></article></main><footer class="footer"><div class="footer__content"><ul class="hero__social-links"><li><a rel="me" href="https://github.com/qmacro" target="_blank" rel="noopener noreferrer">GitHub</a></li><li><a rel="me" href="https://www.youtube.com/djadams-qmacro" target="_blank" rel="noopener noreferrer">YouTube</a></li><li><a rel="me" href="https://www.linkedin.com/in/djadams/" target="_blank" rel="noopener noreferrer">LinkedIn</a></li><li><a rel="me" href="/tweets/">Tweet Archive</a></li><li><a rel="me" href="https://hachyderm.io/@qmacro" target="_blank" rel="noopener noreferrer">Mastodon</a></li><li><a rel="me" href="https://bsky.app/profile/qmacro.bsky.social" target="_blank" rel="noopener noreferrer">Bluesky</a></li><li><a href="/feed.xml" target="_blank" rel="noopener noreferrer">RSS</a></li></ul></div></footer></div><script src="/assets/main.31d6cfe0d16ae931b73c.js"></script></body></html>