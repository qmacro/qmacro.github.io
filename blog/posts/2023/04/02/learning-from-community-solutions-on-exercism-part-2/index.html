<!doctype html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="canonical" href="https://qmacro.org/blog/posts/2023/04/02/learning-from-community-solutions-on-exercism-part-2/"><link rel="alternate" type="application/atom+xml" title="DJ's Weblog - Feed" href="https://qmacro.org/feed.xml"><link href="/assets/main.4654d4542dcb045c9ba3.css" rel="stylesheet"><link rel="preconnect" href="https://fonts.gstatic.com"><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans&display=swap" rel="stylesheet"><title>Learning from community solutions on Exercism - part 2 | DJ Adams</title><link rel="icon" type="“image/x-icon”" href="/images/favicon.ico"><meta property="og:title" content="Learning from community solutions on Exercism - part 2"><meta property="og:site_name" content="DJ Adams"><meta property="og:type" content="website"><meta property="og:url" content="https://qmacro.org/blog/posts/2023/04/02/learning-from-community-solutions-on-exercism-part-2/"><meta name="description" content="Learning from community solutions on Exercism - part 2 02 Apr 2023 | 8 min read In response to the first part of this series, in relation to..."><meta property="og:description" content="Learning from community solutions on Exercism - part 2 02 Apr 2023 | 8 min read In response to the first part of this series, in relation to..."><meta name="description" content="Learning from community solutions on Exercism - part 2 02 Apr 2023 | 8 min read In response to the first part of this series, in relation to..."><meta property="og:image" content="https://qmacro.org/images/site-image.png"><script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script><script>mermaid.initialize({startOnLoad:true});</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-4WQKBG0L4Y"></script><script>window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-4WQKBG0L4Y');</script></head><body><div class="layout-wrapper"><header class="header"><div class="header__content"><h1 class="site-title"><a href="/">DJ Adams</a></h1><nav class="nav"><ul class="nav__list"><li class="nav-item"><a href="/about">About Me</a></li><li class="nav-item"><a href="/talks">Talks</a></li><li class="nav-item"><a href="/blog">Blog</a></li><li class="nav-item"><a href="/feed.xml">Feed</a></li></ul></nav></div></header><main class="main"><article class="post"><header class="post__header"><h1>Learning from community solutions on Exercism - part 2</h1><div class="post__details"><time datetime="2023-04-02">02 Apr 2023 </time><span>| </span><span>8 min read</span></div></header><main class="post__content"><p>In response to the <a href="/blog/posts/2023/03/29/learning-from-community-solutions-on-exercism-part-1/">first part of this series</a>, in relation to the <a href="/blog/posts/2023/03/29/learning-from-community-solutions-on-exercism-part-1/#vehicle-purchase-exercise">rabbit hole in the Vehicle Purchase exercise</a>, Mattias Wadman <a href="https://fosstodon.org/@wader/110117608773689719">kindly shared some variants using generators</a>, which I'll reproduce here:</p><pre class="language-jq"><code class="language-jq"><span class="token keyword">def</span> <span class="token function">needs_license</span><span class="token punctuation">:</span> <br>  <span class="token c-style-function function">any</span><span class="token punctuation">(</span><span class="token dot important">.</span> <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token string">"car"</span><span class="token punctuation">,</span> <span class="token string">"truck"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token dot important">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class="language-jq"><code class="language-jq"><span class="token keyword">def</span> <span class="token function">needs_license</span><span class="token punctuation">:</span> <br>  <span class="token keyword">if</span> <span class="token dot important">.</span> <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token string">"car"</span><span class="token punctuation">,</span> <span class="token string">"truck"</span><span class="token punctuation">)</span> <span class="token keyword">then</span> <span class="token boolean">true</span> <span class="token keyword">else</span> empty <span class="token keyword">end</span> <span class="token operator">//</span> <span class="token boolean">false</span><span class="token punctuation">;</span></code></pre><pre class="language-jq"><code class="language-jq"><span class="token keyword">def</span> <span class="token function">needs_license</span><span class="token punctuation">:</span> <br>  <span class="token punctuation">(</span><span class="token dot important">.</span> <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token string">"car"</span><span class="token punctuation">,</span> <span class="token string">"truck"</span><span class="token punctuation">)</span> <span class="token operator pipe">|</span> <span class="token c-style-function function">select</span><span class="token punctuation">(</span><span class="token dot important">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token boolean">false</span><span class="token punctuation">;</span></code></pre><p>Each variant, when fed the same input, like this:</p><pre class="language-jq"><code class="language-jq"><span class="token string">"car"</span><span class="token punctuation">,</span> <span class="token string">"truck"</span><span class="token punctuation">,</span> <span class="token string">"bike"</span> <span class="token operator pipe">|</span> needs_license</code></pre><p>produces the same output, i.e.:</p><pre class="language-json"><code class="language-json"><span class="token boolean">true</span><br><span class="token boolean">true</span><br><span class="token boolean">false</span></code></pre><p>(It's worth pointing out before continuing that none of these variants will fall foul of the gotcha I discovered with <code>contains</code> / <code>inside</code>, so I can move on from testing whether <code>true</code> will be returned for <code>&quot;car&quot;</code> when the possible vehicles listed includes <code>&quot;cart&quot;</code> and put that behind us.)</p><p>In this post, I'll take a brief look at <a href="#generators-and-streams-of-values">generators</a>, and then look at each of these solutions in turn, i.e.</p><ul><li><a href="#the-any-based-function">the &quot;any&quot; based function</a></li><li><a href="#the-if-then-else-end-based-function">the &quot;if ... then ... else ... end&quot; based function</a></li><li><a href="#the-select-based-function">the &quot;select&quot; based function</a></li></ul><p><a name="generators-and-streams-of-values"></a></p><h2>Generators and streams of values</h2><p>There's a section that's common to each of these functions, and it's this:</p><pre class="language-jq"><code class="language-jq"><span class="token dot important">.</span> <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token string">"car"</span><span class="token punctuation">,</span> <span class="token string">"truck"</span><span class="token punctuation">)</span></code></pre><p>This struck me right between the eyes. Given the context that the value <code>.</code> would be a vehicle string e.g. <code>&quot;car&quot;</code>, I can't help but admit I was wondering what the heck was going on here. How can a string be sensibly compared with what looks like a list of strings?</p><p>So I decided to dig in, and am glad I did.</p><p>It becomes quickly clear that <code>(&quot;car&quot;, &quot;truck&quot;)</code> isn't a list in the sense I was thinking about. First, the <a href="https://stedolan.github.io/jq/manual/#Parenthesis">parentheses</a> are just for grouping, not for any literal list construction. So let's omit them for a second. In fact, let's reduce the expression to something simpler, to see what I get:</p><pre class="language-jq"><code class="language-jq"><span class="token string">"car"</span> <span class="token operator pipe">|</span> <span class="token dot important">.</span> <span class="token operator">==</span> <span class="token string">"car"</span><br><span class="token comment"># => true</span></code></pre><p>So far so good. But what happens when I add the <code>&quot;truck&quot;</code> value?</p><pre class="language-jq"><code class="language-jq"><span class="token string">"car"</span> <span class="token operator pipe">|</span> <span class="token dot important">.</span> <span class="token operator">==</span> <span class="token string">"car"</span><span class="token punctuation">,</span> <span class="token string">"truck"</span></code></pre><p>This gives us:</p><pre class="language-json"><code class="language-json"><span class="token boolean">true</span><br><span class="token string">"truck"</span></code></pre><p>The output is not a single JSON value, there are two, one from either side of the comma. And looking at the <a href="https://stedolan.github.io/jq/manual/#Generatorsanditerators">Generators and iterators</a> section of the jq manual, I discover that:</p><blockquote><p>Even the comma operator is a generator.</p></blockquote><p>What is a generator? Something that produces zero, one or more values. I've used <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators">iterators and generators in JavaScript</a>, and also <a href="https://wiki.python.org/moin/Generators">in Python</a>, so the concept is at least familiar to me.</p><p>What's happening here is that the comma is acting as a generator, producing (in this case) a value resulting from the expression on its left (<code>&quot;car&quot; | . == &quot;car&quot;)</code>, and a value resulting from the expression on its right (<code>&quot;truck&quot;</code>). This is also why the output is as it is, and not, say, <code>[true, &quot;truck&quot;]</code>; what's produced is not an array, but a stream of two discrete (and independently valid) JSON values.</p><p>And the difference between this and the version with the parentheses is becoming clearer now. What happens when I add them?</p><pre class="language-jq"><code class="language-jq"><span class="token string">"car"</span> <span class="token operator pipe">|</span> <span class="token dot important">.</span> <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token string">"car"</span><span class="token punctuation">,</span> <span class="token string">"truck"</span><span class="token punctuation">)</span></code></pre><p>The grouping that the <code>(...)</code> brings doesn't affect the generator nature of the comma, it just causes the <code>. ==</code> part of the expression to be applied to the group of strings (<code>&quot;car&quot;</code> and <code>&quot;truck&quot;</code>), one by one. So this results in:</p><pre class="language-json"><code class="language-json"><span class="token boolean">true</span><br><span class="token boolean">false</span></code></pre><p>In other words, it's the equivalent of:</p><pre class="language-jq"><code class="language-jq"><span class="token string">"car"</span> <span class="token operator pipe">|</span> <span class="token dot important">.</span> <span class="token operator">==</span> <span class="token string">"car"</span><span class="token punctuation">,</span> <span class="token dot important">.</span> <span class="token operator">==</span> <span class="token string">"truck"</span></code></pre><h3>More on comma as generator</h3><p>I wanted to dwell a little more on this comma-as-generator. Here are a couple of very simple examples:</p><pre class="language-jq"><code class="language-jq"><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span></code></pre><p>This, unsurprisingly, produces:</p><pre class="language-json"><code class="language-json"><span class="token number">1</span><br><span class="token number">2</span><br><span class="token number">3</span><br><span class="token number">4</span><br><span class="token number">5</span></code></pre><p>But I know know what's actually happening, and the stream of scalar JSON values is more obvious.</p><p>(This subtlety reminds me of another subtlety in LISP, where list construction can be done via the <code>list</code> function: <code>(list 1 2 3 4 5)</code> which produces <code>(1 2 3 4 5)</code>, or more explicitly using the <code>cons</code> function: <code>(cons 1 (cons 2 (cons 3 (cons 4 (cons 5 nil)))))</code> which also produces <code>(1 2 3 4 5)</code>. We're not constructing lists here, but there's a vaguely similar feeling in how things are constructed. But anyway, I digress.)</p><p>How about using functions either side of commas, functions that produce streams of values?</p><pre class="language-jq"><code class="language-jq"><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator pipe">|</span><span class="token c-style-function function">map</span><span class="token punctuation">(</span><span class="token dot important">.</span><span class="token operator">*</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token c-style-function function">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span></code></pre><p>This produces a stream of five individual JSON scalar values:</p><pre class="language-json"><code class="language-json"><span class="token number">10</span><br><span class="token number">20</span><br><span class="token number">0</span><br><span class="token number">1</span><br><span class="token number">2</span></code></pre><p>Note that the important part of the expression to the left of the comma in this example is the <a href="https://stedolan.github.io/jq/manual/#Array/ObjectValueIterator:.%5B%5D">array iterator</a>, i.e. the <code>[]</code> part. If we were to omit that:</p><pre class="language-jq"><code class="language-jq"><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator pipe">|</span><span class="token c-style-function function">map</span><span class="token punctuation">(</span><span class="token dot important">.</span><span class="token operator">*</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token c-style-function function">range</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span></code></pre><p>we'd get this:</p><pre class="language-json"><code class="language-json"><span class="token punctuation">[</span><br>  <span class="token number">10</span><span class="token punctuation">,</span><br>  <span class="token number">20</span><br><span class="token punctuation">]</span><br><span class="token number">0</span><br><span class="token number">1</span><br><span class="token number">2</span></code></pre><p>This is a stream of four JSON values, the array being the first one.</p><p><a name="the-any-based-function"></a></p><h2>The &quot;any&quot; based function</h2><p>In part 1 of this series, in looking at <a href="/blog/posts/2023/03/29/learning-from-community-solutions-on-exercism-part-1/#some-alternatives">some alternatives</a> for the Vehicle Purchase exercise, I noted that the <code>any</code> function can be used with 0, 1 or 2 parameters.</p><p>In Matthias's first function example, we see the <code>any/2</code> in use:</p><pre class="language-jq"><code class="language-jq"><span class="token keyword">def</span> <span class="token function">needs_license</span><span class="token punctuation">:</span> <br>  <span class="token c-style-function function">any</span><span class="token punctuation">(</span><span class="token dot important">.</span> <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token string">"car"</span><span class="token punctuation">,</span> <span class="token string">"truck"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token dot important">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>The jq manual says <a href="https://stedolan.github.io/jq/manual/#any,any(condition),any(generator;condition)">the following</a> about this form of <code>any</code>:</p><blockquote><p>The <code>any(generator; condition)</code> form applies the given condition to all the outputs of the given generator.</p></blockquote><p>So the first argument passed to <code>any/2</code> is exactly the expression we've been looking at thus far, i.e. <code>. == (&quot;car&quot;, &quot;truck&quot;)</code>. And it's supplied to the generator parameter.</p><p>The second argument being passed is <code>.</code> which is supplied to the condition parameter.</p><p>So how is this function body to be interpreted? Trying out a simple call to <code>any/2</code> helps me understand it a little more; the expression returns <code>true</code> here because at least one of the values (<code>2</code>) emitted from the generator expression <code>1,2,3</code> is divisible by 2:</p><pre class="language-jq"><code class="language-jq"><span class="token c-style-function function">any</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token dot important">.</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><br><span class="token comment"># => true</span></code></pre><p>Even more simply, I try this:</p><pre class="language-jq"><code class="language-jq"><span class="token c-style-function function">any</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token dot important">.</span> <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">)</span><br><span class="token comment"># => true</span></code></pre><p>In fact, this can be simplified to:</p><pre class="language-jq"><code class="language-jq"><span class="token c-style-function function">any</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token dot important">.</span><span class="token punctuation">)</span><br><span class="token comment"># => true</span></code></pre><p>The values (<code>null</code>, <code>false</code> and <code>true</code>) in the generator expression are considered in the context of the condition expression <code>.</code> and this of course then evaluates to <code>true</code> due to the third value being truthy. I deliberately used the word &quot;truthy&quot; here as this also works:</p><pre class="language-jq"><code class="language-jq"><span class="token c-style-function function">any</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">;</span> <span class="token dot important">.</span><span class="token punctuation">)</span><br><span class="token comment"># => true</span></code></pre><p>In working slowly through this, I realise what looked odd to me about Matthias's first function solution, given the <code>any(generator; condition)</code> signature - the generator expression looks more like a condition expression:</p><pre class="language-jq"><code class="language-jq"><span class="token keyword">def</span> <span class="token function">needs_license</span><span class="token punctuation">:</span> <br>  <span class="token c-style-function function">any</span><span class="token punctuation">(</span><span class="token dot important">.</span> <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token string">"car"</span><span class="token punctuation">,</span> <span class="token string">"truck"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token dot important">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>But now having a better understanding of how <code>. == (&quot;car&quot;, &quot;truck&quot;)</code> works as a generator, things are now clear. Piping the value <code>&quot;truck&quot;</code> into this function, for example, gives us what we want:</p><pre class="language-jq"><code class="language-jq"><span class="token string">"truck"</span> <span class="token operator pipe">|</span> needs_license<br><span class="token comment"># => true</span></code></pre><p>And to make sure I see what's going on, I can insert a couple of <a href="https://stedolan.github.io/jq/manual/#debug">debug</a> filters in-line with the generator:</p><pre class="language-jq"><code class="language-jq"><span class="token keyword">def</span> <span class="token function">needs_license</span><span class="token punctuation">:</span> <br>  <span class="token c-style-function function">any</span><span class="token punctuation">(</span>debug <span class="token operator pipe">|</span> <span class="token dot important">.</span> <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token string">"car"</span><span class="token punctuation">,</span> <span class="token string">"truck"</span><span class="token punctuation">)</span> <span class="token operator pipe">|</span> debug<span class="token punctuation">;</span> <span class="token dot important">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token string">"truck"</span> <span class="token operator pipe">|</span> needs_license</code></pre><p>Look at what that gives us (I've added some blank lines to better distinguish things):</p><pre class="language-json"><code class="language-json"><span class="token punctuation">[</span><span class="token string">"DEBUG:"</span><span class="token punctuation">,</span><span class="token string">"truck"</span><span class="token punctuation">]</span> From the 1st debug<span class="token punctuation">,</span> value going<br>                   into the generator.<br><br><span class="token punctuation">[</span><span class="token string">"DEBUG:"</span><span class="token punctuation">,</span><span class="token boolean">false</span><span class="token punctuation">]</span>   From the 2nd debug<span class="token punctuation">,</span> these two values<br><span class="token punctuation">[</span><span class="token string">"DEBUG:"</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">]</span>    are emitted from the generator.<br><br><span class="token boolean">true</span>               the final result produced by the call</code></pre><p><a name="the-if-then-else-end-based-function"></a></p><h2>The &quot;if ... then ... else ... end&quot; based function</h2><p>Here's the next sample solution:</p><pre class="language-jq"><code class="language-jq"><span class="token keyword">def</span> <span class="token function">needs_license</span><span class="token punctuation">:</span> <br>  <span class="token keyword">if</span> <span class="token dot important">.</span> <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token string">"car"</span><span class="token punctuation">,</span> <span class="token string">"truck"</span><span class="token punctuation">)</span> <span class="token keyword">then</span> <span class="token boolean">true</span> <span class="token keyword">else</span> empty <span class="token keyword">end</span> <span class="token operator">//</span> <span class="token boolean">false</span><span class="token punctuation">;</span></code></pre><p>This looked a bit odd to me too. Knowing that <code>. == (&quot;car&quot;, &quot;truck&quot;)</code> is essentially a generator of multiple values, what's going on here? Multiple values in the condition part of an if-then-else construct?</p><p>Well, the jq manual <a href="https://stedolan.github.io/jq/manual/#if-then-else">has the following to say</a> in the context of <code>if A then B else C end</code>:</p><blockquote><p>If the condition A produces multiple results, then B is evaluated once for each result that is not false or null, and C is evaluated once for each false or null.</p></blockquote><p>What does this look like? To get a feel for it, I try this:</p><pre class="language-jq"><code class="language-jq"><span class="token keyword">if</span> <span class="token string">"car"</span> <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token string">"car"</span><span class="token punctuation">,</span> <span class="token string">"truck"</span><span class="token punctuation">)</span> <span class="token keyword">then</span> <span class="token string">"yes"</span> <span class="token keyword">else</span> <span class="token string">"no"</span> <span class="token keyword">end</span></code></pre><p>This produces:</p><pre class="language-json"><code class="language-json"><span class="token string">"yes"</span><br><span class="token string">"no"</span></code></pre><p>The <code>&quot;yes&quot;</code> is from the <code>&quot;car&quot; == &quot;car&quot;</code> returning <code>true</code> (i.e. something that &quot;is not false or null&quot;), and the <code>&quot;no&quot;</code> is from the <code>&quot;car&quot; == &quot;truck&quot;</code> returning <code>false</code>.</p><p>So far so good - and I know that multiple values from the generator expression can and do &quot;flow through&quot; the if-then-else construct. This also then helps me understand what is going on in the rest of the construct:</p><pre class="language-jq"><code class="language-jq"><span class="token keyword">if</span> <span class="token dot important">.</span> <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token string">"car"</span><span class="token punctuation">,</span> <span class="token string">"truck"</span><span class="token punctuation">)</span> <span class="token keyword">then</span> <span class="token boolean">true</span> <span class="token keyword">else</span> empty <span class="token keyword">end</span></code></pre><p>First, the <code>true</code> and <code>empty</code> values, in their respective positions here, are so that the if-then-else construct will emit <code>true</code> (if there's a vehicle match) or nothing at all.</p><p>Using something like <code>if . == (&quot;car&quot;, &quot;truck&quot;) then true else false end</code> is not going to work for us here, not least because it's redundant (it could be reduced to the actual condition, without the if-then-else at all) but mostly because it will produce multiple boolean values, whatever the input. Only one is wanted, and that's why <code>empty</code> is used to throw away any <code>false</code> values.</p><p>But that then leaves just <code>true</code> or nothing being emitted, and this is what the <code>// false</code> is for:</p><pre class="language-jq"><code class="language-jq"><span class="token keyword">if</span> <span class="token dot important">.</span> <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token string">"car"</span><span class="token punctuation">,</span> <span class="token string">"truck"</span><span class="token punctuation">)</span> <span class="token keyword">then</span> <span class="token boolean">true</span> <span class="token keyword">else</span> empty <span class="token keyword">end</span> <span class="token operator">//</span> <span class="token boolean">false</span><span class="token punctuation">;</span></code></pre><p>Using this <a href="https://stedolan.github.io/jq/manual/#Alternativeoperator://">alternative operator</a> (<code>//</code>), <code>false</code> can be emitted where there's no value coming from the if-then-else; in other words, whenever there are <code>false</code> value(s) being emitted from the generator in the condition position.</p><p>To round off this section, I'll add a couple of <code>debug</code>s to the body of the function to see with my own eyes what's going on (I've also added some extra whitespace for readability):</p><pre class="language-jq"><code class="language-jq"><span class="token keyword">def</span> <span class="token function">needs_license</span><span class="token punctuation">:</span> <br>  <span class="token keyword">if</span> debug <span class="token dot important">.</span> <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token string">"car"</span><span class="token punctuation">,</span> <span class="token string">"truck"</span><span class="token punctuation">)</span> <span class="token operator pipe">|</span> debug <br>  <span class="token keyword">then</span> <span class="token boolean">true</span> <br>  <span class="token keyword">else</span> empty<br>  <span class="token keyword">end</span> <span class="token operator">//</span> <span class="token boolean">false</span><span class="token punctuation">;</span></code></pre><p>First, passing a vehicle that's not in the list, such as with <code>&quot;boat&quot; | needs_license</code>, emits this:</p><pre class="language-json"><code class="language-json"><span class="token punctuation">[</span><span class="token string">"DEBUG:"</span><span class="token punctuation">,</span><span class="token string">"boat"</span><span class="token punctuation">]</span><br><span class="token punctuation">[</span><span class="token string">"DEBUG:"</span><span class="token punctuation">,</span><span class="token boolean">false</span><span class="token punctuation">]</span><br><span class="token punctuation">[</span><span class="token string">"DEBUG:"</span><span class="token punctuation">,</span><span class="token boolean">false</span><span class="token punctuation">]</span><br><span class="token boolean">false</span></code></pre><p>The value <code>&quot;boat&quot;</code> goes in, two <code>false</code> values are emitted from the generator, they both get turned into nothing (with <code>else empty</code>) and then this nothingness is converted into <code>false</code> with the <code>// false</code>.</p><p>Now how about a vehicle that is in the list: <code>&quot;car&quot; | needs_license</code> emits this:</p><pre class="language-json"><code class="language-json"><span class="token punctuation">[</span><span class="token string">"DEBUG:"</span><span class="token punctuation">,</span><span class="token string">"car"</span><span class="token punctuation">]</span><br><span class="token punctuation">[</span><span class="token string">"DEBUG:"</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">]</span><br><span class="token punctuation">[</span><span class="token string">"DEBUG:"</span><span class="token punctuation">,</span><span class="token boolean">false</span><span class="token punctuation">]</span><br><span class="token boolean">true</span></code></pre><p>The <code>true</code> is emitted for <code>&quot;car&quot; == &quot;car&quot;</code>, and then <code>false</code> is emitted for <code>&quot;car&quot; == &quot;truck&quot;</code>. The <code>false</code> value is thrown away, but also because we still have a <code>true</code> value coming out of the if-then-else construct, the <code>// false</code> does not kick in, and we end up withat <code>true</code> value.</p><p>While I still prefer the &quot;any&quot; based function solution to this one, I still think it's quite elegant, and it taught me to be aware of generators producing multiple values in the context of a condition in such a construct, and how to handle them.</p><p><a name="the-select-based-function"></a></p><h2>The &quot;select&quot; based function</h2><p>The last of the function variants is this one:</p><pre class="language-jq"><code class="language-jq"><span class="token keyword">def</span> <span class="token function">needs_license</span><span class="token punctuation">:</span> <br>  <span class="token punctuation">(</span><span class="token dot important">.</span> <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token string">"car"</span><span class="token punctuation">,</span> <span class="token string">"truck"</span><span class="token punctuation">)</span> <span class="token operator pipe">|</span> <span class="token c-style-function function">select</span><span class="token punctuation">(</span><span class="token dot important">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token boolean">false</span><span class="token punctuation">;</span></code></pre><p>Everything here except for the <code>select(.)</code> has been covered already, so I can treat myself to slightly extended test, while omitting that <code>select(.)</code> part (and the <code>// false</code>) for now:</p><pre class="language-jq"><code class="language-jq"><span class="token string">"car"</span><span class="token punctuation">,</span> <span class="token string">"truck"</span><span class="token punctuation">,</span> <span class="token string">"bike"</span> <span class="token operator pipe">|</span> <span class="token dot important">.</span> <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token string">"car"</span><span class="token punctuation">,</span> <span class="token string">"truck"</span><span class="token punctuation">)</span></code></pre><p>This produces:</p><pre class="language-json"><code class="language-json"><span class="token boolean">true</span><br><span class="token boolean">false</span><br><span class="token boolean">false</span><br><span class="token boolean">true</span><br><span class="token boolean">false</span><br><span class="token boolean">false</span></code></pre><p>The order here is significant. That's three pairs of two booleans, from the combination of pairing <code>&quot;car&quot;</code>, <code>&quot;truck&quot;</code> and <code>&quot;boat&quot;</code>, one at a time, with the two values <code>&quot;car&quot;</code> and <code>&quot;truck&quot;</code>:</p><table><thead><tr><th>Input</th><th>Compare with <code>&quot;car&quot;</code></th><th>Compare with <code>&quot;truck&quot;</code></th></tr></thead><tbody><tr><td><code>&quot;car&quot;</code></td><td><code>true</code></td><td><code>false</code></td></tr><tr><td><code>&quot;truck&quot;</code></td><td><code>false</code></td><td><code>true</code></td></tr><tr><td><code>&quot;boat&quot;</code></td><td><code>false</code></td><td><code>false</code></td></tr></tbody></table><p>The <a href="https://stedolan.github.io/jq/manual/#select(boolean_expression)">select</a> function is described in the jq manual as <code>select(boolean_expression)</code> thus:</p><blockquote><p>The function <code>select(foo)</code> produces its input unchanged if <code>foo</code> returns <code>true</code> for that input, and produces no output otherwise.</p></blockquote><p>This description reminds me of the <code>if &lt;condition&gt; then true else empty end</code>; the only difference is that <code>select</code> returns the input unchanged and this if-then-else construct explicitly returns true. It just so happens of course that the input in this <code>select</code> case is going to be boolean values too, so it has the same effect.</p><p>And because it has the same effect, it also needs to supply the alternative value <code>false</code> when there's not a match, which is done again with <code>// false</code> attached to the entire output of the combination of the generator and the <code>select</code> function, i.e. this combination: <code>(.==(&quot;car&quot;, &quot;truck&quot;) | select(.))</code>.</p><p>I think the beauty here is the use of <code>.</code> as the boolean expression that <code>select</code> expects, conveying the values from the generator.</p><h2>Wrapping up</h2><p>I hadn't planned to write this content in this second part of the series, but thanks to Matthias's contribution, I thought it was worthwhile. I've certainly had a good opportunity to dwell on the minutiae of these solutions and to get a better feel for streams of values in jq programs.</p><p>In the next part I'll continue to look at community solutions for some other jq exercises on Exercism, and explain what I missed, observed, and learned.</p></main><aside class="post__aside"><div class="post__tags"><a href="/tags/jq/">#jq</a> <a href="/tags/exercism/">#exercism</a></div><style>.utterances {
  margin-left: inherit !important;
}</style><script src="https://utteranc.es/client.js" repo="qmacro/qmacro.github.io" issue-term="title" crossorigin="anonymous" async></script><nav class="post__pagination"><a href="/blog/posts/2023/04/07/living-on-a-narrowboat-the-stove-as-the-heart-of-the-home/"><span>←</span> <span>Living on a narrowboat - the stove as the heart of the home</span> </a><a href="/blog/posts/2023/03/29/learning-from-community-solutions-on-exercism-part-1/"><span>Learning from community solutions on Exercism - part 1</span> <span>→</span></a></nav></aside></article></main><footer class="footer"><div class="footer__content"><ul class="hero__social-links"><li><a rel="me" href="https://github.com/qmacro" target="_blank" rel="noopener noreferrer">GitHub</a></li><li><a rel="me" href="https://www.youtube.com/djadams-qmacro" target="_blank" rel="noopener noreferrer">YouTube</a></li><li><a rel="me" href="https://hachyderm.io/@qmacro" target="_blank" rel="noopener noreferrer">Mastodon</a></li><li><a href="/feed.xml" target="_blank" rel="noopener noreferrer">RSS</a></li></ul></div></footer></div><script src="/assets/main.31d6cfe0d16ae931b73c.js"></script></body></html>