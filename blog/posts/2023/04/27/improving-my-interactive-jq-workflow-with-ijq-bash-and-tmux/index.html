<!doctype html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="canonical" href="https://qmacro.org/blog/posts/2023/04/27/improving-my-interactive-jq-workflow-with-ijq-bash-and-tmux/"><link rel="alternate" type="application/atom+xml" title="DJ's Weblog - Feed" href="https://qmacro.org/feed.xml"><link href="/assets/main.fe6b9c1e7ba4ff2bb7b5.css" rel="stylesheet"><link rel="preconnect" href="https://fonts.gstatic.com"><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans&display=swap" rel="stylesheet"><title>Improving my interactive jq workflow with ijq, bash and tmux | DJ Adams</title><link rel="icon" type="“image/x-icon”" href="/images/favicon.ico"><meta property="og:title" content="Improving my interactive jq workflow with ijq, bash and tmux"><meta property="og:site_name" content="DJ Adams"><meta property="og:type" content="website"><meta property="og:url" content="https://qmacro.org/blog/posts/2023/04/27/improving-my-interactive-jq-workflow-with-ijq-bash-and-tmux/"><meta name="description" content="Improving my interactive jq workflow with ijq, bash and tmux 27 Apr 2023 | 4 min read I&#39;m a big fan of ijq and how it allows me to explore..."><meta property="og:description" content="Improving my interactive jq workflow with ijq, bash and tmux 27 Apr 2023 | 4 min read I&#39;m a big fan of ijq and how it allows me to explore..."><meta name="description" content="Improving my interactive jq workflow with ijq, bash and tmux 27 Apr 2023 | 4 min read I&#39;m a big fan of ijq and how it allows me to explore..."><meta property="og:image" content="https://qmacro.org/images/site-image.png"><script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script><script>mermaid.initialize({startOnLoad:true});</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-4WQKBG0L4Y"></script><script>window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-4WQKBG0L4Y');</script></head><body><div class="layout-wrapper"><header class="header"><div class="header__content"><h1 class="site-title"><a href="/">DJ Adams</a></h1><nav class="nav"><ul class="nav__list"><li class="nav-item"><a href="/about">About Me</a></li><li class="nav-item"><a href="/blog">Blog</a></li><li class="nav-item"><a href="/feed.xml">Feed</a></li></ul></nav></div></header><main class="main"><article class="post"><header class="post__header"><h1>Improving my interactive jq workflow with ijq, bash and tmux</h1><div class="post__details"><time datetime="2023-04-27">27 Apr 2023 </time><span>| </span><span>4 min read</span></div></header><main class="post__content"><p>I'm a big fan of ijq and how it allows me to explore JSON data interactively with jq expressions. With a small script I have improved my workflow by being able to capture the jq expression from ijq and use it easily on the command line.</p><h2>The challenge</h2><p>I noticed that I had developed a workflow where I would:</p><ul><li>load my JSON data into <a href="https://sr.ht/~gpanders/ijq/">ijq</a> and explore it</li><li>get to a stage where I was happy with the jq expression I'd constructed</li><li>exit ijq back to the command line, to then use jq</li><li>try to remember and manually type in the jq expression</li></ul><p>Yes, I could just use ijq to run the expression for real and get the results, but the command line is both part of my IDE, my scratchpad, my recent memory and much more, so it's important that I have the jq invocation and expression in my command history, and it's also then ready for further processing with more commands in a pipeline that I can add (super easily through the power of <a href="https://opensource.com/article/17/3/fun-vi-mode-your-shell">vi mode</a>).</p><p>Anyway, I finally recognised that this was suboptimal and decided to do something about it.</p><h2>The context</h2><p>90% of the time I'm working in a dev container. Whether that's running on my SAP-supplied MacBook Pro, or on one of my own Chrome OS devices, or even remotely, via Tailscale, on my Raspberry Pi at home.</p><p>The definition of my dev container is <a href="https://github.com/qmacro/dotfiles/tree/main/devcontainer">in my dotfiles repo</a>, and if you examine it, or watch some of the episode replays of our <a href="https://github.com/qmacro/dotfiles/tree/main/devcontainer">Hands-on SAP Dev</a> show on our <a href="https://www.youtube.com/user/sapdevs">SAP Developers YouTube channel</a>, you'll see that I use <a href="https://github.com/tmux/tmux/wiki">tmux</a>, an awesome terminal multiplexer. Beyond the obvious and visual superpowers it offers, tmux also surfaces session, window, pane and buffer management to the command line level, which gives me access to them and enables me to make use of them too.</p><p>The last part of the context is that the underlying OS in my dev containers is Linux, which means I have a native UNIX based environment in which to work, regardless of the actual physical machine I'm using.</p><h2>The solution</h2><p>Because of the context, mainly tmux and a Linux environment, but also the nice way ijq works, the solution was straightforward.</p><p>The way ijq works, as I've mentioned also in the comments in the script, is that it uses STDOUT and STDERR to split what it emits. On exiting, it will emit the results of the jq expression to STDOUT (i.e. the data you've grabbed or manipulated with the jq expression) and it will emit the jq expression itself to STDERR. If anything was amiss with the jq expression, it will also add the error detail to STDERR as well as ending on a high return code.</p><p>Anyway, to take advantage of tmux and how ijq works, I created a short Bash shell script, currently called <a href="https://github.com/qmacro/dotfiles/blob/98d3a68a960a42299d186c310252efb6df98b512/scripts/zijq">zijq</a> (the ABAP developers amongst you will know why). It currently looks like this:</p><pre class="language-shell"><code class="language-shell"><span class="token shebang important">#!/usr/bin/env bash</span><br><br><span class="token comment"># Wrapper around ijq to capture the actual jq expression that was used, </span><br><span class="token comment"># unless it ended in an error. The capture of the expression is into a </span><br><span class="token comment"># TMUX paste buffer, so this will only be valid in a TMUX session.</span><br><br><span class="token comment"># Just exec ijq directly if we're not in a TMUX context</span><br><span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token parameter variable">-z</span> <span class="token variable">$TMUX</span> <span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">exec</span> ijq <span class="token string">"<span class="token variable">$@</span>"</span><br><br><span class="token comment"># This is a temporary file to capture the jq expression in</span><br><span class="token builtin class-name">declare</span> tempfile<br><span class="token assign-left variable">tempfile</span><span class="token operator">=</span><span class="token string">"<span class="token variable"><span class="token variable">$(</span>mktemp<span class="token variable">)</span></span>"</span><br><br><span class="token comment"># When ijq ends, the output of the expression is emitted to STDOUT,</span><br><span class="token comment"># and the expression itself is output to STDERR.</span><br><br><span class="token comment"># Run ijq and capture STDERR and the actual RC</span><br><span class="token builtin class-name">declare</span> ijqrc<br>ijq <span class="token string">"<span class="token variable">$@</span>"</span> <span class="token operator"><span class="token file-descriptor important">2</span>></span><span class="token string">"<span class="token variable">$tempfile</span>"</span><br><span class="token assign-left variable">ijqrc</span><span class="token operator">=</span><span class="token string">"<span class="token variable">$?</span>"</span><br><br><span class="token comment"># Emit contents of temporary file to STDERR as ijq would</span><br><span class="token function">cat</span> <span class="token string">"<span class="token variable">$tempfile</span>"</span> <span class="token operator">></span><span class="token file-descriptor important">&amp;2</span><br><br><span class="token comment"># If things were OK, set the TMUX paste buffer.</span><br><span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token string">"<span class="token variable">$ijqrc</span>"</span> <span class="token parameter variable">-eq</span> <span class="token number">0</span> <span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> tmux set-buffer <span class="token string">"<span class="token variable"><span class="token variable">$(</span><span class="token function">cat</span> <span class="token string">"<span class="token variable">$tempfile</span>"</span><span class="token variable">)</span></span>"</span><br><br><span class="token comment"># Exit with whatever RC ijq ended with</span><br><span class="token builtin class-name">exit</span> <span class="token string">"<span class="token variable">$ijqrc</span>"</span></code></pre><p>I've tried to explain the main parts in the comments, but here are a few extra notes.</p><p>When tmux is running, the environment variable <code>TMUX</code> is set with some internal information, and it's not set when tmux is not running. So I'm using that to check whether the script is in fact running in a tmux context, and if not, I use Bash's <code>exec</code> builtin to replace the current process (the script) with the execution of the normal ijq instead (there's no point keeping the context of the script around, hence <code>exec</code>).</p><p>The separate lines <code>declare tempfile</code> and <code>tempfile=&quot;$(mktemp)&quot;</code> are a result of the wonderful <a href="https://github.com/koalaman/shellcheck">shellcheck</a> which keeps me straight on Bash style, accuracy and nuances (see the post <a href="/blog/posts/2020/10/05/improving-my-shell-scripting/">Improving my shell scripting</a> for more on this). If you're interested in the specific trap here, see <a href="https://www.shellcheck.net/wiki/SC2155">SC2155 Declare and assign separately to avoid masking return values</a>.</p><p>On executing ijq, I capture both the STDERR output into a file, and the return code into a variable. A return code of zero means success, anything else is failure. I'm only capturing the return code because I want this script to emit it when finishing, as if it were ijq itself (in case I have something downstream that examines that).</p><p>To stay true to ijq's behaviour at this point, I also emit to STDERR (<code>&gt;&amp;2</code>) whatever was captured there from the actual ijq invocation.</p><p>Most importantly, if the jq expression in my ijq session was OK (return code 0), then whatever was in the temporary file will be the expression, so that's when I use tmux's set-buffer command to put it into the buffer (in fact, there are multiple buffers, and lots you can do with them in tmux, check the <a href="https://man7.org/linux/man-pages/man1/tmux.1.html">man page</a> for all the details). I can then just use the standard tmux key binding <code>&lt;prefix&gt;[</code> to emit the contents wherever I am (which will be back on the command line).</p><h2>Usage</h2><p>Now I have this script, I can use ijq as normal (calling it as zijq, which I do often, and <a href="https://github.com/qmacro/dotfiles/commit/2a81134cdaf3f86a48826e7ba7483073c63a6db3">indirectly, via lf</a>) and when I'm happy with the jq expression I've come up with, I have it in my buffer, as if I'd captured it from, say, copy-mode, and I can emit it wherever I want, such as on the command line, by hitting <code>&lt;prefix&gt;[</code>.</p><p>You can see it in action here, as I exit to the command line, and paste in the jq expression into the <code>jq -r '...'</code> invocation.</p><p><img src="/images/2023/04/zijq.gif" alt="animated gif of zijq and paste buffer in action"></p></main><aside class="post__aside"><div class="post__tags"><a href="/tags/jq/">#jq</a> <a href="/tags/ijq/">#ijq</a> <a href="/tags/bash/">#bash</a> <a href="/tags/tmux/">#tmux</a> <a href="/tags/shell/">#shell</a></div><style>.utterances {
  margin-left: inherit !important;
}</style><script src="https://utteranc.es/client.js" repo="qmacro/qmacro.github.io" issue-term="title" crossorigin="anonymous" async></script><nav class="post__pagination"><a href="/blog/posts/2023/05/07/living-on-a-narrowboat-layout-details-of-the-stern/"><span>←</span> <span>Living on a narrowboat - layout details of the stern</span> </a><a href="/blog/posts/2023/04/25/more-on-the-comma-as-generator-and-streaming-with-select-in-jq/"><span>More on the comma as generator, and streaming with select in jq</span> <span>→</span></a></nav></aside></article></main><footer class="footer"><div class="footer__content"><ul class="hero__social-links"><li><a rel="me" href="https://github.com/qmacro" target="_blank" rel="noopener noreferrer">GitHub</a></li><li><a rel="me" href="https://www.youtube.com/djadams-qmacro" target="_blank" rel="noopener noreferrer">YouTube</a></li><li><a rel="me" href="https://www.linkedin.com/in/djadams/" target="_blank" rel="noopener noreferrer">LinkedIn</a></li><li><a rel="me" href="https://hachyderm.io/@qmacro" target="_blank" rel="noopener noreferrer">Mastodon</a></li><li><a href="/feed.xml" target="_blank" rel="noopener noreferrer">RSS</a></li></ul></div></footer></div><script src="/assets/main.31d6cfe0d16ae931b73c.js"></script></body></html>