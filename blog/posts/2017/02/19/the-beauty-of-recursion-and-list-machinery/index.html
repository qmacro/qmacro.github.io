<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<title>The beauty of recursion and list machinery</title>
		<meta name="description" content="Reserving the right to be wrong.">
		<link rel="alternate" href="/feed/feed.xml" type="application/atom+xml" title="DJ Adams">
		<link rel="icon" type="image/x-icon" href="/images/favicon.ico">

      <meta property="og:title" content="The beauty of recursion and list machinery">
        <meta property="og:site_name" content="DJ Adams">
          <meta property="og:image" content="/images/site-image.png">
        <meta property="og:description" content="Reserving the right to be wrong.">
        <meta property="og:url" content="https://qmacro.org/blog/posts/2017/02/19/the-beauty-of-recursion-and-list-machinery/">
		
		
		
		<style>/* This is an arbitrary CSS string added to the bundle */
/* Defaults */
:root {
	--font-family: -apple-system, system-ui, sans-serif;
	--font-family-monospace: Consolas, Menlo, Monaco, Andale Mono WT, Andale Mono, Lucida Console, Lucida Sans Typewriter, DejaVu Sans Mono, Bitstream Vera Sans Mono, Liberation Mono, Nimbus Mono L, Courier New, Courier, monospace;
}

/* Theme colors */
:root {
	--color-gray-20: #e0e0e0;
	--color-gray-50: #C0C0C0;
	--color-gray-90: #333;

	--background-color: #fff;

	--text-color: var(--color-gray-90);
	--text-color-link: #2884d2;
	--text-color-link-active: #15b0ed;
	--text-color-link-visited: #9f4199;

	--syntax-tab-size: 2;
}

@media (prefers-color-scheme: dark) {
	:root {
		--color-gray-20: #e0e0e0;
		--color-gray-50: #C0C0C0;
		--color-gray-90: #dad8d8;

		/* --text-color is assigned to --color-gray-_ above */
		--text-color-link: #1493fb;
		--text-color-link-active: #6969f7;
		--text-color-link-visited: #a6a6f8;

		--background-color: #15202b;
	}
}


/* Global stylesheet */
* {
	box-sizing: border-box;
}

@view-transition {
	navigation: auto;
}

html,
body {
	padding: 0;
	margin: 0 auto;
	font-family: var(--font-family);
	color: var(--text-color);
	background-color: var(--background-color);
}
html {
	overflow-y: scroll;
}
body {
	max-width: 40em;
}

/* https://www.a11yproject.com/posts/how-to-hide-content/ */
.visually-hidden:not(:focus):not(:active) {
	clip: rect(0 0 0 0);
	clip-path: inset(50%);
	height: 1px;
	overflow: hidden;
	position: absolute;
	white-space: nowrap;
	width: 1px;
}

/* Fluid images via https://www.zachleat.com/web/fluid-images/ */
img{
  max-width: 100%;
}
img[width][height] {
  height: auto;
}
img[src$=".svg"] {
  width: 100%;
  height: auto;
  max-width: none;
}
video,
iframe {
	width: 100%;
	height: auto;
}
iframe {
	aspect-ratio: 16/9;
}

p:last-child {
	margin-bottom: 0;
}
p {
	line-height: 1.5;
}

li {
	line-height: 1.5;
}

a[href] {
	color: var(--text-color-link);
}
a[href]:visited {
	color: var(--text-color-link-visited);
}
a[href]:hover,
a[href]:active {
	color: var(--text-color-link-active);
}

main,
footer {
	padding: 1rem;
}
/* main :first-child { */
/* 	margin-top: 0; */
/* } */

header {
	border-bottom: 1px dashed var(--color-gray-20);
}

#skip-link {
	text-decoration: none;
	background: var(--background-color);
	color: var(--text-color);
	padding: 0.5rem 1rem;
	border: 1px solid var(--color-gray-90);
	border-radius: 2px;
}

/* Prevent visually-hidden skip link fom pushing content around when focused */
#skip-link.visually-hidden:focus {
	position: absolute;
	top: 1rem;
	left: 1rem;
	/* Ensure it is positioned on top of everything else when it is shown */
	z-index: 999;
}

.links-nextprev {
	display: flex;
	justify-content: space-between;
	gap: .5em 1em;
	list-style: "";
	border-top: 1px dashed var(--color-gray-20);
	padding: 1em 0;
}
.links-nextprev > * {
	flex-grow: 1;
}
.links-nextprev-next {
	text-align: right;
}

table {
	margin: 1em 0;
}
table td,
table th {
	padding-right: 1em;
}

pre,
code {
	font-family: var(--font-family-monospace);
	color: seagreen;
}

pre,code[class*="language-"] {
	line-height: 1.2em !important;
	font-size: 0.93em !important;
}

pre:not([class*="language-"]) {
	margin: .5em 0;
	line-height: 1.375; /* 22px /16 */
	-moz-tab-size: var(--syntax-tab-size);
	-o-tab-size: var(--syntax-tab-size);
	tab-size: var(--syntax-tab-size);
	-webkit-hyphens: none;
	-ms-hyphens: none;
	hyphens: none;
	direction: ltr;
	text-align: left;
	white-space: pre;
	word-spacing: normal;
	word-break: normal;
	overflow-x: auto;
}
code {
	word-break: break-all;
}

/* Header */
header {
	display: flex;
	gap: 1em;
	flex-wrap: wrap;
	justify-content: space-between;
	align-items: center;
	padding: 1em;
}
.home-link {
	flex-grow: 1;
	font-size: 1em; /* 16px /16 */
	font-weight: 700;
}
.home-link:link:not(:hover) {
	text-decoration: none;
}

/* Nav */
.nav {
	display: flex;
	gap: .5em 1em;
	padding: 0;
	margin: 0;
	list-style: none;
}
.nav-item {
	display: inline-block;
}
.nav-item a[href]:not(:hover) {
	text-decoration: none;
}
.nav a[href][aria-current="page"] {
	text-decoration: underline;
}

/* Posts list */
.postlist {
	counter-reset: start-from var(--postlist-index);
	list-style: none;
	padding: 0;
}
.postlist-item {
	display: flex;
	flex-wrap: wrap;
	align-items: baseline;
	counter-increment: start-from -1;
	margin-bottom: 1em;
}
.postlist-item:before {
	display: inline-block;
	pointer-events: none;
	line-height: 100%;
	text-align: right;
	margin-left: -1.5rem;
}
.postlist-date,
.postlist-item:before {
	font-size: 0.8125em; /* 13px /16 */
	color: var(--color-gray-90);
}
.postlist-date {
	word-spacing: -0.5px;
}
.postlist-link {
	font-size: 1.1875em; /* 19px /16 */
	font-weight: 700;
	flex-basis: calc(100% - 1.5rem);
	text-underline-position: from-font;
	text-underline-offset: 0;
	text-decoration-thickness: 1px;
}
.postlist-item-active .postlist-link {
	font-weight: bold;
}

/* Tags */
.post-tag {
	display: inline-flex;
	align-items: center;
	justify-content: center;
	font-style: italic;
}

/* may want to make the description text smaller at some stage */
.post-description-list {
	font-size: 1.0em;
}

.post-description-main {
	font-style: italic;
}

.postlist-item > .post-tag {
	align-self: center;
}

/* Tags list */
.post-metadata {
	display: inline-flex;
	flex-wrap: wrap;
	gap: .5em;
	list-style: none;
	padding: 0;
	margin: 0;
}
.post-metadata time {
	margin-right: 1em;
}

blockquote {
	margin-top: 0px;
	margin-left: 0px;
	margin-bottom: 15px;
	padding-left: 15px;
	border-left: 5px solid lightgray;
}
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
	color: black;
	background: none;
	text-shadow: 0 1px white;
	font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
	font-size: 1em;
	text-align: left;
	white-space: pre;
	word-spacing: normal;
	word-break: normal;
	word-wrap: normal;
	line-height: 1.5;

	-moz-tab-size: 4;
	-o-tab-size: 4;
	tab-size: 4;

	-webkit-hyphens: none;
	-moz-hyphens: none;
	-ms-hyphens: none;
	hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
	text-shadow: none;
	background: #b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
	text-shadow: none;
	background: #b3d4fc;
}

@media print {
	code[class*="language-"],
	pre[class*="language-"] {
		text-shadow: none;
	}
}

/* Code blocks */
pre[class*="language-"] {
	padding: 1em;
	margin: .5em 0;
	overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
	background: #f5f2f0;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
	padding: .1em;
	border-radius: .3em;
	white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
	color: slategray;
}

.token.punctuation {
	color: #999;
}

.token.namespace {
	opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
	color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
	color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
	color: #9a6e3a;
	/* This background color was intended by the author of this theme. */
	background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
	color: #07a;
}

.token.function,
.token.class-name {
	color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
	color: #e90;
}

.token.important,
.token.bold {
	font-weight: bold;
}
.token.italic {
	font-style: italic;
}

.token.entity {
	cursor: help;
}
/*
 * New diff- syntax
 */

pre[class*="language-diff-"] {
	--eleventy-code-padding: 1.25em;
	padding-left: var(--eleventy-code-padding);
	padding-right: var(--eleventy-code-padding);
}
.token.deleted {
	background-color: hsl(0, 51%, 37%);
	color: inherit;
}
.token.inserted {
	background-color: hsl(126, 31%, 39%);
	color: inherit;
}

/* Make the + and - characters unselectable for copy/paste */
.token.prefix.unchanged,
.token.prefix.inserted,
.token.prefix.deleted {
	-webkit-user-select: none;
	user-select: none;
	display: inline-flex;
	align-items: center;
	justify-content: center;
	padding-top: 2px;
	padding-bottom: 2px;
}
.token.prefix.inserted,
.token.prefix.deleted {
	width: var(--eleventy-code-padding);
	background-color: rgba(0,0,0,.2);
}

/* Optional: full-width background color */
.token.inserted:not(.prefix),
.token.deleted:not(.prefix) {
	display: block;
	margin-left: calc(-1 * var(--eleventy-code-padding));
	margin-right: calc(-1 * var(--eleventy-code-padding));
	text-decoration: none; /* override del, ins, mark defaults */
	color: inherit; /* override del, ins, mark defaults */
}
.utterances {
  margin-left: inherit !important;
}</style>
		

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async="" src="https://www.googletagmanager.com/gtag/js?id=G-4WQKBG0L4Y"></script>
    

	</head>
	<body>
		<a href="#main" id="skip-link" class="visually-hidden">Skip to main content</a>

		<header>
			<a href="/" class="home-link">DJ Adams</a>
			<nav>
				<h2 class="visually-hidden" id="top-level-navigation-menu">Top level navigation menu</h2>
				<ul class="nav">
					<li class="nav-item"><a href="/">Home</a></li>
					<li class="nav-item"><a href="/about/">About</a></li>
					<li class="nav-item"><a href="/blog/">Blog</a></li>
					<li class="nav-item"><a href="/feed/feed.xml">Feed</a></li>
				</ul>
			</nav>
		</header>

		<main id="main">
			<heading-anchors>
				


<h1 id="the-beauty-of-recursion-and-list-machinery">The beauty of recursion and list machinery</h1>

<ul class="post-metadata">
	<li><time datetime="2017-02-19">19 February 2017</time></li>
	<li><a href="/tags/fp/" class="post-tag">fp</a>, </li>
	<li><a href="/tags/language-ramblings/" class="post-tag">language-ramblings</a></li>
</ul>

<p class="post-description-main"></p>

<p>There are beautiful patterns inherent in the use of recursion that I've seen in my attempts to reboot my brain with a new, more functionally focused way of thinking about programming.</p>
<p>This post explores one particular pattern that is inherent in how recursion is often expressed in some functional languages, and finishes with the alternative based on what I'm going to call &quot;list machinery&quot; - mechanisms within a language that provide powerful processing abstractions over structures such as lists.</p>
<h2 id="initial-recognition">Initial recognition</h2>
<p>Erik Meijer, whom I'll mention properly in a moment, uses a phrase:</p>
<blockquote>
<p>&quot;If you stare long enough at it ...&quot;.</p>
</blockquote>
<p>This really appeals to me, because it expresses the act of focus and concentration in a wonderfully casual way. I've stared at this stuff long enough for it to become something tangible, something recognisable, and hopefully there's useful content here for you to stare at too.</p>
<h3 id="introduction-via-haskell">Introduction via Haskell</h3>
<p>It was my son <a href="http://jcla1.com">Joseph</a> that introduced me to the concept that has intrigued me since the first day I saw it. Proficient in many different languages, he was showing me some solutions to <a href="(https://www.youtube.com/watch?v=UIUlFQH4Cvo&amp;list=PLTA0Ta9Qyspa5Nayx0VCHj5AHQJqp1clD)">Project Euler</a> challenges that he'd written in Haskell. They involved a fascinating approach using pattern matching. Determining the resulting value of something based upon a list of possible matches on the data being processed. It involved expressions involving the symbols <code>x</code> and <code>xs</code>. This is very abstract, but it will become more concrete shortly.</p>
<h3 id="c9-lectures">C9 Lectures</h3>
<p>The next time I encountered this pattern matching technique was in a series of lectures by the inimitable Erik Meijer. These lectures are on functional programming techniques, and the series is called &quot;<a href="https://www.youtube.com/watch?v=UIUlFQH4Cvo&amp;list=PLTA0Ta9Qyspa5Nayx0VCHj5AHQJqp1clD">Programming in Haskell</a>&quot;, although the concepts themselves are explained in terms of other languages (C#, LINQ) too. I thoroughly recommend you spend some time enjoying them. One thing that Erik said a lot was &quot;x over xs&quot;, which is expressed as <code>x::xs</code>.</p>
<p>Being somewhat intimidated by the M-word (monad), I have avoided Haskell so far, although my interest in functional programming in other languages (such as in Clojure, and with Ramda in JavaScript) has grown considerably ... I presented at <a href="https://sessioncatalog.sapevents.com/go/agendabuilder.sessions/?l=133&amp;sid=37706_0&amp;locale=en_US">SAP TechEd EMEA</a> and also at <a href="/tweets/qmacro/status/802108634255806465/">UI5con</a>, both in 2016, on functional programming techniques in JavaScript.</p>
<h3 id="elm">Elm</h3>
<p>And now, learning <a href="http://elm-lang.org/">elm</a>, I re-encounter these pattern-matching patterns again. I think it's because, at least to my naive mind, elm seems to reflect a lot of concepts from Haskell (and from Clojure, for that matter). The patterns are expressed nicely in an online book &quot;<a href="https://learnyouanelm.github.io/">Learn You an Elm</a>&quot;; the book is very much a work-in-progress but definitely worth a read even at this early stage.</p>
<p>The examples in this post will be in elm.</p>
<h2 id="subsequent-understanding">Subsequent understanding</h2>
<p>It turns out that the wonderfully succinct expression <code>x::xs</code> represents one of the core concepts in functional programming. A list can be seen in two parts - the head, and the tail. The first element, and the rest of the elements. So <code>x</code> represents the head of a list, and <code>xs</code> represents the tail. And the <code>::</code>? That represents the concept of &quot;cons&quot;, which has <a href="https://en.wikipedia.org/wiki/Cons">its own page on Wikipedia</a> but I'm going to call &quot;prepend&quot; for brevity.</p>
<h3 id="no-loops">No loops</h3>
<p>One thing to bear in mind from the outset is that in functional programming, there are no loops. Not as you or I might understand them, at least. But if you think of a list of items that you want to process &quot;in a loop&quot;, the concept of &quot;x over xs&quot; is what you need.</p>
<p>If you want to transform a list, by applying some function to [each element in] that list, here's how it goes, using that concept. Remembering that functional programming is less about describing the 'how', and more about stating the 'what', we can say that the new list is the result of the function applied to the head of the list (an individual element), combined with the result of the function applied to the tail of the list (a smaller list).</p>
<p>And the function applied to the tail of the list is the result of the function applied to the head of that list, combined with the function applied to the tail of that same list.</p>
<p>And so it goes on, until there are no more elements in the (ever decreasing) tail to which the function must be applied.</p>
<p>The function is called recursively in this fashion.</p>
<p>Here's an example. If we have a list <code>[1,2,3,4,5]</code> and want to compute the sum of all the elements in that list (15), this is what the pattern matching approach looks like.</p>
<pre class="language-elm" tabindex="0"><code class="language-elm"><span class="token hvariable">sum</span> <span class="token operator">:</span> <span class="token constant">List</span> <span class="token hvariable">number</span> <span class="token operator">-></span> <span class="token hvariable">number</span>
<span class="token hvariable">sum</span> <span class="token hvariable">list</span> <span class="token operator">=</span>
  <span class="token keyword">case</span> <span class="token hvariable">list</span> <span class="token keyword">of</span>
    <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">-></span> <span class="token number">0</span>
    <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">::</span><span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token hvariable">x</span> <span class="token operator">+</span> <span class="token hvariable">sum</span> <span class="token hvariable">xs</span></code></pre>
<p>Calling the function on the list gives us what we're looking for:</p>
<pre class="language-elm" tabindex="0"><code class="language-elm"><span class="token hvariable">sum</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>
<span class="token comment">--> 15</span></code></pre>
<p>Let's extract the core pattern matching approach here, in the <code>case</code> expression:</p>
<ul>
<li>
<p><code>[]</code> matches an empty list. To be useful (ie not go on forever), recursion needs a base case. This is the base case.</p>
</li>
<li>
<p><code>(x::xs)</code> is a pattern that matches two parts - the head and the tail of the list. If the earlier <code>[]</code> didn't match, then we're going to have at least one element, matched into <code>x</code>, and any further elements, if they exist, are matched into <code>xs</code>.</p>
</li>
</ul>
<p>(For those of you who, like me, are not steeped in strongly typed languages, the question &quot;what happens if we don't pass a list at all, just, say, a string?&quot; doesn't even come up, as the elm compiler won't allow that to happen.)</p>
<p>The sum of an empty list of numbers - the base case - is zero, clearly. The sum of a non empty list of numbers is where we see the recursive nature of the definition: it's the first number added to the sum of the rest of the numbers. And while contemplating this beautiful simplicity, consider also that this is an example of how a functional approach to programming is declarative, rather than imperative. Rather than explaining <em>how</em> to compute the sum (which we'd traditionally do with a loop and some variable to accumulate the final value), we're just saying <em>what</em> it is.</p>
<h3 id="further-pattern-examples">Further pattern examples</h3>
<p>Let's examine a few more instances of this pattern matching. I'm going for quite a few examples, so you can stare at them all for a while.</p>
<h4 id="factorial">Factorial</h4>
<p>First, how about calculating factorials:</p>
<pre class="language-elm" tabindex="0"><code class="language-elm"><span class="token hvariable">factorial</span> <span class="token operator">:</span> <span class="token constant">Int</span> <span class="token operator">-></span> <span class="token constant">Int</span>
<span class="token hvariable">factorial</span> <span class="token hvariable">n</span> <span class="token operator">=</span>
  <span class="token keyword">case</span> <span class="token hvariable">n</span> <span class="token keyword">of</span>
    <span class="token number">0</span> <span class="token operator">-></span> <span class="token number">1</span>
    _ <span class="token operator">-></span> <span class="token hvariable">n</span> <span class="token operator">*</span> <span class="token hvariable">factorial</span> <span class="token punctuation">(</span><span class="token hvariable">n</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>

<span class="token hvariable">factorial</span> <span class="token number">5</span>
<span class="token comment">--> 120</span></code></pre>
<p>We have the same approach here: matching the base case, where n is zero, and then declaring that the factorial of n is just n multiplied by the factorial of n - 1. In this particular example of pattern matching, we're not interested in capturing the matched number (as we already have it in n), hence the <code>_</code> in the pattern.</p>
<h4 id="length">Length</h4>
<p>How about calculating the length of a list? That's simple:</p>
<pre class="language-elm" tabindex="0"><code class="language-elm"><span class="token hvariable">length</span> <span class="token operator">:</span> <span class="token constant">List</span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token constant">Int</span>
<span class="token hvariable">length</span> <span class="token hvariable">list</span> <span class="token operator">=</span>
  <span class="token keyword">case</span> <span class="token hvariable">list</span> <span class="token keyword">of</span>
    <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">-></span> <span class="token number">0</span>
    <span class="token punctuation">(</span>_<span class="token operator">::</span><span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token hvariable">length</span> <span class="token hvariable">xs</span>

<span class="token hvariable">length</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>
<span class="token comment">--> 5</span></code></pre>
<p>Again, we see the same pattern.</p>
<h4 id="reverse">Reverse</h4>
<p>This time we'll use the pattern matching approach to produce the reverse of a list.</p>
<pre class="language-elm" tabindex="0"><code class="language-elm"><span class="token hvariable">reverse</span> <span class="token operator">:</span> <span class="token constant">List</span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token constant">List</span> <span class="token hvariable">a</span>
<span class="token hvariable">reverse</span> <span class="token hvariable">list</span> <span class="token operator">=</span>
  <span class="token keyword">case</span> <span class="token hvariable">list</span> <span class="token keyword">of</span>
    <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">-></span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">::</span><span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token hvariable">reverse</span> <span class="token hvariable">xs</span> <span class="token operator">++</span> <span class="token punctuation">[</span><span class="token hvariable">x</span><span class="token punctuation">]</span>

<span class="token hvariable">reverse</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>
<span class="token comment">--> [5,4,3,2,1]</span></code></pre>
<p>This time, the base case - an empty list - results in an empty list. Otherwise we take the head and prepend the reverse of the tail to it, recursively.</p>
<h4 id="take">Take</h4>
<p>Now let's define our own <code>take</code> function, a common facility found in functional languages that are (naturally) list-oriented. The function returns the first n elements of a list.</p>
<pre class="language-elm" tabindex="0"><code class="language-elm"><span class="token hvariable">take</span> <span class="token operator">:</span> <span class="token constant">Int</span> <span class="token operator">-></span> <span class="token constant">List</span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token constant">List</span> <span class="token hvariable">a</span>
<span class="token hvariable">take</span> <span class="token hvariable">n</span> <span class="token hvariable">list</span> <span class="token operator">=</span>
  <span class="token keyword">if</span> <span class="token hvariable">n</span> <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token keyword">then</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token keyword">else</span> <span class="token keyword">case</span> <span class="token hvariable">list</span> <span class="token keyword">of</span>
    <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">-></span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">::</span><span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token hvariable">x</span> <span class="token operator">::</span> <span class="token hvariable">take</span> <span class="token punctuation">(</span><span class="token hvariable">n</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token hvariable">xs</span>

<span class="token hvariable">take</span> <span class="token number">3</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>
<span class="token comment">--> [1,2,3]</span></code></pre>
<p>Here we have something extra. There are two base cases - where the list is empty, but also where the number of elements to take is zero or less. But otherwise the pattern is the same.</p>
<h4 id="member">Member</h4>
<p>This time, we're going to need the <code>if then else</code> expression to declare the recursive definition for a function that returns whether an element is a member of a list.</p>
<pre class="language-elm" tabindex="0"><code class="language-elm">
<span class="token hvariable">member</span> <span class="token operator">:</span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token constant">List</span> <span class="token hvariable">a</span> <span class="token operator">-></span> <span class="token constant">Bool</span>
<span class="token hvariable">member</span> <span class="token hvariable">a</span> <span class="token hvariable">list</span> <span class="token operator">=</span>
  <span class="token keyword">case</span> <span class="token hvariable">list</span> <span class="token keyword">of</span>
    <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">-></span> <span class="token constant">False</span>
    <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">::</span><span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token keyword">if</span> <span class="token hvariable">a</span> <span class="token operator">==</span> <span class="token hvariable">x</span> <span class="token keyword">then</span> <span class="token constant">True</span> <span class="token keyword">else</span> <span class="token hvariable">member</span> <span class="token hvariable">a</span> <span class="token hvariable">xs</span>

<span class="token hvariable">member</span> <span class="token number">3</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>
<span class="token comment">--> True</span>

<span class="token hvariable">member</span> <span class="token number">6</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>
<span class="token comment">--> False</span></code></pre>
<p>If the list is empty - the base case - then the answer is clearly going to be False. Otherwise we check to see if the head of the list is the same as the element to find, and if it is, then the answer is True; otherwise we recurse with the tail of the list.</p>
<h4 id="maximum">Maximum</h4>
<p>Finally, here's a definition of a function that will return the maximum value in a list. Note here that the function's type signature uses the <code>comparable</code> type.</p>
<pre class="language-elm" tabindex="0"><code class="language-elm"><span class="token hvariable">maximum</span> <span class="token operator">:</span> <span class="token constant">List</span> <span class="token hvariable">comparable</span> <span class="token operator">-></span> <span class="token hvariable">comparable</span>
<span class="token hvariable">maximum</span> <span class="token hvariable">list</span> <span class="token operator">=</span>
  <span class="token keyword">case</span> <span class="token hvariable">list</span> <span class="token keyword">of</span>
    <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">-></span> <span class="token hvariable">Debug.crash</span> <span class="token string">"Maximum of empty list?!"</span>
    <span class="token punctuation">[</span><span class="token hvariable">x</span><span class="token punctuation">]</span> <span class="token operator">-></span> <span class="token hvariable">x</span>
    <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">::</span><span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token keyword">let</span> <span class="token hvariable">m</span> <span class="token operator">=</span> <span class="token hvariable">maximum</span> <span class="token hvariable">xs</span>
      <span class="token keyword">in</span> <span class="token keyword">if</span> <span class="token hvariable">x</span> <span class="token operator">></span> <span class="token hvariable">m</span> <span class="token keyword">then</span> <span class="token hvariable">x</span> <span class="token keyword">else</span> <span class="token hvariable">m</span>

<span class="token hvariable">maximum</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token comment">--> 5</span></code></pre>
<p>Here we see another construct - the 'let expression', similar to how 'let' is used in Clojure for bindings. It allows the creation of short-lived values, similar to scope-limited variables in other languages. What we're saying for this last pattern case <code>(x::xs)</code> is that we want to calculate the maximum of the tail of the list and assign that to <code>m</code>, and then in the context of that, check whether the head of the list is greater than that or not.</p>
<p>Elm has a builtin function <code>max</code> that will return the maximum of two comparables. The &quot;Learn You an Elm&quot; book points out that this can allow us to be even more succinct in our maximum function, like this:</p>
<pre class="language-elm" tabindex="0"><code class="language-elm"><span class="token hvariable">maximum_</span> <span class="token operator">:</span> <span class="token constant">List</span> <span class="token hvariable">comparable</span> <span class="token operator">-></span> <span class="token hvariable">comparable</span>
<span class="token hvariable">maximum_</span> <span class="token hvariable">list</span> <span class="token operator">=</span>
  <span class="token keyword">case</span> <span class="token hvariable">list</span> <span class="token keyword">of</span>
    <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">-></span> <span class="token hvariable">Debug.crash</span> <span class="token string">"Maximum of empty list?!"</span>
    <span class="token punctuation">[</span><span class="token hvariable">x</span><span class="token punctuation">]</span> <span class="token operator">-></span> <span class="token hvariable">x</span>
    <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">::</span><span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token builtin">max</span> <span class="token hvariable">x</span> <span class="token punctuation">(</span><span class="token hvariable">maximum_</span> <span class="token hvariable">xs</span><span class="token punctuation">)</span>

<span class="token hvariable">maximum_</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token comment">--> 5</span></code></pre>
<p>Wonderful.</p>
<h2 id="list-machinery">List machinery</h2>
<p>I've talked at length about recursion, and perhaps you too can see the beauty therein.</p>
<p>So what about list machinery? Again, following the 'what not how' philosophy, let's look at a little bit of list machinery in the form of the swiss army chainsaw function <code>reduce</code>, which in elm (and other languages) is known as <code>foldl</code> - for &quot;fold-left&quot;.</p>
<p>We'll re-implement the <code>maximum</code> function with <code>foldl</code> and the <code>max</code> builtin function:</p>
<pre class="language-elm" tabindex="0"><code class="language-elm"><span class="token hvariable">maximum_</span> <span class="token operator">:</span> <span class="token constant">List</span> <span class="token hvariable">comparable</span> <span class="token operator">-></span> <span class="token hvariable">comparable</span>
<span class="token hvariable">maximum_</span> <span class="token hvariable">list</span> <span class="token operator">=</span>
  <span class="token hvariable">List.foldl</span> <span class="token builtin">max</span> <span class="token number">0</span> <span class="token hvariable">list</span>

<span class="token hvariable">maximum_</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token comment">--> 5</span></code></pre>
<p>The <code>foldl</code> function reduces a list by applying a function in turn to each of the elements. The function to apply should have two parameters - the first to accept the accumulated value and the second to accept the list element being folded over. So here, the function to apply is <code>max</code>, which takes two arguments, and the initial value for any maximum comparison (of positive numbers, at least) should be zero.</p>
<p>Perhaps more wonderful even than the recursive version? Remember that we're processing each element of a list, without any concern as to how that processing happens - we leave that to the language's list machinery to deal with for us.</p>
<p>And to finish, how about using <code>foldl</code> to reverse a list, so we can contrast it with the recursive definition earlier?</p>
<pre class="language-elm" tabindex="0"><code class="language-elm"><span class="token hvariable">List.foldl</span> <span class="token punctuation">(</span><span class="token operator">::</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>
<span class="token comment">--> [5,4,3,2,1]</span></code></pre>
<p>(The cons function <code>::</code> can be used in function position by surrounding it in brackets.)</p>
<p>Gosh. Worthy of a long stare. Don't you think?</p>
<p><strong>Postscript:</strong></p>
<p>A day after publishing this post, I find myself at <a href="http://www.lambdalounge.org.uk/">Lambda Lounge</a> in Manchester this evening, hosted at <a href="https://madlab.org.uk/">MadLab</a>, where we're learning about <a href="http://elixir-lang.org/">Elixir</a>, a dynamic functional language on the Erlang OTP platform, and a short way into the session, this sample is presented to us:</p>
<pre class="language-elixir" tabindex="0"><code class="language-elixir"><span class="token keyword">defmodule</span> <span class="token module class-name">Factorial</span> <span class="token keyword">do</span>
  <span class="token keyword">def</span> <span class="token function">of</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token attr-name">do:</span> <span class="token number">1</span>
  <span class="token keyword">def</span> <span class="token function">of</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token attr-name">do:</span> n <span class="token operator">*</span> <span class="token function">of</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token keyword">end</span>

<span class="token module class-name">Factorial</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>
<span class="token operator">/</span><span class="token operator">/</span>> <span class="token number">120</span></code></pre>
<p>While the Elixir syntax may be less familiar to us right now, I'm guessing that the approach here, that we've examined in this post, jumps off the page in a rush of familiarity. Within the <code>Factorial</code> module, we have a couple of definitions of the <code>of</code> function, which are used in the same pattern matching way. And we can see the base case defined thus:</p>
<pre class="language-elixir" tabindex="0"><code class="language-elixir"><span class="token keyword">def</span> <span class="token function">of</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token attr-name">do:</span> <span class="token number">1</span></code></pre>
<p>and the recursive call:</p>
<pre class="language-elixir" tabindex="0"><code class="language-elixir"><span class="token keyword">def</span> <span class="token function">of</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token attr-name">do:</span> n <span class="token operator">*</span> <span class="token function">of</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span></code></pre>
<p>Lovely.</p>



<script src="https://utteranc.es/client.js" repo="qmacro/qmacro.github.io" issue-term="title" crossorigin="anonymous" async=""></script>

<ul class="links-nextprev"><li class="links-nextprev-prev">← Previous<br> <a href="/blog/posts/2017/02/13/reaching-out-to-the-new-new-kingmakers/">Reaching out to the new new kingmakers</a></li><li class="links-nextprev-next">Next →<br><a href="/blog/posts/2017/02/27/best-practices-for-mobile-reporting/">Best practices for mobile reporting</a></li>
</ul>

			</heading-anchors>
		</main>

		<!-- This page `/blog/posts/2017/02/19/the-beauty-of-recursion-and-list-machinery/` was built on 2025-12-08T20:40:48.622Z -->
		<script type="module" src="/dist/t-8sxMV3B9.js"></script>
	</body>
</html>
