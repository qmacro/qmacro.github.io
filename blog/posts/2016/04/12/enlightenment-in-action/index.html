<!doctype html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="canonical" href="https://qmacro.org/blog/posts/2016/04/12/enlightenment-in-action/"><link href="/assets/main.d44a8693a615cc267cd3.css" rel="stylesheet"><link rel="preconnect" href="https://fonts.gstatic.com"><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans&display=swap" rel="stylesheet"><title>Enlightenment in action | DJ Adams</title><link rel="icon" type="“image/x-icon”" href="/images/favicon.ico"><meta property="og:title" content="Enlightenment in action"><meta property="og:site_name" content="DJ Adams"><meta property="og:type" content="website"><meta property="og:url" content="https://qmacro.org/blog/posts/2016/04/12/enlightenment-in-action/"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:creator" content="@qmacro"><meta name="description" content="Enlightenment in action 12 Apr 2016 | 3 min read One of the ideas that Clojure embraces is this Perlism: It is better to have 100 functions..."><meta property="og:description" content="Enlightenment in action 12 Apr 2016 | 3 min read One of the ideas that Clojure embraces is this Perlism: It is better to have 100 functions..."><meta name="description" content="Enlightenment in action 12 Apr 2016 | 3 min read One of the ideas that Clojure embraces is this Perlism: It is better to have 100 functions..."><meta property="og:image" content="https://qmacro.org/images/site-image.png"><meta name="twitter:image" content="https://qmacro.org/images/site-image.png"><script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script><script>mermaid.initialize({startOnLoad:true});</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-4WQKBG0L4Y"></script><script>window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-4WQKBG0L4Y');</script></head><body><div class="layout-wrapper"><header class="header"><div class="header__content"><h1 class="site-title"><a href="/">DJ Adams</a></h1><nav class="nav"><ul class="nav__list"><li class="nav-item"><a href="/about">About Me</a></li><li class="nav-item"><a href="/talks">Talks</a></li><li class="nav-item"><a href="/blog">Blog</a></li><li class="nav-item"><a href="/feed.xml">Feed</a></li></ul></nav></div></header><main class="main"><article class="post"><header class="post__header"><h1>Enlightenment in action</h1><div class="post__details"><time datetime="2016-04-12">12 Apr 2016 </time><span>| </span><span>3 min read</span></div></header><main class="post__content"><p>One of the ideas that Clojure embraces is this <a href="http://www.cs.yale.edu/homes/perlis-alan/quotes.html">Perlism</a>:</p><blockquote><p>It is better to have 100 functions operate on one data structure than 10 functions on 10 data structure</p></blockquote><p>This makes a lot of sense. But it also is clear that the language, as a set of functions and features, is large. Of course, at a low level, the language is very small; but the layers that have been built to operate on data structures have a depth that I haven't yet mastered.</p><p>It's not a case of the layers or functions being too complicated ... rather, I just haven't discovered everything that's possible yet. And when I haven't, I am resorting to mechanical solutions. I suppose this is simply a part of the journey, and while building a mechanical solution to a problem is irksome, it's educational, especially when you are shown something so much more succinct.</p><p><strong>An example</strong></p><p>Here's one example, a solution to 4Clojure problem 63 &quot;<a href="https://www.4clojure.com/problem/63">Group a Sequence</a>&quot;. A fairly straightforward challenge, but one that I couldn't see an obviously neat way of solving. (Note that the rules prevented the use of the <code>group-by</code> function, with which it would have been a cinch to solve, of course!).</p><p><em>A clean but mechanical approach</em></p><p>Here's what I ended up with:</p><pre class="language-clojure"><code class="language-clojure"><span class="token punctuation">(</span><span class="token keyword">fn</span> p63 <span class="token punctuation">[</span>f xs<span class="token punctuation">]</span><br>  <span class="token punctuation">(</span><span class="token keyword">loop</span> <span class="token punctuation">[</span>elements xs<br>         result <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">]</span><br>    <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">empty?</span> elements<span class="token punctuation">)</span><br>      result<br>      <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">[</span>element <span class="token punctuation">(</span><span class="token keyword">first</span> elements<span class="token punctuation">)</span><br>            value <span class="token punctuation">(</span><span class="token function">f</span> element<span class="token punctuation">)</span><br>            values <span class="token punctuation">(</span><span class="token keyword">or</span> <span class="token punctuation">(</span><span class="token function">result</span> value<span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span><br>        <span class="token punctuation">(</span><span class="token keyword">recur</span> <span class="token punctuation">(</span><span class="token keyword">rest</span> elements<span class="token punctuation">)</span><br>               <span class="token punctuation">(</span><span class="token keyword">assoc</span> result value <span class="token punctuation">(</span><span class="token keyword">conj</span> values element<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>In one way, I'm happy, because it's using the <code>loop/recur</code> construction (tail recursion idiom), with the &quot;<a href="http://langram.org/tag/firstrest/">first/rest</a>&quot; pattern, and it's not mutating any state. And I typed this in directly and it solved the puzzle first time :-)</p><p>But there's a mechanical nature to it. Here's what it does, generally:</p><ul><li>starts a <code>loop</code> with the elements given, and an empty result map</li><li>if there are no elements, it just returns whatever's in the result map at that time</li><li>otherwise it takes the first element, calculates the result of applying the function to that element, and retrieves the current values for that result key (defaulting to an empty vector if there aren't any yet)</li><li>then in the body of the <code>let</code> binding it simply <code>recur</code>s with the <code>rest</code> of the elements (all but the <code>first</code>), setting the value for the <code>result</code> var to be that plus the addition of the calculated value in the right place in the map</li></ul><p><em>A neater approach</em></p><p>Here's the solution from another 4Clojure user that I'm following (and I am learning a great deal from them, whoever they are!):</p><pre class="language-clojure"><code class="language-clojure"><span class="token punctuation">(</span><span class="token keyword">fn</span> <span class="token punctuation">[</span>f s<span class="token punctuation">]</span><br>  <span class="token punctuation">(</span><span class="token keyword">apply</span> merge-with concat <span class="token punctuation">(</span><span class="token keyword">map</span> <span class="token operator">#</span><span class="token punctuation">(</span><span class="token keyword">hash-map</span> <span class="token punctuation">(</span><span class="token function">f</span> %<span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>%<span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>Wow. The power of this solution, and the secret of its brevity, is the <code>merge-with</code> function, which is documented thus:</p><p><em>Returns a map that consists of the rest of the maps conj-ed onto the first. If a key occurs in more than one map, the mapping(s) from the latter (left-to-right) will be combined with the mapping in the result by calling (f val-in-result val-in-latter).</em></p><p>This was exactly the right thing. The <code>(map #(hash-map (f %1) [%1]) s)</code> form simply returned a flat list of hash-maps with the keys being the result of applying the given function to the element, and the values being the elements themselves. Beautifully simple, in the philosophy of focusing on performing just one task.</p><p>And then the myriad hash-maps were gathered together with <code>merge-with</code> using the <code>concat</code> function to resolve same-key clashes (in other words, &quot;just group them together&quot;).</p><p>Taking the first of the puzzle's unit tests as an example, here's what stage one (pre <code>merge-with</code>) looks like. This:</p><pre class="language-clojure"><code class="language-clojure"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">fn</span> <span class="token punctuation">[</span>f s<span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token keyword">map</span> <span class="token operator">#</span><span class="token punctuation">(</span><span class="token keyword">hash-map</span> <span class="token punctuation">(</span><span class="token function">f</span> %<span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>%<span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> s<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">#</span><span class="token punctuation">(</span><span class="token keyword">></span> % <span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">1</span> <span class="token number">3</span> <span class="token number">6</span> <span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>produces this:</p><pre class="language-clojure"><code class="language-clojure"><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token boolean">false</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token boolean">false</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token boolean">true</span> <span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token boolean">true</span> <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>Then applying the <code>merge-with concat</code> we get the result:</p><pre class="language-clojure"><code class="language-clojure"><span class="token punctuation">{</span><span class="token boolean">false</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token boolean">true</span> <span class="token punctuation">(</span><span class="token number">6</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>Lovely. I'm still on my journey to enlightenment, and am enjoying learning about functions such as <code>merge-with</code> on the way.</p></main><aside class="post__aside"><div class="post__tags"><a href="/tags/language-ramblings/">#language-ramblings</a></div><style>.utterances {
  margin-left: inherit !important;
}</style><script src="https://utteranc.es/client.js" repo="qmacro/qmacro.github.io" issue-term="title" crossorigin="anonymous" async></script><nav class="post__pagination"><a href="/blog/posts/2016/04/13/finding-a-wonderland-number/"><span>←</span> <span>Finding a wonderland number</span> </a><a href="/blog/posts/2016/04/10/&quot;fiux2&quot;-week-7-build-your-own-sap-fiori-app/"><span>&quot;fiux2&quot; Week 7 - Build Your Own SAP Fiori App</span> <span>→</span></a></nav></aside></article></main><footer class="footer"><div class="footer__content"><ul class="hero__social-links"><li><a rel="me" href="https://github.com/qmacro" target="_blank" rel="noopener noreferrer">GitHub</a></li><li><a rel="me" href="https://www.youtube.com/djadams-qmacro" target="_blank" rel="noopener noreferrer">YouTube</a></li><li><a rel="me" href="https://twitter.com/qmacro" target="_blank" rel="noopener noreferrer">Twitter</a></li><li><a rel="me" href="https://hachyderm.io/@qmacro" target="_blank" rel="noopener noreferrer">Mastodon</a></li><li><a href="/feed.xml" target="_blank" rel="noopener noreferrer">RSS</a></li></ul></div></footer></div><script src="/assets/main.31d6cfe0d16ae931b73c.js"></script></body></html>