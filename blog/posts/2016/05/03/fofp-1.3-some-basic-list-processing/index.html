<!doctype html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="canonical" href="https://qmacro.org/blog/posts/2016/05/03/fofp-1.3-some-basic-list-processing/"><link href="/assets/main.d44a8693a615cc267cd3.css" rel="stylesheet"><link rel="preconnect" href="https://fonts.gstatic.com"><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans&display=swap" rel="stylesheet"><title>FOFP 1.3 Some basic list processing | DJ Adams</title><link rel="icon" type="“image/x-icon”" href="/images/favicon.ico"><meta property="og:title" content="FOFP 1.3 Some basic list processing"><meta property="og:site_name" content="DJ Adams"><meta property="og:type" content="website"><meta property="og:url" content="https://qmacro.org/blog/posts/2016/05/03/fofp-1.3-some-basic-list-processing/"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:creator" content="@qmacro"><meta name="description" content="FOFP 1.3 Some basic list processing 03 May 2016 | 3 min read Part of the Fundamentals of Functional Programming document. Prev: FOFP 1.2..."><meta property="og:description" content="FOFP 1.3 Some basic list processing 03 May 2016 | 3 min read Part of the Fundamentals of Functional Programming document. Prev: FOFP 1.2..."><meta name="description" content="FOFP 1.3 Some basic list processing 03 May 2016 | 3 min read Part of the Fundamentals of Functional Programming document. Prev: FOFP 1.2..."><meta property="og:image" content="https://qmacro.org/images/site-image.png"><meta name="twitter:image" content="https://qmacro.org/images/site-image.png"><script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script><script>mermaid.initialize({startOnLoad:true});</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-4WQKBG0L4Y"></script><script>window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-4WQKBG0L4Y');</script></head><body><div class="layout-wrapper"><header class="header"><div class="header__content"><h1 class="site-title"><a href="/">DJ Adams</a></h1><nav class="nav"><ul class="nav__list"><li class="nav-item"><a href="/about">About Me</a></li><li class="nav-item"><a href="/talks">Talks</a></li><li class="nav-item"><a href="/blog">Blog</a></li><li class="nav-item"><a href="/feed.xml">Feed</a></li></ul></nav></div></header><main class="main"><article class="post"><header class="post__header"><h1>FOFP 1.3 Some basic list processing</h1><div class="post__details"><time datetime="2016-05-03">03 May 2016 </time><span>| </span><span>3 min read</span></div></header><main class="post__content"><p>Part of the <a href="/blog/posts/2016/05/03/fofp-fundamentals-of-functional-programming/">Fundamentals of Functional Programming</a> document.</p><p>Prev: <a href="/blog/posts/2016/05/03/fofp-1.2-trying-things-out">FOFP 1.2 Trying things out</a></p><p>Let's explore the difference between imperative and functional programming approaches with the simple processing of a list of integers 1, 2, 3, 4, 5. We want to turn them into their &quot;squared&quot; equivalents 1, 4, 9, 16, 25.</p><p>Create a list of integers, using the array literal syntax, like this:</p><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">var</span> nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><h2>First attempt</h2><p>A typical imperative approach to creating the squares might look like this:</p><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">var</span> i<span class="token punctuation">;</span><br><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><span class="token comment">// 25</span></code></pre><p>This pattern is very familiar. And it's very mechanical. We're giving very precise instructions on how to achieve the goal.</p><p>There's nothing wrong with that per se. It's just a little, well, <em>mechanical</em>. And even in this trivial example, there are a number of things that will tax us:</p><ul><li><p>we are iterating through the list of integers in <code>nums</code> using an array index lookup. For that we need to declare and maintain a variable <code>i</code>, initialising it to zero at the outset (<code>i = 0</code>), and incrementing it by one each time around the loop (<code>i++</code>). So we have to keep that state in our head as we read, or (worse) want to modify that code.</p></li><li><p>we have to address the number of items in the list (<code>nums.length</code>) explicitly, so as to be able to finish the looping when we reach the end of the list.</p></li><li><p>inside the loop, we have to use the array index explicitly (<code>[i]</code>) each time we want to refer to the value of the list item currently being processed. This just adds to the cognitive noise that we have to deal with, on top of remembering that <code>i</code> is changing each time.</p></li><li><p>The <code>for</code> statement actually evaluates to something, which we see here is 25 - the last value computed inside the block. Sort of makes sense, but only a little.</p></li></ul><p>So after executing this, we have what (we think) we wanted:</p><pre class="language-javascript"><code class="language-javascript">nums<br><span class="token comment">// [1, 4, 9, 16, 25]</span></code></pre><p>But perhaps the biggest problem is that if we run this a second time, we don't get the same result:</p><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">var</span> i<span class="token punctuation">;</span><br><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><span class="token comment">// 625</span></code></pre><p>625? What's going on? Well notice that we're mutating values inside the <code>nums</code> list. So after the first time, the values inside <code>nums</code> are the squares, i.e. 1, 4, 9, 16 and 25. So when we run it again, we're squaring those values, with these results:</p><pre class="language-javascript"><code class="language-javascript">nums<br><span class="token comment">// [1, 16, 81, 256, 625]</span></code></pre><p>Ouch.</p><p>Because state is being mutated, the program becomes harder to follow, harder to reason about.</p><h2>Second attempt</h2><p>So let's have another crack at this. Instead of mutating the values inside <code>num</code>, we'll produce the output in another list, and keep the original list untouched. Before we start, let's put our input back to what it was:</p><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">var</span> nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><p>Now we'll create a new empty array <code>squares</code>, and push each square value into that inside the loop:</p><pre class="language-javascript"><code class="language-javascript"><span class="token keyword">var</span> i<span class="token punctuation">;</span><br><span class="token keyword">var</span> squares <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br><span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  squares<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">*</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><br><span class="token comment">// 5</span></code></pre><p><em>Those eagle-eyed readers among you will perhaps be wondering about the value <code>5</code> here. It's not the same as what we had earlier. But it's consistent, in that it's the value of the last-executed statement inside the loop. Before, that was the result of a multiplication. Here, it's the result of a call to <code>push</code>, which returns the new length of the array being operated upon.</em></p><p>Anyway, after execution, <code>nums</code> is still what it was, and the output values are now to be found in <code>squares</code>:</p><pre class="language-javascript"><code class="language-javascript">squares<br><span class="token comment">// [1, 4, 9, 16, 25]</span></code></pre><p>That's an improvement. We have to be a bit careful if we want to re-run the code, because we need to make sure we include the initialising of the <code>squares</code> array before the loop, so as not to end up with this situation:</p><pre class="language-javascript"><code class="language-javascript">squares<br><span class="token comment">// [1, 4, 9, 16, 25, 1, 4, 9, 16, 25]</span></code></pre><p>But the improvement comes at a cost - yet more stuff to hold in your head, this time about the <code>squares</code> array.</p><p>Next: <a href="/blog/posts/2016/05/03/fofp-1.4-a-different-approach-with-map">FOFP 1.4 A different approach with map</a></p></main><aside class="post__aside"><div class="post__tags"><a href="/tags/language-ramblings/">#language-ramblings</a></div><style>.utterances {
  margin-left: inherit !important;
}</style><script src="https://utteranc.es/client.js" repo="qmacro/qmacro.github.io" issue-term="title" crossorigin="anonymous" async></script><nav class="post__pagination"><a href="/blog/posts/2016/05/03/fofp-1.4-a-different-approach-with-map/"><span>←</span> <span>FOFP 1.4 A different approach with map</span> </a><a href="/blog/posts/2016/05/03/fofp-1.2-trying-things-out/"><span>FOFP 1.2 Trying things out</span> <span>→</span></a></nav></aside></article></main><footer class="footer"><div class="footer__content"><ul class="hero__social-links"><li><a rel="me" href="https://github.com/qmacro" target="_blank" rel="noopener noreferrer">GitHub</a></li><li><a rel="me" href="https://www.youtube.com/djadams-qmacro" target="_blank" rel="noopener noreferrer">YouTube</a></li><li><a rel="me" href="https://twitter.com/qmacro" target="_blank" rel="noopener noreferrer">Twitter</a></li><li><a rel="me" href="https://hachyderm.io/@qmacro" target="_blank" rel="noopener noreferrer">Mastodon</a></li><li><a href="/feed.xml" target="_blank" rel="noopener noreferrer">RSS</a></li></ul></div></footer></div><script src="/assets/main.31d6cfe0d16ae931b73c.js"></script></body></html>