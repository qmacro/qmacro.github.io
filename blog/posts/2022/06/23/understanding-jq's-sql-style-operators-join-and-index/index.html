<!doctype html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="canonical" href="https://qmacro.org/blog/posts/2022/06/23/understanding-jq&#39;s-sql-style-operators-join-and-index/"><link rel="alternate" type="application/atom+xml" title="DJ's Weblog - Feed" href="https://qmacro.org/feed.xml"><link href="/assets/main.cd680003476b1a634b05.css" rel="stylesheet"><link rel="preconnect" href="https://fonts.gstatic.com"><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans&display=swap" rel="stylesheet"><title>Understanding jq&#39;s SQL style operators JOIN and INDEX | DJ Adams</title><link rel="icon" type="“image/x-icon”" href="/images/favicon.ico"><meta property="og:title" content="Understanding jq&#39;s SQL style operators JOIN and INDEX"><meta property="og:site_name" content="DJ Adams"><meta property="og:type" content="website"><meta property="og:url" content="https://qmacro.org/blog/posts/2022/06/23/understanding-jq&#39;s-sql-style-operators-join-and-index/"><meta name="description" content="Understanding jq&amp;#39;s SQL style operators JOIN and INDEX 23 Jun 2022 | 7 min read In this post I explore a couple of new (to me) operators..."><meta property="og:description" content="Understanding jq&amp;#39;s SQL style operators JOIN and INDEX 23 Jun 2022 | 7 min read In this post I explore a couple of new (to me) operators..."><meta name="description" content="Understanding jq&amp;#39;s SQL style operators JOIN and INDEX 23 Jun 2022 | 7 min read In this post I explore a couple of new (to me) operators..."><meta property="og:image" content="https://qmacro.org/images/site-image.png"><script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script><script>mermaid.initialize({startOnLoad:true});</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-4WQKBG0L4Y"></script><script>window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-4WQKBG0L4Y');</script></head><body><div class="layout-wrapper"><header class="header"><div class="header__content"><h1 class="site-title"><a href="/">DJ Adams</a></h1><nav class="nav"><ul class="nav__list"><li class="nav-item"><a href="/about">About Me</a></li><li class="nav-item"><a href="/blog">Blog</a></li><li class="nav-item"><a href="/feed.xml">Feed</a></li></ul></nav></div></header><main class="main"><article class="post"><header class="post__header"><h1>Understanding jq&#39;s SQL style operators JOIN and INDEX</h1><div class="post__details"><time datetime="2022-06-23">23 Jun 2022 </time><span>| </span><span>7 min read</span></div></header><main class="post__content"><p>In this post I explore a couple of new (to me) operators in jq's arsenal: <code>JOIN</code> and <code>INDEX</code>, based on an answer to a question that I came across on Stack Overflow.</p><p>The <a href="https://stackoverflow.com/a/72725480/384366">answer</a> was in response to a question (<a href="https://stackoverflow.com/q/72723706/384366">JQ: How to join arrays by key?</a>) about how to merge two arrays of related information. I found it interesting and it also introduced me to a couple of operators in <code>jq</code> that I'd hitherto not come across. There's a section in the manual titled <a href="https://stedolan.github.io/jq/manual/#SQL-StyleOperators">SQL-Style Operators</a> that describe them.</p><p>I could have sworn I'd never seen this section before, so had instead looked to see if they were defined in the <a href="https://github.com/stedolan/jq/blob/a9f97e9e61a910a374a5d768244e8ad63f407d3e/src/builtin.jq">builtin.jq</a> file, where <code>jq</code> functions, filters and operators are defined ... in <code>jq</code>. I did come across them there, and their definitions helped me understand them too. I thought I'd explore them in this blog post, &quot;out loud&quot;, as it were.</p><h2>Test data</h2><p>Throughout this post I'm going to use the data described in the Stack Overflow question, which (after a bit of tidying up) looks like this (and which I've put into a file called <code>data.json</code>):</p><pre class="language-json"><code class="language-json"><span class="token punctuation">{</span><br>  <span class="token property">"weights"</span><span class="token operator">:</span> <span class="token punctuation">[</span><br>    <span class="token punctuation">{</span><br>      <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"apple"</span><span class="token punctuation">,</span><br>      <span class="token property">"weight"</span><span class="token operator">:</span> <span class="token number">200</span><br>    <span class="token punctuation">}</span><span class="token punctuation">,</span><br>    <span class="token punctuation">{</span><br>      <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"tomato"</span><span class="token punctuation">,</span><br>      <span class="token property">"weight"</span><span class="token operator">:</span> <span class="token number">100</span><br>    <span class="token punctuation">}</span><br>  <span class="token punctuation">]</span><span class="token punctuation">,</span><br>  <span class="token property">"categories"</span><span class="token operator">:</span> <span class="token punctuation">[</span><br>    <span class="token punctuation">{</span><br>      <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"apple"</span><span class="token punctuation">,</span><br>      <span class="token property">"category"</span><span class="token operator">:</span> <span class="token string">"fruit"</span><br>    <span class="token punctuation">}</span><span class="token punctuation">,</span><br>    <span class="token punctuation">{</span><br>      <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"tomato"</span><span class="token punctuation">,</span><br>      <span class="token property">"category"</span><span class="token operator">:</span> <span class="token string">"vegetable"</span><br>    <span class="token punctuation">}</span><br>  <span class="token punctuation">]</span><br><span class="token punctuation">}</span></code></pre><h2>Starting with the definitions in builtin.jq</h2><p>I want to start by staring at the definitions of the two operators in <code>builtin.jq</code>. Here's the section of code, with a few empty lines added for readability:</p><pre class="language-jq"><code class="language-jq"><span class="token keyword">def</span> <span class="token function">INDEX</span><span class="token punctuation">(</span>stream<span class="token punctuation">;</span> idx_expr<span class="token punctuation">)</span><span class="token punctuation">:</span><br>  <span class="token keyword">reduce</span> stream <span class="token keyword">as</span> <span class="token variable">$row</span> <span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token variable">$row</span><span class="token operator pipe">|</span>idx_expr<span class="token operator pipe">|</span>tostring<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$row</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token keyword">def</span> <span class="token function">INDEX</span><span class="token punctuation">(</span>idx_expr<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token c-style-function function">INDEX</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> idx_expr<span class="token punctuation">)</span><span class="token punctuation">;</span><br><br><span class="token keyword">def</span> <span class="token function">JOIN</span><span class="token punctuation">(</span><span class="token variable">$idx</span><span class="token punctuation">;</span> idx_expr<span class="token punctuation">)</span><span class="token punctuation">:</span><br>  <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator pipe">|</span> <span class="token punctuation">[</span><span class="token dot important">.</span><span class="token punctuation">,</span> <span class="token variable">$idx</span><span class="token punctuation">[</span>idx_expr<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br><br><span class="token keyword">def</span> <span class="token function">JOIN</span><span class="token punctuation">(</span><span class="token variable">$idx</span><span class="token punctuation">;</span> stream<span class="token punctuation">;</span> idx_expr<span class="token punctuation">)</span><span class="token punctuation">:</span><br>  stream <span class="token operator pipe">|</span> <span class="token punctuation">[</span><span class="token dot important">.</span><span class="token punctuation">,</span> <span class="token variable">$idx</span><span class="token punctuation">[</span>idx_expr<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br><br><span class="token keyword">def</span> <span class="token function">JOIN</span><span class="token punctuation">(</span><span class="token variable">$idx</span><span class="token punctuation">;</span> stream<span class="token punctuation">;</span> idx_expr<span class="token punctuation">;</span> join_expr<span class="token punctuation">)</span><span class="token punctuation">:</span><br>  stream <span class="token operator pipe">|</span> <span class="token punctuation">[</span><span class="token dot important">.</span><span class="token punctuation">,</span> <span class="token variable">$idx</span><span class="token punctuation">[</span>idx_expr<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator pipe">|</span> join_expr<span class="token punctuation">;</span></code></pre><p>The first thing I see is that there are multiple definitions of both <code>INDEX</code> and <code>JOIN</code>, each with different numbers of parameters. In various discussions, I've seen this represented in the way folks refer to them. For example, there are three definitions of <code>JOIN</code>, one with two parameters (<code>JOIN($idx; idx_expr)</code>), one with three (<code>JOIN($idx; stream; idx_expr)</code>) and one with four (<code>JOIN($idx; stream; idx_expr; join_expr)</code>). These are referred to, respectively, like this: <code>JOIN/2</code>, <code>JOIN/3</code> and <code>JOIN/4</code>, where the number represents the <a href="https://en.wikipedia.org/wiki/Arity">arity</a>.</p><h3>INDEX definitions</h3><p>So I set off on my exploration, looking at the two definitions of <code>INDEX</code>.</p><h4>INDEX/2</h4><p>Starting with <code>INDEX/2</code>, I see:</p><pre class="language-jq"><code class="language-jq"><span class="token keyword">def</span> <span class="token function">INDEX</span><span class="token punctuation">(</span>stream<span class="token punctuation">;</span> idx_expr<span class="token punctuation">)</span><span class="token punctuation">:</span><br>  <span class="token keyword">reduce</span> stream <span class="token keyword">as</span> <span class="token variable">$row</span> <span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token variable">$row</span><span class="token operator pipe">|</span>idx_expr<span class="token operator pipe">|</span>tostring<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$row</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Earlier this year I managed to get to grips with the <code>reduce</code> function in <code>jq</code>, and wrote about it in this post: <a href="/blog/posts/2022/03/25/understanding-jq's-reduce-function/">Understanding jq's reduce function</a>. With that understanding, the call to <code>reduce</code> here doesn't seem as impenetrable. Here's how I understand it, in pseudo-JS:</p><pre class="language-javascript"><code class="language-javascript">stream<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">accumulator<span class="token punctuation">,</span> row</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><br>  accumulator<span class="token punctuation">[</span><span class="token operator">&lt;</span>result <span class="token keyword">of</span> determining the idx_expr<span class="token operator">></span><span class="token punctuation">]</span> <span class="token operator">=</span> row<br>  <span class="token keyword">return</span> accumulator<br><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>In other words, this <code>reduce</code> invocation iterates through the elements of <code>stream</code>, and for each one, represented by <code>$row</code> each time, adds a new entry to an object, which is empty to start with (<code>{}</code>), where the value of the entry is the element itself (<code>$row</code>) and the key is determined by applying the <code>idx_expr</code> expression to the row, and then stringifying the result (<code>tostring</code>).</p><p>What happens if I invoke such an <code>INDEX</code> operator on the test data above? How about:</p><pre class="language-bash"><code class="language-bash">jq <span class="token string">'INDEX(.categories[]; .name)'</span> data.json</code></pre><p>First, <code>.categories[]</code> is used as the &quot;stream&quot;, i.e. a stream of values - in this case the values are objects each with <code>name</code> and <code>category</code> keys, like this:</p><pre class="language-json"><code class="language-json"><span class="token punctuation">{</span><br>  <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"apple"</span><span class="token punctuation">,</span><br>  <span class="token property">"category"</span><span class="token operator">:</span> <span class="token string">"fruit"</span><br><span class="token punctuation">}</span><span class="token punctuation">,</span><br><span class="token punctuation">{</span><br>  <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"tomato"</span><span class="token punctuation">,</span><br>  <span class="token property">"category"</span><span class="token operator">:</span> <span class="token string">"vegetable"</span><br><span class="token punctuation">}</span></code></pre><p>In this invocation of <code>INDEX</code>, <code>.name</code> is set as the <code>idx_expr</code> (the expression for determining what the index, or key, is going to be). So for the first element (the object with the &quot;apple&quot; details) the <code>idx_expr</code> of <code>.name</code> gives &quot;apple&quot;.</p><p>The result of invoking <code>INDEX(.categories[], .name)</code> then, is this:</p><pre class="language-json"><code class="language-json"><span class="token punctuation">{</span><br>  <span class="token property">"apple"</span><span class="token operator">:</span> <span class="token punctuation">{</span><br>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"apple"</span><span class="token punctuation">,</span><br>    <span class="token property">"category"</span><span class="token operator">:</span> <span class="token string">"fruit"</span><br>  <span class="token punctuation">}</span><span class="token punctuation">,</span><br>  <span class="token property">"tomato"</span><span class="token operator">:</span> <span class="token punctuation">{</span><br>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"tomato"</span><span class="token punctuation">,</span><br>    <span class="token property">"category"</span><span class="token operator">:</span> <span class="token string">"vegetable"</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><p>So this has turned a stream of objects into a single object with keys (&quot;indices&quot;, I guess) built from values in the original objects.</p><h4>INDEX/1</h4><p>And <code>INDEX/1</code> is just a call to <code>INDEX/2</code> with the first parameter set to <code>.[]</code>:</p><pre class="language-jq"><code class="language-jq"><span class="token keyword">def</span> <span class="token function">INDEX</span><span class="token punctuation">(</span>idx_expr<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token c-style-function function">INDEX</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> idx_expr<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>This feels like a nice convenience redefinition, and I get the feeling that this version might see more use in a pipeline context. Looking at how it might be used, with the same data, I get this:</p><pre class="language-bash"><code class="language-bash">jq <span class="token string">'.categories | INDEX(.name)'</span> data.json</code></pre><p>This produces the same thing:</p><pre class="language-json"><code class="language-json"><span class="token punctuation">{</span><br>  <span class="token property">"apple"</span><span class="token operator">:</span> <span class="token punctuation">{</span><br>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"apple"</span><span class="token punctuation">,</span><br>    <span class="token property">"category"</span><span class="token operator">:</span> <span class="token string">"fruit"</span><br>  <span class="token punctuation">}</span><span class="token punctuation">,</span><br>  <span class="token property">"tomato"</span><span class="token operator">:</span> <span class="token punctuation">{</span><br>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"tomato"</span><span class="token punctuation">,</span><br>    <span class="token property">"category"</span><span class="token operator">:</span> <span class="token string">"vegetable"</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><p>Implicitly what's piped into <code>INDEX/1</code> has to be an array, I guess, which is why the left hand side of the pipe here is <code>.categories</code>, rather than <code>.categories[]</code> which would have caused multiple invocations of <code>INDEX</code>, one for every array element. Moreover, <code>.categories</code> is more appropriate because the first thing that <code>INDEX/1</code> does is invoke the <a href="https://stedolan.github.io/jq/manual/#Array/ObjectValueIterator:.%5B%5D">array iterator</a> on it (i.e. the <code>.[]</code> in <code>INDEX(.[]; idx_expr)</code>).</p><p>So in summary, <code>INDEX</code> can be used to create a &quot;lookup&quot; object where the keys are determined based on what you specify to pick out of the incoming stream.</p><h3>JOIN definitions</h3><p>Now I can turn my attention to each of the definitions of <code>JOIN</code>, and there are three: <code>JOIN/2</code>, <code>JOIN/3</code> and <code>JOIN/4</code>:</p><pre class="language-jq"><code class="language-jq"><span class="token keyword">def</span> <span class="token function">JOIN</span><span class="token punctuation">(</span><span class="token variable">$idx</span><span class="token punctuation">;</span> idx_expr<span class="token punctuation">)</span><span class="token punctuation">:</span><br>  <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator pipe">|</span> <span class="token punctuation">[</span><span class="token dot important">.</span><span class="token punctuation">,</span> <span class="token variable">$idx</span><span class="token punctuation">[</span>idx_expr<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br><br><span class="token keyword">def</span> <span class="token function">JOIN</span><span class="token punctuation">(</span><span class="token variable">$idx</span><span class="token punctuation">;</span> stream<span class="token punctuation">;</span> idx_expr<span class="token punctuation">)</span><span class="token punctuation">:</span><br>  stream <span class="token operator pipe">|</span> <span class="token punctuation">[</span><span class="token dot important">.</span><span class="token punctuation">,</span> <span class="token variable">$idx</span><span class="token punctuation">[</span>idx_expr<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br><br><span class="token keyword">def</span> <span class="token function">JOIN</span><span class="token punctuation">(</span><span class="token variable">$idx</span><span class="token punctuation">;</span> stream<span class="token punctuation">;</span> idx_expr<span class="token punctuation">;</span> join_expr<span class="token punctuation">)</span><span class="token punctuation">:</span><br>  stream <span class="token operator pipe">|</span> <span class="token punctuation">[</span><span class="token dot important">.</span><span class="token punctuation">,</span> <span class="token variable">$idx</span><span class="token punctuation">[</span>idx_expr<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator pipe">|</span> join_expr<span class="token punctuation">;</span></code></pre><p>I'll start by examining <code>JOIN/4</code>.</p><h4>JOIN/4</h4><p>As the arity identification suggests, this version takes four parameters. Even though the definition is just above, it's worth repeating it here, to be able to stare at for a minute or two:</p><pre class="language-jq"><code class="language-jq"><span class="token keyword">def</span> <span class="token function">JOIN</span><span class="token punctuation">(</span><span class="token variable">$idx</span><span class="token punctuation">;</span> stream<span class="token punctuation">;</span> idx_expr<span class="token punctuation">;</span> join_expr<span class="token punctuation">)</span><span class="token punctuation">:</span><br>  stream <span class="token operator pipe">|</span> <span class="token punctuation">[</span><span class="token dot important">.</span><span class="token punctuation">,</span> <span class="token variable">$idx</span><span class="token punctuation">[</span>idx_expr<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator pipe">|</span> join_expr<span class="token punctuation">;</span></code></pre><p>It's described in the manual thus (emphasis mine, to refer to the parameters):</p><blockquote><p>This builtin joins the values from the <strong>given stream</strong> to the <strong>given index</strong>. The index's keys are computed by applying the given <strong>index expression</strong> to each value from the given stream. An array of the value in the stream and the corresponding value from the index is fed to the given <strong>join expression</strong> to produce each result.</p></blockquote><p>Here's an example call that I'll run shortly:</p><pre class="language-jq"><code class="language-jq"><span class="token c-style-function function">INDEX</span><span class="token punctuation">(</span><span class="token punctuation">.</span>categories<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token variable">$categories</span><br><span class="token operator pipe">|</span> <span class="token c-style-function function">JOIN</span><span class="token punctuation">(</span><span class="token variable">$categories</span><span class="token punctuation">;</span> <span class="token punctuation">.</span>weights<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">.</span>name<span class="token punctuation">;</span> add<span class="token punctuation">)</span></code></pre><p>Examining each of the parameters in turn, in the context of this description, we have the following values provided for the following parameters:</p><p><strong><code>$idx &lt;-- $categories</code> (&quot;the given index&quot;)</strong></p><p>An example of such an index is what's produced by the <code>INDEX</code> builtin we looked at earlier:</p><pre class="language-json"><code class="language-json"><span class="token punctuation">{</span><br>  <span class="token property">"apple"</span><span class="token operator">:</span> <span class="token punctuation">{</span><br>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"apple"</span><span class="token punctuation">,</span><br>    <span class="token property">"category"</span><span class="token operator">:</span> <span class="token string">"fruit"</span><br>  <span class="token punctuation">}</span><span class="token punctuation">,</span><br>  <span class="token property">"tomato"</span><span class="token operator">:</span> <span class="token punctuation">{</span><br>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"tomato"</span><span class="token punctuation">,</span><br>    <span class="token property">"category"</span><span class="token operator">:</span> <span class="token string">"vegetable"</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><p>In the example call, this is referred to via <code>$categories</code> which is a symbolic binding to the result of <code>INDEX(.categories[]; .name)</code>.</p><p><strong><code>stream &lt;-- .weights[]</code> (the &quot;given stream&quot;)</strong></p><p>This is a sequence, usually of objects. In the example call, I'm using <code>.weights[]</code> as the stream, i.e. the objects describing food and their respective weights:</p><pre class="language-json"><code class="language-json"><span class="token punctuation">{</span><br>  <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"apple"</span><span class="token punctuation">,</span><br>  <span class="token property">"weight"</span><span class="token operator">:</span> <span class="token number">200</span><br><span class="token punctuation">}</span><span class="token punctuation">,</span><br><span class="token punctuation">{</span><br>  <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"tomato"</span><span class="token punctuation">,</span><br>  <span class="token property">"weight"</span><span class="token operator">:</span> <span class="token number">100</span><br><span class="token punctuation">}</span></code></pre><p><strong><code>idx_expr &lt;-- .name</code> (the &quot;given index expression&quot;)</strong></p><p>This is effectively what to use, in the stream, to look up the corresponding data in the index. In this case, <code>.name</code> is appropriate, as it has the values which are used as keys (&quot;apple&quot; and &quot;tomato&quot;) in the index.</p><p><strong><code>join_expr &lt;-- add</code> (the &quot;given join expression&quot;)</strong></p><p>In order to understand why this parameter exists, it's necessary to have in mind what would be produced before such a join. For every stream object, after a successful lookup of a corresponding object in the index based on the index expression that points to a value in that stream object, what's produced is an array of two objects.</p><p>Here's an example, again based on the call I'll make, which is:</p><pre class="language-jq"><code class="language-jq"><span class="token c-style-function function">INDEX</span><span class="token punctuation">(</span><span class="token punctuation">.</span>categories<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token variable">$categories</span><br><span class="token operator pipe">|</span> <span class="token c-style-function function">JOIN</span><span class="token punctuation">(</span><span class="token variable">$categories</span><span class="token punctuation">;</span> <span class="token punctuation">.</span>weights<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">.</span>name<span class="token punctuation">;</span> add<span class="token punctuation">)</span></code></pre><p>The first object in the <code>.weights[]</code> stream is:</p><pre class="language-json"><code class="language-json"><span class="token punctuation">{</span><br>  <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"apple"</span><span class="token punctuation">,</span><br>  <span class="token property">"weight"</span><span class="token operator">:</span> <span class="token number">200</span><br><span class="token punctuation">}</span></code></pre><p>From this, the value of <code>.name</code> is &quot;apple&quot;, and this is used to look for an entry in the <code>$categories</code> index, and one is found - this one:</p><pre class="language-json"><code class="language-json"><span class="token property">"apple"</span><span class="token operator">:</span> <span class="token punctuation">{</span><br>  <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"apple"</span><span class="token punctuation">,</span><br>  <span class="token property">"category"</span><span class="token operator">:</span> <span class="token string">"fruit"</span><br><span class="token punctuation">}</span></code></pre><p>Note that what's returned is not that entire structure, but just the value that &quot;apple&quot; points to:</p><pre class="language-json"><code class="language-json"><span class="token punctuation">{</span><br>  <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"apple"</span><span class="token punctuation">,</span><br>  <span class="token property">"category"</span><span class="token operator">:</span> <span class="token string">"fruit"</span><br><span class="token punctuation">}</span></code></pre><p>What happens now is described in the last sentence from the manual description:</p><blockquote><p>An array of the value in the stream and the corresponding value from the index is fed to the given join expression to produce each result.</p></blockquote><p>So looking at the first part of that sentence, this is what's produced - an array like this:</p><pre class="language-json"><code class="language-json"><span class="token punctuation">[</span><br>  <span class="token punctuation">{</span><br>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"apple"</span><span class="token punctuation">,</span><br>    <span class="token property">"weight"</span><span class="token operator">:</span> <span class="token number">200</span><br>  <span class="token punctuation">}</span><span class="token punctuation">,</span><br>  <span class="token punctuation">{</span><br>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"apple"</span><span class="token punctuation">,</span><br>    <span class="token property">"category"</span><span class="token operator">:</span> <span class="token string">"fruit"</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">]</span></code></pre><p>With the knowledge of what's produced before the <code>join_expr</code> is employed, it is now clearer as to why such a join expression exists as a parameter.</p><p>In this example case it makes most sense to merge the two objects, and the multi-faceted <a href="https://stedolan.github.io/jq/manual/#add">add</a> filter is perfect for this, producing - from that array of two objects - this single object:</p><pre class="language-json"><code class="language-json"><span class="token punctuation">{</span><br>  <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"apple"</span><span class="token punctuation">,</span><br>  <span class="token property">"weight"</span><span class="token operator">:</span> <span class="token number">200</span><span class="token punctuation">,</span><br>  <span class="token property">"category"</span><span class="token operator">:</span> <span class="token string">"fruit"</span><br><span class="token punctuation">}</span></code></pre><p>Joining the pairs of objects in one way or another is very likely to be what one desires.</p><h4>JOIN/3</h4><p>Following on from <code>JOIN/4</code>, it's easier to examine the other arity versions, starting with this one:</p><pre class="language-jq"><code class="language-jq"><span class="token keyword">def</span> <span class="token function">JOIN</span><span class="token punctuation">(</span><span class="token variable">$idx</span><span class="token punctuation">;</span> stream<span class="token punctuation">;</span> idx_expr<span class="token punctuation">)</span><span class="token punctuation">:</span><br>  stream <span class="token operator pipe">|</span> <span class="token punctuation">[</span><span class="token dot important">.</span><span class="token punctuation">,</span> <span class="token variable">$idx</span><span class="token punctuation">[</span>idx_expr<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><p>From the definition, the difference to <code>JOIN/4</code> is just that the <code>join_expr</code> parameter is omitted, and there's no pipe into such an expression at the end. The equivalent of this in a <code>JOIN/4</code> context would be to specify <code>.</code> as the <code>join_expr</code>. I guess it's nicer not have to specify that if you don't want any special joining of the pairs of elements in your result.</p><h4>JOIN/2</h4><p>This is an even more cut down version, in that not only is there no <code>join_expr</code> but there's also no explicit parameter for specifying the stream. Instead, one is expected to pipe that into such a call to <code>JOIN/2</code>. This is what the definition looks like, and one can see the <code>.[]</code> at the start which unwraps an assumed array to produce a stream that is then piped into the main definition:</p><pre class="language-jq"><code class="language-jq"><span class="token keyword">def</span> <span class="token function">JOIN</span><span class="token punctuation">(</span><span class="token variable">$idx</span><span class="token punctuation">;</span> idx_expr<span class="token punctuation">)</span><span class="token punctuation">:</span><br>  <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator pipe">|</span> <span class="token punctuation">[</span><span class="token dot important">.</span><span class="token punctuation">,</span> <span class="token variable">$idx</span><span class="token punctuation">[</span>idx_expr<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><p>Note also in this arity version that the results are returned within an outer array via the <code>[...]</code> array construction that wraps the entire definition.</p><h2>Walking through the entire call</h2><p>Now I've examined the different definitions, it's time to finish off with putting the new knowledge to work, to better understand the <a href="https://stackoverflow.com/questions/72723706/jq-how-to-join-arrays-by-key/72725480#72725480">answer</a> given, which centres around this <code>jq</code> expression and operates on the same test data I described earlier:</p><pre class="language-jq"><code class="language-jq"><span class="token punctuation">{</span><span class="token property-literal property">weights</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token c-style-function function">JOIN</span><span class="token punctuation">(</span><span class="token c-style-function function">INDEX</span><span class="token punctuation">(</span><span class="token punctuation">.</span>categories<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">.</span>weights<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">.</span>name<span class="token punctuation">;</span> add<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><p>With some whitespace, that expression looks like this, which might help us read it more easily and see that there's nothing we don't now know about:</p><pre class="language-jq"><code class="language-jq"><span class="token punctuation">{</span><br>  <span class="token property-literal property">weights</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><br>    <span class="token c-style-function function">JOIN</span><span class="token punctuation">(</span><br>      <span class="token c-style-function function">INDEX</span><span class="token punctuation">(</span> <span class="token punctuation">.</span>categories<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">.</span>name <span class="token punctuation">)</span><span class="token punctuation">;</span><br>      <span class="token punctuation">.</span>weights<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br>      <span class="token punctuation">.</span>name<span class="token punctuation">;</span><br>      add<br>    <span class="token punctuation">)</span><br>  <span class="token punctuation">]</span><br><span class="token punctuation">}</span></code></pre><p>The expression contains a call to <code>JOIN/4</code>, and the first parameter (the &quot;index&quot;) is actually a call to <code>INDEX/2</code>, which, as we know, given the test data, produces this:</p><pre class="language-json"><code class="language-json"><span class="token punctuation">{</span><br>  <span class="token property">"apple"</span><span class="token operator">:</span> <span class="token punctuation">{</span><br>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"apple"</span><span class="token punctuation">,</span><br>    <span class="token property">"category"</span><span class="token operator">:</span> <span class="token string">"fruit"</span><br>  <span class="token punctuation">}</span><span class="token punctuation">,</span><br>  <span class="token property">"tomato"</span><span class="token operator">:</span> <span class="token punctuation">{</span><br>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"tomato"</span><span class="token punctuation">,</span><br>    <span class="token property">"category"</span><span class="token operator">:</span> <span class="token string">"vegetable"</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span></code></pre><p>Then there's <code>.weights[]</code> specified for the &quot;stream&quot;, from which values for the &quot;index expression&quot; <code>.name</code> are used to look up data in the index. Finally, <code>add</code> is specified as what to use as the &quot;join expression&quot;. What's produced is a stream of values which are then enclosed in an array (<code>[...]</code>). This array is then returned as the value of a <code>weights</code> property inside an object that's constructed just to hold that property.</p><p>This entire <code>jq</code> filter, when applied to the test data, produces the following:</p><pre class="language-json"><code class="language-json"><span class="token punctuation">{</span><br>  <span class="token property">"weights"</span><span class="token operator">:</span> <span class="token punctuation">[</span><br>    <span class="token punctuation">{</span><br>      <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"apple"</span><span class="token punctuation">,</span><br>      <span class="token property">"weight"</span><span class="token operator">:</span> <span class="token number">200</span><span class="token punctuation">,</span><br>      <span class="token property">"category"</span><span class="token operator">:</span> <span class="token string">"fruit"</span><br>    <span class="token punctuation">}</span><span class="token punctuation">,</span><br>    <span class="token punctuation">{</span><br>      <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"tomato"</span><span class="token punctuation">,</span><br>      <span class="token property">"weight"</span><span class="token operator">:</span> <span class="token number">100</span><span class="token punctuation">,</span><br>      <span class="token property">"category"</span><span class="token operator">:</span> <span class="token string">"vegetable"</span><br>    <span class="token punctuation">}</span><br>  <span class="token punctuation">]</span><br><span class="token punctuation">}</span></code></pre><h2>Wrapping up</h2><p>Again, I've probably used too many words in my exploration, but perhaps it will help you in your understanding as you explore this area too.</p><p>This exploration was inspired by the great <a href="https://stackoverflow.com/a/72725480/384366">answer</a> by Stack Overflow user <a href="https://stackoverflow.com/users/2158479/pmf">pmf</a>.</p><p>If you're looking for another angle, and another example, there's <a href="https://stackoverflow.com/a/71107203/384366">another great answer</a> from the same user, to a related question <a href="https://stackoverflow.com/q/71106595/384366">Understanding jq JOIN()</a>.</p></main><aside class="post__aside"><div class="post__tags"><a href="/tags/jq/">#jq</a></div><style>.utterances {
  margin-left: inherit !important;
}</style><script src="https://utteranc.es/client.js" repo="qmacro/qmacro.github.io" issue-term="title" crossorigin="anonymous" async></script><nav class="post__pagination"><a href="/blog/posts/2022/10/28/untappd-data-with-jq-my-top-brewery-countries/"><span>←</span> <span>Untappd data with jq - my top brewery countries</span> </a><a href="/blog/posts/2022/06/16/summing-and-grouping-values-with-jq/"><span>Summing and grouping values with jq</span> <span>→</span></a></nav></aside></article></main><footer class="footer"><div class="footer__content"><ul class="hero__social-links"><li><a rel="me" href="https://github.com/qmacro" target="_blank" rel="noopener noreferrer">GitHub</a></li><li><a rel="me" href="https://www.youtube.com/djadams-qmacro" target="_blank" rel="noopener noreferrer">YouTube</a></li><li><a rel="me" href="https://www.linkedin.com/in/djadams/" target="_blank" rel="noopener noreferrer">LinkedIn</a></li><li><a rel="me" href="https://hachyderm.io/@qmacro" target="_blank" rel="noopener noreferrer">Mastodon</a></li><li><a href="/feed.xml" target="_blank" rel="noopener noreferrer">RSS</a></li></ul></div></footer></div><script src="/assets/main.31d6cfe0d16ae931b73c.js"></script></body></html>