<!doctype html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="canonical" href="https://qmacro.org/blog/posts/2022/05/02/some-thoughts-on-jq-and-statelessness/"><link href="/assets/main.c8613da530e0f001ce67.css" rel="stylesheet"><link rel="preconnect" href="https://fonts.gstatic.com"><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans&display=swap" rel="stylesheet"><title>Some thoughts on jq and statelessness | DJ Adams</title><link rel="icon" type="“image/x-icon”" href="/images/favicon.ico"><meta property="og:title" content="Some thoughts on jq and statelessness"><meta property="og:site_name" content="DJ Adams"><meta property="og:type" content="website"><meta property="og:url" content="https://qmacro.org/blog/posts/2022/05/02/some-thoughts-on-jq-and-statelessness/"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:creator" content="@qmacro"><meta name="description" content="Some thoughts on jq and statelessness 02 May 2022 | 4 min read I came across a great article via lobsters recently: Introducing zq: an..."><meta property="og:description" content="Some thoughts on jq and statelessness 02 May 2022 | 4 min read I came across a great article via lobsters recently: Introducing zq: an..."><meta name="description" content="Some thoughts on jq and statelessness 02 May 2022 | 4 min read I came across a great article via lobsters recently: Introducing zq: an..."><meta property="og:image" content="https://qmacro.org/images/DJA-head.png"><meta name="twitter:image" content="https://qmacro.org/images/DJA-head.png"><script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script><script>mermaid.initialize({startOnLoad:true});</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-4WQKBG0L4Y"></script><script>window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-4WQKBG0L4Y');</script></head><body><div class="layout-wrapper"><header class="header"><div class="header__content"><h1 class="site-title"><a href="/">DJ Adams</a></h1><nav class="nav"><ul class="nav__list"><li class="nav-item"><a href="/about">About Me</a></li><li class="nav-item"><a href="/talks">Talks</a></li><li class="nav-item"><a href="/blog">Blog</a></li><li class="nav-item"><a href="/feed.xml">Feed</a></li></ul></nav></div></header><main class="main"><article class="post"><header class="post__header"><h1>Some thoughts on jq and statelessness</h1><div class="post__details"><time datetime="2022-05-02">02 May 2022 </time><span>| </span><span>4 min read</span></div></header><main class="post__content"><p>I came across a great article <a href="https://lobste.rs/s/uhkwhn/introducing_zq_easier_faster">via lobsters</a> recently: <a href="https://www.brimdata.io/blog/introducing-zq/">Introducing zq: an Easier (and Faster) Alternative to jq</a>. I <a href="https://lobste.rs/s/uhkwhn/introducing_zq_easier_faster#c_ue6azr">posted</a> some brief thoughts on it over on the lobsters thread, and in the spirit of &quot;owning your own words&quot;, I thought I'd write them up here too.</p><p>I do like articles like this, that show and lay out the thinking behind the conclusion, and along the way, impart knowledge about the topic at hand. Especially when they're on a subject I'm eager to learn more about.</p><p>While reading the article a couple of things struck me.</p><h2>Stateless dataflow</h2><p>First, I'd not really heard of the phrase &quot;stateless dataflow&quot; (and its opposite &quot;stateful dataflow&quot;). I did look it up via Google and found that there were <a href="https://www.google.com/search?q=%22stateless+(dataflow%7Cdata-flow)">very few results</a>, most of them being scholarly papers either in PDF or even PostScript form. So I sort of forgave myself for not really knowing what was implied, although I had taken a guess anyway.</p><p>Basically the author was explaining that the reason for finding the <code>jq</code> language difficult was down to the computational model. I don't think <code>jq</code> is the easiest language, and in my experience so far that is down to a number of things, not least the relative terseness of the official manual, but also my inability to grasp powerful constructs, as well as having to manipulate complex object and array structures in my head, not only statically, but also having to imagine how they might change when processed through filters.</p><p>It seems that the author's issue with the &quot;stateless dataflow&quot; was down to the fact that what's being processed by <code>jq</code> is very often a <em>stream</em> of discrete JSON values, rather than a single value.</p><h2>JSON values</h2><p>So what do I mean by &quot;JSON value&quot;? Well, in the article <a href="https://www.json.org/json-en.html">Introducing JSON</a> there's a McKeeman form expressing the JSON grammar, and the building blocks of what we know as JSON are described as &quot;JSON values&quot; thus:</p><pre><code>value
  object
  array
  string
  number
  &quot;true&quot;
  &quot;false&quot;
  &quot;null&quot;
</code></pre><p>These JSON values are described as fundamental building blocks in <a href="https://datatracker.ietf.org/doc/html/rfc8259#section-3">RFC 8259</a>.</p><p>Anything expressed in JSON will be one of these value types. This is why, for example, <code>&quot;hello world&quot;</code> is valid JSON, as is <code>42</code>.</p><h2>Processing JSON with jq</h2><p>In the &quot;Invoking jq&quot; section of the <a href="https://stedolan.github.io/jq/manual/">manual</a>, it says:</p><blockquote><p>jq filters run on a stream of JSON data. The input to jq is parsed as a sequence of whitespace-separated JSON values which are passed through the provided filter one at a time. The output(s) of the filter are written to standard out, again as a sequence of whitespace-separated JSON data.</p></blockquote><p>Key for me, in my journey towards a deeper understanding of <code>jq</code>, is that the &quot;filter&quot; here is the entire <code>jq</code> program, whether that's something short expressed literally on the command line, or in a file, pointed to with the <code>--from-file</code> or <code>-f</code> option.</p><p>So each and every JSON value that is passed into <code>jq</code> is processed by the entire program.</p><p>There's the &quot;slurp&quot; option (with <code>--slurp</code> or <code>-s</code>) which will &quot;read the entire input stream into a large array and run the filter just once&quot;. This is maybe what one might initially assume or expect <code>jq</code> to do, but one needs to be explicit.</p><p>Perhaps a small example might help, based on a sequence of JSON values that we can produce with <a href="https://linux.die.net/man/1/seq">seq</a>:</p><pre class="language-bash"><code class="language-bash"><span class="token function">seq</span> <span class="token number">3</span></code></pre><p>produces:</p><pre><code>1
2
3
</code></pre><p>If we pass this sequence of JSON values through the simplest of <code>jq</code> filters -- the <a href="https://stedolan.github.io/jq/manual/#Identity:.">identity</a> function -- like this:</p><pre class="language-bash"><code class="language-bash"><span class="token function">seq</span> <span class="token number">3</span> <span class="token operator">|</span> jq <span class="token builtin class-name">.</span></code></pre><p>then we get this:</p><pre><code>1
2
3
</code></pre><p>One might think &quot;well, what else would you expect?&quot; but this illustrates the nature of running discrete JSON values through a filter quite nicely.</p><p>Before we continue, let's use the <code>--compact-output</code> (or <code>-c</code>) option here:</p><pre class="language-bash"><code class="language-bash"><span class="token function">seq</span> <span class="token number">3</span> <span class="token operator">|</span> jq -c <span class="token builtin class-name">.</span></code></pre><p>The output is the same:</p><pre><code>1
2
3
</code></pre><p>For me, this drives home the &quot;discrete JSON values&quot; approach to both <code>jq</code>'s input and output processing - there are three discrete values in, and three out.</p><h2>Stateless</h2><p>I guess this also helps explain what the author of the article means by &quot;stateless&quot;. As far as the filter is concerned, it's seeing the values <code>1</code>, <code>2</code> and <code>3</code> separately and in new contexts each time. And as the article illustrates, this is where <code>jq</code>'s <code>--slurp</code> (or <code>-s</code>) option comes in. Adding the option to the above example:</p><pre class="language-bash"><code class="language-bash"><span class="token function">seq</span> <span class="token number">3</span> <span class="token operator">|</span> jq -c -s <span class="token builtin class-name">.</span></code></pre><p>produces this:</p><pre><code>[1,2,3]
</code></pre><p>A <em>single JSON value</em>. This is because what the filter received was actually this:</p><pre class="language-json"><code class="language-json"><span class="token punctuation">[</span><br>  <span class="token number">1</span><span class="token punctuation">,</span><br>  <span class="token number">2</span><span class="token punctuation">,</span><br>  <span class="token number">3</span><br><span class="token punctuation">]</span></code></pre><p>Three discrete values, but wrapped in an outer enclosing array. A single JSON value, in the form of an array. And being the simple identity function, just regurgitating what it reads, produces in turn that same, single JSON value as output. On one line here, rather than pretty printed with more whitespace, because of the <code>-c</code> option.</p><h2>Stateful</h2><p>The <code>--slurp</code> option brings about a sort of statefulness, in that every discrete JSON value, previously independent, now share the same single context of the single invocation of the <code>jq</code> filter.</p><p>Changing the filter from the <code>.</code> identity function to the <code>add</code> function* demonstrates this singular context, this &quot;statefulness&quot;:</p><pre class="language-bash"><code class="language-bash"><span class="token function">seq</span> <span class="token number">3</span> <span class="token operator">|</span> jq -s <span class="token function">add</span></code></pre><p>This yields the single JSON value:</p><pre><code>6
</code></pre><p>*I'm calling them &quot;functions&quot;, but the manual actually calls them &quot;filters&quot;</p><h2>Syntactic sugar</h2><p>There's one more observation I'd like to make in these ramblings. The article describes the task of adding up the numbers here:</p><pre class="language-bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token string">'[1,2,3] [4,5,6]'</span></code></pre><p>In other words, the result should be 21.</p><p>We know by now that this:</p><pre><code>[1,2,3] [4,5,6]
</code></pre><p>is actually two discrete JSON values. Two arrays. So, as the author demonstrates, the <code>--slurp</code> option is called for, thus:</p><pre class="language-bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token string">'[1,2,3] [4,5,6]'</span> <span class="token operator">|</span> jq -s <span class="token string">'[.[] | add] | add'</span></code></pre><p>So in this invocation, the filter is executed once only, and actually receives:</p><pre class="language-json"><code class="language-json"><span class="token punctuation">[</span><br>  <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><br>  <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><br><span class="token punctuation">]</span></code></pre><p>The article does a great job of describing the author's thought process here, and also showing how some of the basic filters work. And I guess the filter used here is possibly deliberately complex, or at least contrived to illustrate a point:</p><pre><code>[.[] | add] | add
</code></pre><p>However to be fair on the language, it has some syntactic sugar in the form of <a href="https://stedolan.github.io/jq/manual/#map(x),map_values(x)">map</a>. In the description, we read:</p><blockquote><p><code>map(x)</code> is equivalent to <code>[.[] | x]</code>. In fact, this is how it's defined.</p></blockquote><p>And we can see this definition in <code>jq</code>'s source, specifically in the <a href="https://github.com/stedolan/jq/blob/a9f97e9e61a910a374a5d768244e8ad63f407d3e/src/builtin.jq#L3">builtin.jq</a> file:</p><pre><code>def map(f): [.[] | f];
</code></pre><p>This definition helps the mental model, and helps me a lot, not only to reduce noise, but also to relate the computation to an arguably well-known function (map). So the entire line turns into a much simpler:</p><pre class="language-bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token string">'[1,2,3] [4,5,6]'</span> <span class="token operator">|</span> jq -s <span class="token string">'map(add) | add'</span></code></pre><h2>Wrapping up</h2><p>This has turned into a bit of a longer ramble, beyond what I'd originally <a href="https://lobste.rs/s/uhkwhn/introducing_zq_easier_faster#c_ue6azr">commented</a>. But writing it has helped me think about this a bit more. Perhaps it helps you too - I hope so!</p><p>And most importantly, my thoughts in this post should not detract from the article nor from their conclusions with zq - more power to them!</p></main><aside class="post__aside"><div class="post__tags"><a href="/tags/jq/">#jq</a> <a href="/tags/lobsters/">#lobsters</a></div><style>.utterances {
  margin-left: inherit !important;
}</style><script src="https://utteranc.es/client.js" repo="qmacro/qmacro.github.io" issue-term="title" crossorigin="anonymous" async></script><nav class="post__pagination"><a href="/blog/posts/2022/05/06/converting-strings-to-objects-with-jq/"><span>←</span> <span>Converting strings to objects with jq</span> </a><a href="/blog/posts/2022/04/17/bash-notes-3/"><span>Bash notes 3</span> <span>→</span></a></nav></aside></article></main><footer class="footer"><div class="footer__content"><ul class="hero__social-links"><li><a href="https://github.com/qmacro" target="_blank" rel="noopener noreferrer">GitHub</a></li><li><a href="https://www.youtube.com/djadams-qmacro" target="_blank" rel="noopener noreferrer">YouTube</a></li><li><a href="https://twitter.com/qmacro" target="_blank" rel="noopener noreferrer">Twitter</a></li><li><a href="/feed.xml" target="_blank" rel="noopener noreferrer">RSS</a></li></ul></div></footer></div><script src="/assets/main.31d6cfe0d16ae931b73c.js"></script></body></html>