<!doctype html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="canonical" href="https://qmacro.org/blog/posts/2022/05/06/converting-strings-to-objects-with-jq/"><link href="/assets/main.abc736e4654d9e4a3a50.css" rel="stylesheet"><link rel="preconnect" href="https://fonts.gstatic.com"><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans&display=swap" rel="stylesheet"><title>Converting strings to objects with jq | DJ Adams</title><link rel="icon" type="“image/x-icon”" href="/images/favicon.ico"><meta property="og:title" content="Converting strings to objects with jq"><meta property="og:site_name" content="DJ Adams"><meta property="og:type" content="website"><meta property="og:url" content="https://qmacro.org/blog/posts/2022/05/06/converting-strings-to-objects-with-jq/"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:creator" content="@qmacro"><meta name="description" content="Converting strings to objects with jq 06 May 2022 | 6 min read In preparing some data for another upcoming blog post (now published:..."><meta property="og:description" content="Converting strings to objects with jq 06 May 2022 | 6 min read In preparing some data for another upcoming blog post (now published:..."><meta name="description" content="Converting strings to objects with jq 06 May 2022 | 6 min read In preparing some data for another upcoming blog post (now published:..."><meta property="og:image" content="https://qmacro.org/images/DJA-head.png"><meta name="twitter:image" content="https://qmacro.org/images/DJA-head.png"><script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script><script>mermaid.initialize({startOnLoad:true});</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-4WQKBG0L4Y"></script><script>window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-4WQKBG0L4Y');</script></head><body><div class="layout-wrapper"><header class="header"><div class="header__content"><h1 class="site-title"><a href="/">DJ Adams</a></h1><nav class="nav"><ul class="nav__list"><li class="nav-item"><a href="/about">About Me</a></li><li class="nav-item"><a href="/talks">Talks</a></li><li class="nav-item"><a href="/blog">Blog</a></li><li class="nav-item"><a href="/feed.xml">Feed</a></li></ul></nav></div></header><main class="main"><article class="post"><header class="post__header"><h1>Converting strings to objects with jq</h1><div class="post__details"><time datetime="2022-05-06">06 May 2022 </time><span>| </span><span>6 min read</span></div></header><main class="post__content"><p>In preparing some data for another upcoming blog post (now published: <a href="/blog/posts/2022/05/07/exploring-github-repo-name-distribution-with-jq/">Exploring GitHub repo name distribution with jq</a>), I needed to convert a list of fully qualified GitHub repository names into a JSON array of single-property objects (to reflect the style of JSON output from GitHub's <code>gh</code> CLI). I achieved this with a short jq filter. Here's how, recorded here, with my working thoughts, mostly for my outboard memory.</p><h2>The starting data</h2><p>For <a href="/blog/posts/2022/05/07/exploring-github-repo-name-distribution-with-jq/">that other blog post</a> I wanted to start with a list of repositories from GitHub. The list produced by the command I was invoking (<code>gh repo list SAP-samples --limit 10 --public</code>) was fine but to illustrate the wider point of the post I wanted to select specific repository names. So I ended up with a manually edited list like this, in a file called <code>names.txt</code>:</p><pre class="language-text"><code class="language-text">SAP-samples/cloud-sdk-js<br>SAP-samples/cloud-cap-samples-java<br>SAP-samples/btp-setup-automator<br>SAP-samples/btp-ai-sustainability-bootcamp<br>SAP-samples/cloud-cap-samples<br>SAP-samples/ui5-exercises-codejam<br>SAP-samples/cap-sflight<br>SAP-samples/cloud-cf-feature-flags-sample<br>SAP-samples/cloud-espm-cloud-native<br>SAP-samples/iot-edge-samples</code></pre><h2>The desired output</h2><p>What I wanted was a JSON version of this, where each repository name, minus the organisation prefix (<code>SAP-samples/</code>), was represented in a <code>name</code> property in an object, with all of them wrapped in an outer array, like this:</p><pre class="language-json"><code class="language-json"><span class="token punctuation">[</span><br>  <span class="token punctuation">{</span><br>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"cloud-sdk-js"</span><br>  <span class="token punctuation">}</span><span class="token punctuation">,</span><br>  <span class="token punctuation">{</span><br>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"cloud-cap-samples-java"</span><br>  <span class="token punctuation">}</span><span class="token punctuation">,</span><br>  <span class="token punctuation">{</span><br>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"btp-setup-automator"</span><br>  <span class="token punctuation">}</span><span class="token punctuation">,</span><br>  <span class="token punctuation">{</span><br>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"btp-ai-sustainability-bootcamp"</span><br>  <span class="token punctuation">}</span><span class="token punctuation">,</span><br>  <span class="token punctuation">{</span><br>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"cloud-cap-samples"</span><br>  <span class="token punctuation">}</span><span class="token punctuation">,</span><br>  <span class="token punctuation">{</span><br>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"ui5-exercises-codejam"</span><br>  <span class="token punctuation">}</span><span class="token punctuation">,</span><br>  <span class="token punctuation">{</span><br>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"cap-sflight"</span><br>  <span class="token punctuation">}</span><span class="token punctuation">,</span><br>  <span class="token punctuation">{</span><br>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"cloud-cf-feature-flags-sample"</span><br>  <span class="token punctuation">}</span><span class="token punctuation">,</span><br>  <span class="token punctuation">{</span><br>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"cloud-espm-cloud-native"</span><br>  <span class="token punctuation">}</span><span class="token punctuation">,</span><br>  <span class="token punctuation">{</span><br>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"iot-edge-samples"</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">]</span></code></pre><h2>Looking at jq options</h2><p>First off, the content of the text file is lines of raw text, so I'll need to use the <code>--raw-input</code> (<code>-R</code>) option to tell <code>jq</code> that.</p><p>Incidentally, if the lines of the file had been like this (where each line was enclosed in double quotes):</p><pre class="language-text"><code class="language-text">"SAP-samples/cloud-sdk-js"<br>"SAP-samples/cloud-cap-samples-java"<br>"SAP-samples/btp-setup-automator"<br>...</code></pre><p>then I wouldn't have needed this option, as these lines are all valid JSON values (a double-quoted string is a valid JSON value).</p><p>While thinking of command line options, I then considered the <code>--slurp</code> (<code>-s</code>) option. This is because I was thinking about gathering up the entire input to pass through the filter once, because I needed the final result to be enclosed in a single, outer array. For more on slurping and statelessness, you may like to read <a href="/blog/posts/2022/05/02/some-thoughts-on-jq-and-statelessness/">Some thoughts on jq and statelessness</a>.</p><p>What I noticed is that <code>--slurp</code> has a very specific effect when used with the <code>--raw-input</code> option, as described in the manual - see the second sentence here:</p><blockquote><p><code>--raw-input</code> : Don't parse the input as JSON. Instead, each line of text is passed to the filter as a string. If combined with <code>--slurp</code>, then the entire input is passed to the filter as a single long string.</p></blockquote><p>This would be a way to read all the repository names in at once, which would give me a chance to output them, transformed, in an enclosing array.</p><h3>Trying --slurp</h3><p>So let's start by looking at the effect of the combination of these two options, when processing the input data with the simple identity filter (<code>.</code>). With this invocation:</p><pre class="language-bash"><code class="language-bash">jq -s -R <span class="token builtin class-name">.</span> names.txt</code></pre><p>we get this, a single string:</p><pre><code>&quot;SAP-samples/cloud-sdk-js\nSAP-samples/cloud-cap-samples-java\nSAP-samples/btp-setup-automator\nSAP-samples/btp-ai-sustainability-bootcamp\nSAP-samples/cloud-cap-samples\nSAP-samples/ui5-exercises-codejam\nSAP-samples/cap-sflight\nSAP-samples/cloud-cf-feature-flags-sample\nSAP-samples/cloud-espm-cloud-native\nSAP-samples/iot-edge-samples\n&quot;
</code></pre><p>At first I thought I could simply then separate the names by using <code>split</code> to chop up on what looked to be a newline (<code>\n</code>) character separating each one; this would be ideal as <code>split</code> produces an array, which is exactly what I'm looking for:</p><pre class="language-bash"><code class="language-bash">jq -s -R <span class="token string">'split("\n")'</span> names.txt</code></pre><p>But this wasn't quite right, producing this:</p><pre class="language-json"><code class="language-json"><span class="token punctuation">[</span><br>  <span class="token string">"SAP-samples/cloud-sdk-js"</span><span class="token punctuation">,</span><br>  <span class="token string">"SAP-samples/cloud-cap-samples-java"</span><span class="token punctuation">,</span><br>  <span class="token string">"SAP-samples/btp-setup-automator"</span><span class="token punctuation">,</span><br>  <span class="token string">"SAP-samples/btp-ai-sustainability-bootcamp"</span><span class="token punctuation">,</span><br>  <span class="token string">"SAP-samples/cloud-cap-samples"</span><span class="token punctuation">,</span><br>  <span class="token string">"SAP-samples/ui5-exercises-codejam"</span><span class="token punctuation">,</span><br>  <span class="token string">"SAP-samples/cap-sflight"</span><span class="token punctuation">,</span><br>  <span class="token string">"SAP-samples/cloud-cf-feature-flags-sample"</span><span class="token punctuation">,</span><br>  <span class="token string">"SAP-samples/cloud-espm-cloud-native"</span><span class="token punctuation">,</span><br>  <span class="token string">"SAP-samples/iot-edge-samples"</span><span class="token punctuation">,</span><br>  <span class="token string">""</span><br><span class="token punctuation">]</span></code></pre><p>What's that random empty string at the end?</p><p>Turns out that I wasn't staring hard enough at the single string; the newline characters weren't used to &quot;join&quot; each string, they were just there because each of the strings themselves included a newline.</p><p>In other words, they weren't separators, they were just part of the data, and so the last newline at the end of the last string &quot;SAP-samples/iot-edge-samples&quot; meant that <code>split</code> would produce a final empty value, i.e. what it found to the right of the last newline character, as we can see in the last array position above (<code>&quot;&quot;</code>).</p><h3>Avoiding or cleaning up the extra empty value</h3><p>Of course, I was tempted to munge the input data before even feeding it to <code>jq</code>, so each repository name <em>would</em> be a valid JSON value. I would do this by enclosing each of them in double quotes. But that wasn't what I was looking to do here, I wanted to use <code>jq</code> on its own.</p><p>Another way would be just to ignore the last value in the array, like this:</p><pre class="language-bash"><code class="language-bash">jq -s -R <span class="token string">'split("\n") | .[:-1]'</span> names.txt</code></pre><p>This makes use of the <a href="https://stedolan.github.io/jq/manual/#Array/StringSlice:.%5B10:15%5D">array slice</a>, where the second filter <code>.[:-1]</code> says to return all the array elements up to but not including the last one, producing the basics of what we're looking for:</p><pre class="language-json"><code class="language-json"><span class="token punctuation">[</span><br>  <span class="token string">"SAP-samples/cloud-sdk-js"</span><span class="token punctuation">,</span><br>  <span class="token string">"SAP-samples/cloud-cap-samples-java"</span><span class="token punctuation">,</span><br>  <span class="token string">"SAP-samples/btp-setup-automator"</span><span class="token punctuation">,</span><br>  <span class="token string">"SAP-samples/btp-ai-sustainability-bootcamp"</span><span class="token punctuation">,</span><br>  <span class="token string">"SAP-samples/cloud-cap-samples"</span><span class="token punctuation">,</span><br>  <span class="token string">"SAP-samples/ui5-exercises-codejam"</span><span class="token punctuation">,</span><br>  <span class="token string">"SAP-samples/cap-sflight"</span><span class="token punctuation">,</span><br>  <span class="token string">"SAP-samples/cloud-cf-feature-flags-sample"</span><span class="token punctuation">,</span><br>  <span class="token string">"SAP-samples/cloud-espm-cloud-native"</span><span class="token punctuation">,</span><br>  <span class="token string">"SAP-samples/iot-edge-samples"</span><br><span class="token punctuation">]</span></code></pre><p>While this would be perfectly practical, creating and then removing unwanted data elements didn't feel entirely agreeable to me today, so I looked for another approach.</p><h2>Using inputs</h2><p>On my <a href="https://www.strava.com/activities/7101292856">walk</a>, thinking about this, I decided to see if there were any approaches that didn't involve the use of the <code>--slurp</code> option. And there was, in the form of <a href="https://stedolan.github.io/jq/manual/#inputs">inputs</a>, which, according to the manual:</p><blockquote><p>outputs all remaining inputs, one by one.</p></blockquote><p>This suggested to me that if I were to call <code>inputs</code> at the start, I'd likely get all but the first string, and this was the case:</p><pre class="language-bash"><code class="language-bash">jq -R inputs names.txt</code></pre><p>This produced this:</p><pre class="language-json"><code class="language-json"><span class="token string">"SAP-samples/cloud-cap-samples-java"</span><br><span class="token string">"SAP-samples/btp-setup-automator"</span><br><span class="token string">"SAP-samples/btp-ai-sustainability-bootcamp"</span><br><span class="token string">"SAP-samples/cloud-cap-samples"</span><br><span class="token string">"SAP-samples/ui5-exercises-codejam"</span><br><span class="token string">"SAP-samples/cap-sflight"</span><br><span class="token string">"SAP-samples/cloud-cf-feature-flags-sample"</span><br><span class="token string">"SAP-samples/cloud-espm-cloud-native"</span><br><span class="token string">"SAP-samples/iot-edge-samples"</span></code></pre><p>The first string</p><pre class="language-json"><code class="language-json"><span class="token string">"SAP-samples/cloud-sdk-js"</span></code></pre><p>was missing, as it was already &quot;consumed&quot; ... but happily available in <code>.</code>. So I could <a href="https://stedolan.github.io/jq/manual/#Arrayconstruction:%5B%5D">construct an array</a> directly at the start of the filter program, like this:</p><pre class="language-bash"><code class="language-bash">jq -R <span class="token string">'[.,inputs]'</span> names.txt</code></pre><blockquote><p>See the end of this post for an update on this.</p></blockquote><p>Lo and behold, it seems that this is exactly the sort of thing I'm looking to start with:</p><pre class="language-json"><code class="language-json"><span class="token punctuation">[</span><br>  <span class="token string">"SAP-samples/cloud-sdk-js"</span><span class="token punctuation">,</span><br>  <span class="token string">"SAP-samples/cloud-cap-samples-java"</span><span class="token punctuation">,</span><br>  <span class="token string">"SAP-samples/btp-setup-automator"</span><span class="token punctuation">,</span><br>  <span class="token string">"SAP-samples/btp-ai-sustainability-bootcamp"</span><span class="token punctuation">,</span><br>  <span class="token string">"SAP-samples/cloud-cap-samples"</span><span class="token punctuation">,</span><br>  <span class="token string">"SAP-samples/ui5-exercises-codejam"</span><span class="token punctuation">,</span><br>  <span class="token string">"SAP-samples/cap-sflight"</span><span class="token punctuation">,</span><br>  <span class="token string">"SAP-samples/cloud-cf-feature-flags-sample"</span><span class="token punctuation">,</span><br>  <span class="token string">"SAP-samples/cloud-espm-cloud-native"</span><span class="token punctuation">,</span><br>  <span class="token string">"SAP-samples/iot-edge-samples"</span><br><span class="token punctuation">]</span></code></pre><p>Now that I had the basic structure, it was then just a matter of modifying each element, from a string to an object. Moreover, given that I had the elements where I wanted them, in an outer array, it would seem sensible at this point onwards to express the transformations required via <a href="https://stedolan.github.io/jq/manual/#map(x),map_values(x)">map</a>, which (like <code>map</code> in other languages, I guess it's as much of a paradigm as it is a function or filter), takes an array and produces an array.</p><p>So for example, I could replace each string with its length, while still keeping the structure, by passing the <code>[.,inputs]</code> into <code>map</code> like this:</p><pre class="language-bash"><code class="language-bash">jq -c -R <span class="token string">'[.,inputs] | map(length)'</span> names.txt</code></pre><p>This would produce the following (note I've used the <code>--compact-output</code> (<code>-c</code>) option to save space here):</p><pre class="language-json"><code class="language-json"><span class="token punctuation">[</span><span class="token number">24</span><span class="token punctuation">,</span><span class="token number">34</span><span class="token punctuation">,</span><span class="token number">31</span><span class="token punctuation">,</span><span class="token number">42</span><span class="token punctuation">,</span><span class="token number">29</span><span class="token punctuation">,</span><span class="token number">33</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">41</span><span class="token punctuation">,</span><span class="token number">35</span><span class="token punctuation">,</span><span class="token number">28</span><span class="token punctuation">]</span></code></pre><h2>Transforming the repository name</h2><p>In the modification requirements, I first had to remove the <code>SAP-samples/</code> organisation name prefix, and I turned to <a href="https://stedolan.github.io/jq/manual/#sub(regex;tostring)sub(regex;string;flags)">sub</a> for that, as I'm partial to the occasional regular expression:</p><pre class="language-bash"><code class="language-bash">jq -R <span class="token string">'[.,inputs] | map(sub("^.+/";""))'</span> names.txt</code></pre><p>Mapping the substitution of <code>^.+/</code> (anchored at the start of the line, at least one but possibly more characters, up to and including a forward slash) with nothing (<code>&quot;&quot;</code>) gives this:</p><pre class="language-json"><code class="language-json"><span class="token punctuation">[</span><br>  <span class="token string">"cloud-sdk-js"</span><span class="token punctuation">,</span><br>  <span class="token string">"cloud-cap-samples-java"</span><span class="token punctuation">,</span><br>  <span class="token string">"btp-setup-automator"</span><span class="token punctuation">,</span><br>  <span class="token string">"btp-ai-sustainability-bootcamp"</span><span class="token punctuation">,</span><br>  <span class="token string">"cloud-cap-samples"</span><span class="token punctuation">,</span><br>  <span class="token string">"ui5-exercises-codejam"</span><span class="token punctuation">,</span><br>  <span class="token string">"cap-sflight"</span><span class="token punctuation">,</span><br>  <span class="token string">"cloud-cf-feature-flags-sample"</span><span class="token punctuation">,</span><br>  <span class="token string">"cloud-espm-cloud-native"</span><span class="token punctuation">,</span><br>  <span class="token string">"iot-edge-samples"</span><br><span class="token punctuation">]</span></code></pre><h2>Objectifying the string</h2><p>The second transformation was to make the simple string value into the value for a property called <code>name</code>, within an object.</p><p>So for the first string</p><pre class="language-json"><code class="language-json"><span class="token string">"cloud-sdk-js"</span></code></pre><p>I wanted this:</p><pre class="language-json"><code class="language-json"><span class="token punctuation">{</span><br>  <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"cloud-sdk-js"</span><br><span class="token punctuation">}</span></code></pre><p>Similar to the <a href="https://stedolan.github.io/jq/manual/#Arrayconstruction:%5B%5D">array construction</a> there's also the <a href="https://stedolan.github.io/jq/manual/#ObjectConstruction:%7B%7D">object construction</a>, with which objects can be created on the fly quite easily. And as the manual says:</p><blockquote><p>If the keys are &quot;identifier-like&quot;, then the quotes can be left off</p></blockquote><p>So I can use <code>name</code> rather than <code>&quot;name&quot;</code> for the property, reducing the JSON noise a little:</p><pre class="language-bash"><code class="language-bash">jq -R <span class="token string">'[.,inputs] | map(sub("^.+/";"")) | map({name: .})'</span> names.txt</code></pre><p>This produces:</p><pre class="language-json"><code class="language-json"><span class="token punctuation">[</span><br>  <span class="token punctuation">{</span><br>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"cloud-sdk-js"</span><br>  <span class="token punctuation">}</span><span class="token punctuation">,</span><br>  <span class="token punctuation">{</span><br>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"cloud-cap-samples-java"</span><br>  <span class="token punctuation">}</span><span class="token punctuation">,</span><br>  <span class="token punctuation">{</span><br>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"btp-setup-automator"</span><br>  <span class="token punctuation">}</span><span class="token punctuation">,</span><br>  <span class="token punctuation">{</span><br>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"btp-ai-sustainability-bootcamp"</span><br>  <span class="token punctuation">}</span><span class="token punctuation">,</span><br>  <span class="token punctuation">{</span><br>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"cloud-cap-samples"</span><br>  <span class="token punctuation">}</span><span class="token punctuation">,</span><br>  <span class="token punctuation">{</span><br>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"ui5-exercises-codejam"</span><br>  <span class="token punctuation">}</span><span class="token punctuation">,</span><br>  <span class="token punctuation">{</span><br>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"cap-sflight"</span><br>  <span class="token punctuation">}</span><span class="token punctuation">,</span><br>  <span class="token punctuation">{</span><br>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"cloud-cf-feature-flags-sample"</span><br>  <span class="token punctuation">}</span><span class="token punctuation">,</span><br>  <span class="token punctuation">{</span><br>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"cloud-espm-cloud-native"</span><br>  <span class="token punctuation">}</span><span class="token punctuation">,</span><br>  <span class="token punctuation">{</span><br>    <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"iot-edge-samples"</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">]</span></code></pre><p>Actually we can reduce the filter a little here, by including the object construction within the first <code>map</code>, like this:</p><pre class="language-bash"><code class="language-bash">jq -R <span class="token string">'[.,inputs] | map(sub("^.+/";"") | {name: .})'</span> names.txt</code></pre><p>and it produces exactly the same thing. And what it produces, is what we're looking for.</p><h2>Wrapping up</h2><p>So there we are, I can now produce a simulation of what <code>gh</code>'s JSON output creates, from a flat list of simple strings, using a modest filter with <code>jq</code>. Of course, there are other ways of achieving this, but I'm happy with this for now.</p><hr><p>There is some brief discussion of this post on <a href="https://news.ycombinator.com/item?id=31293982#31294281">Hacker News</a> and <a href="https://lobste.rs/s/qi5tge/converting_strings_objects_with_jq">Lobsters</a>.</p><hr><p>Update: in the middle of the night last night, after publishing this post, I woke up and suddenly realised that I could make this even neater, by the use of the <code>--null-input</code> (<code>-n</code>) option, which is described as follows:</p><blockquote><p>Don't read any input at all! Instead, the filter is run once using null as the input.</p></blockquote><p>That in turn means that I could avoid the two-item list of <code>.</code> and <code>inputs</code>, and simply have:</p><pre class="language-bash"><code class="language-bash">jq -R -n <span class="token string">'[inputs]'</span> names.txt</code></pre><p>I do still have a place in my heart for <code>[.,inputs]</code> because it reminds me of the fundamental &quot;first and rest&quot;, or &quot;head and tail&quot; concept from functional programming. See the &quot;Subsequent understanding&quot; section in <a href="/blog/posts/2017/02/19/the-beauty-of-recursion-and-list-machinery/">The beauty of recursion and list machinery</a> for more on this, if you're interested.</p></main><aside class="post__aside"><div class="post__tags"><a href="/tags/jq/">#jq</a> <a href="/tags/github/">#github</a></div><style>.utterances {
  margin-left: inherit !important;
}</style><script src="https://utteranc.es/client.js" repo="qmacro/qmacro.github.io" issue-term="title" crossorigin="anonymous" async></script><nav class="post__pagination"><a href="/blog/posts/2022/05/07/exploring-github-repo-name-distribution-with-jq/"><span>←</span> <span>Exploring GitHub repo name distribution with jq</span> </a><a href="/blog/posts/2022/05/02/some-thoughts-on-jq-and-statelessness/"><span>Some thoughts on jq and statelessness</span> <span>→</span></a></nav></aside></article></main><footer class="footer"><div class="footer__content"><ul class="hero__social-links"><li><a href="https://github.com/qmacro" target="_blank" rel="noopener noreferrer">GitHub</a></li><li><a href="https://www.youtube.com/djadams-qmacro" target="_blank" rel="noopener noreferrer">YouTube</a></li><li><a href="https://twitter.com/qmacro" target="_blank" rel="noopener noreferrer">Twitter</a></li><li><a href="/feed.xml" target="_blank" rel="noopener noreferrer">RSS</a></li></ul></div></footer></div><script src="/assets/main.31d6cfe0d16ae931b73c.js"></script></body></html>