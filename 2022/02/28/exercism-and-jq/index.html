<!doctype html>
<html lang="en">
  <head>

  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-4WQKBG0L4Y"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-4WQKBG0L4Y');
  </script>

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Exercism and jq</title>
    <meta name="description" content="Reserving the right to be wrong.">
    <link rel="stylesheet" href="/css/index.css">
    <link rel="stylesheet" href="/css/prism-base16-monokai.dark.css">
    <link rel="alternate" href="/feed/feed.xml" type="application/atom+xml" title="DJ Adams">
    <link rel="alternate" href="/feed/feed.json" type="application/json" title="DJ Adams">
    <link href="https://unpkg.com/prismjs@1.20.0/themes/prism-okaidia.css" rel="stylesheet">
  </head>
  <body>
    <header>
      <h1 class="home"><a href="/">DJ Adams</a></h1>
      <ul class="nav">
        <li class="nav-item"><a href="/">Home</a></li>
        <li class="nav-item"><a href="/about/">About</a></li>
        <li class="nav-item"><a href="/posts/">Archive</a></li>
        <li class="nav-item"><a href="/tags/">Tags</a></li>
        <li class="nav-item"><a href="/feed.xml">Feed</a></li>
      </ul>
    </header>

    <main class="tmpl-post">
      <h1>Exercism and jq</h1>

<time datetime="2022-02-28">28 Feb 2022</time><a href="/tags/jq/" class="post-tag">jq</a><a href="/tags/learning/" class="post-tag">learning</a><a href="/tags/bats/" class="post-tag">bats</a><a href="/tags/shell/" class="post-tag">shell</a>

<p>I wanted to see how a jq track might work in Exercism. Here's what I tried out this morning.</p>
<p><a href="exercism.org">Exercism</a> is a great resource for learning and practising languages. I've dabbled in a couple of tracks and it's a fun and compelling way to iterate and meditate on constructs in the languages you're interested in. One of the very appealing things to me is that as well as a very capable online editor environment, there's a command line interface (CLI) for <a href="https://exercism.org/docs/using/solving-exercises/working-locally">working locally</a>.</p>
<h2 id="digging-into-jq" tabindex="-1">Digging into jq <a class="direct-link" href="#digging-into-jq" aria-hidden="true">#</a></h2>
<p>I've <a href="https://qmacro.org/tags/jq/">recently been digging</a> into <a href="https://stedolan.github.io/jq/">jq</a> and wanting to build my knowledge out beyond the classic one-liners one might normally express in a JSON processing pipeline situation. <code>jq</code> is a complete language, with a functional flavour and there's support for modules, function definitions and more. The <a href="https://stedolan.github.io/jq/manual/">manual</a> felt pretty terse at first, but after a while my brain got used to it.</p>
<p>I thought it might be an interesting exercise to see how a <code>jq</code> track might work with Exercism; initially I just want to perhaps use some of the existing tests to code against, where I provide <code>jq</code> scripts to compute the right answers.</p>
<h2 id="using-the-bash-track-for-jq" tabindex="-1">Using the bash track for jq <a class="direct-link" href="#using-the-bash-track-for-jq" aria-hidden="true">#</a></h2>
<p>As <code>jq</code> is &quot;just another Unix tool&quot; that works well on the command line, it seemed logical to try and start with something similar, which I did - the <code>bash</code> track. Here's what I did to feel my way into this journey. It's early days, and this blog post is more of a reminder to my future self what I did.</p>
<h3 id="downloading-a-bash-track-exercise-as-a-base" tabindex="-1">Downloading a bash track exercise as a base <a class="direct-link" href="#downloading-a-bash-track-exercise-as-a-base" aria-hidden="true">#</a></h3>
<p>Having set myself up for <a href="https://exercism.org/docs/using/solving-exercises/working-locally">working locally</a> I downloaded a simple exercise from the <a href="https://exercism.org/tracks/bash">Bash track</a> - <a href="https://exercism.org/tracks/bash/exercises/reverse-string">Reverse String</a>, and moved it to a new, local <code>jq</code> track directory:</p>
<pre><code># /home/user
; cd work/Exercism/
# /home/user/work/Exercism
; ls
./  ../  bash/
# /home/user/work/Exercism
; mkdir jq
# /home/user/work/Exercism
; exercism download --exercise=reverse-string --track=bash

Downloaded to
/home/user/work/Exercism/bash/reverse-string
# /home/user/work/Exercism
; mv bash/reverse-string jq/
# /home/user/work/Exercism
; cd jq/reverse-string/
# /home/user/work/Exercism/jq/reverse-string/
; ls
./  ../  .exercism/  HELP.md  README.md  bats-extra.bash  reverse_string.bats  reverse_string.sh
# /home/user/work/Exercism/jq/reverse-string
;
</code></pre>
<h3 id="modifying-the-bats-file" tabindex="-1">Modifying the bats file <a class="direct-link" href="#modifying-the-bats-file" aria-hidden="true">#</a></h3>
<p>The <code>bash</code> track uses the <a href="https://github.com/bats-core/bats-core">Bash Automated Testing System</a>, known as <code>bats</code>, for unit testing. The tests are in the <code>reverse_string.bats</code> file and look like this (just the first two tests are shown here):</p>
<pre class="language-bash"><code class="language-bash"><span class="token shebang important">#!/usr/bin/env bats</span><br>load bats-extra<br><br><span class="token comment"># local version: 1.2.0.1</span><br><br>@test <span class="token string">"an empty string"</span> <span class="token punctuation">{</span><br>  <span class="token comment">#[[ $BATS_RUN_SKIPPED == "true" ]] || skip</span><br>  run <span class="token function">bash</span> reverse_string.sh <span class="token string">""</span><br><br>  assert_success<br>  assert_output <span class="token string">""</span><br><span class="token punctuation">}</span><br><br>@test <span class="token string">"a word"</span> <span class="token punctuation">{</span><br>  <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token variable">$BATS_RUN_SKIPPED</span> <span class="token operator">==</span> <span class="token string">"true"</span> <span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">||</span> skip<br>  run <span class="token function">bash</span> reverse_string.sh <span class="token string">"robot"</span><br><br>  assert_success<br>  assert_output <span class="token string">"tobor"</span><br><span class="token punctuation">}</span></code></pre>
<p>I modified each test line (<code>run bash &lt;sometest&gt;.sh &lt;test input&gt;</code>) to reflect a more <code>jq</code> oriented invocation, which looks like this:</p>
<pre><code>run jq -rR -f &lt;sometest&gt;.jq &lt;&lt;&lt; &lt;test input&gt;
</code></pre>
<p>This:</p>
<ul>
<li>invokes <code>jq</code> instead of <code>bash</code></li>
<li>uses the <code>-r</code> flag to tell <code>jq</code> to output raw strings, rather than JSON texts (this means that the value <code>banana</code> would be output as is, rather than <code>&quot;banana&quot;</code> with double quotes; a double-quoted string is valid JSON and <code>jq</code> strives to output valid JSON by default)</li>
<li>uses the <code>-R</code> flag to tell <code>jq</code> to expect raw strings, rather than JSON input</li>
<li>uses the <code>-f</code> flag to point to a file containing the actual <code>jq</code> script (called a &quot;filter&quot;)</li>
<li>provides the input via a <a href="https://qmacro.org/2021/11/07/exploring-fff-part-2-get-ls-colors/#inputoutput-redirection-here-documents-and-here-strings">here string</a> as <code>jq</code> expects the input via STDIN (so far, the <code>&lt;test input&gt;</code> values have been scalar values)</li>
</ul>
<p>This is what the above excerpted unit test file now looks like:</p>
<pre class="language-bash"><code class="language-bash"><span class="token shebang important">#!/usr/bin/env bats</span><br>load bats-extra<br><br><span class="token comment"># local version: 1.2.0.1</span><br><br>@test <span class="token string">"an empty string"</span> <span class="token punctuation">{</span><br>  <span class="token comment">#[[ $BATS_RUN_SKIPPED == "true" ]] || skip</span><br>  run jq -rR -f reverse_string.jq <span class="token operator">&lt;&lt;&lt;</span> <span class="token string">""</span><br><br>  assert_success<br>  assert_output <span class="token string">""</span><br><span class="token punctuation">}</span><br><br>@test <span class="token string">"a word"</span> <span class="token punctuation">{</span><br>  <span class="token punctuation">[</span><span class="token punctuation">[</span> <span class="token variable">$BATS_RUN_SKIPPED</span> <span class="token operator">==</span> <span class="token string">"true"</span> <span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">||</span> skip<br>  run jq -rR -f reverse_string.jq <span class="token operator">&lt;&lt;&lt;</span> <span class="token string">"robot"</span><br><br>  assert_success<br>  assert_output <span class="token string">"tobor"</span><br><span class="token punctuation">}</span></code></pre>
<h3 id="writing-the-solution-file" tabindex="-1">Writing the solution file <a class="direct-link" href="#writing-the-solution-file" aria-hidden="true">#</a></h3>
<p>The solution file supplied by default here is <code>reverse_string.sh</code> and contains some hints as to how to structure the contents. Basically, the file has to be written in such a way that when it's invoked, with the input supplied, it outputs the expected answer.</p>
<p>So here, I created <code>reverse_string.jq</code> to be used instead of the default <code>reverse_string.sh</code>. Having deliberately chosen a simple exercise, here's what my solution looks like in this file:</p>
<pre class="language-jq"><code class="language-jq"><span class="token comment">#!/usr/bin/env jq</span><br><br><span class="token c-style-function function">split</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span> <span class="token operator pipe">|</span> reverse <span class="token operator pipe">|</span> <span class="token c-style-function function">join</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span></code></pre>
<h3 id="running-the-unit-tests" tabindex="-1">Running the unit tests <a class="direct-link" href="#running-the-unit-tests" aria-hidden="true">#</a></h3>
<p>I'm a big fan of <a href="https://eradman.com/entrproject/">entr</a> and used it here to rerun the unit tests every time I changed either them or my solution file <code>reverse_string.jq</code>, like this:</p>
<pre class="language-bash"><code class="language-bash"><span class="token comment"># /home/user/work/Exercism/jq/reverse-string</span><br><span class="token punctuation">;</span> <span class="token function">ls</span> *.bats *.jq <span class="token operator">|</span> entr -c bats reverse_string.bats</code></pre>
<p>This provided me with a lovely unit test result that would automatically update if I modified the solution or even the unit test file itself:</p>
<pre><code> ✓ an empty string
 - a word (skipped)
 - a capitalised word (skipped)
 - a sentence with punctuation (skipped)
 - a palindrome (skipped)
 - an even-sized word (skipped)
 - avoid globbing (skipped)

7 tests, 0 failures, 6 skipped
</code></pre>
<h3 id="activating-the-further-tests" tabindex="-1">Activating the further tests <a class="direct-link" href="#activating-the-further-tests" aria-hidden="true">#</a></h3>
<p>As you can see from the unit test results, only one test (&quot;an empty string&quot;) was executed. The others are skipped. This is by design - see the <a href="https://github.com/exercism/bash/blob/main/exercises/shared/.docs/tests.md#skipped-tests">Skipped tests</a> section of the test documentation.</p>
<p>Activating the further tests is just a matter of commenting out the <code>[[ $BATS_RUN_SKIPPED == &quot;true&quot; ]] || skip</code> line  - note that the first test in the file has this line commented out by default so just that first test is run initially.</p>
<p>Alternatively, as you can see from that line, the <code>BATS_RUN_SKIPPED</code> environment variable can be set to <code>true</code> instead, and all of the tests will be run, like this:</p>
<pre><code># /home/user/work/Exercism/jq/reverse-string
; BATS_RUN_SKIPPED=true bats reverse_string.bats
 ✓ an empty string
 ✓ a word
 ✓ a capitalised word
 ✓ a sentence with punctuation
 ✓ a palindrome
 ✓ an even-sized word
 ✓ avoid globbing

7 tests, 0 failures
</code></pre>
<p>Looks like that <code>jq</code> filter passes all the tests 🎉</p>
<hr>
<p>Anyway, that's as far as I got - I think there could be some mileage in pursuing this approach further. Now it's time for me to use this technique to help me dig into writing a <code>jq</code> filter to solve the <a href="https://exercism.org/tracks/bash/exercises/scrabble-score">Scrabble Score</a> exercise!</p>

<hr>
<style>
.utterances {
  margin-left: inherit !important;
}
</style>
<script src="https://utteranc.es/client.js" repo="qmacro/qmacro.github.io" issue-term="title" crossorigin="anonymous" async></script>

<hr>
<ul><li>Next: <a href="/2022/03/14/setting-up-my-own-cloud-foundry/">Setting up my own Cloud Foundry</a></li><li>Previous: <a href="/2022/02/09/how-i-got-involved-in-the-sap-community/">How I got involved in the SAP community</a></li>
</ul>

    </main>

    <footer></footer>

    <!-- Current page: /2022/02/28/exercism-and-jq/ -->
  </body>
</html>
